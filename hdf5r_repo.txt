Directory Structure:

└── ./
    ├── docker
    │   └── install_all_packages.R
    ├── inst
    │   ├── CWrappers_1.10.0
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   └── remove_c_comments.R
    │   ├── CWrappers_1.10.2
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   └── remove_c_comments.R
    │   ├── CWrappers_1.10.3
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   └── remove_c_comments.R
    │   ├── CWrappers_1.12.0
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   ├── order_struct_by_dependency.R
    │   │   └── remove_c_comments.R
    │   ├── CWrappers_1.8.12
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   └── remove_c_comments.R
    │   ├── CWrappers_1.8.14
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   └── remove_c_comments.R
    │   ├── CWrappers_1.8.16
    │   │   ├── create_constants_wrapper.R
    │   │   ├── create_datatype_wrappers.R
    │   │   ├── createCWrappers.R
    │   │   ├── FindAndReplace.R
    │   │   ├── helperFunctions.R
    │   │   ├── identify_prototypes.R
    │   │   ├── injectionCode.R
    │   │   └── remove_c_comments.R
    │   ├── function_overview
    │   │   └── createFunctionOverview.R
    │   ├── speed_check
    │   │   └── Speed_test.R
    │   └── test_implementations
    │       └── reorder.R
    ├── R
    │   ├── adapt_during_onLoad.R
    │   ├── Common_functions.R
    │   ├── Compound.R
    │   ├── convert.R
    │   ├── factor_ext.R
    │   ├── globalVariables.R
    │   ├── H5constants.R
    │   ├── h5errorHandling.R
    │   ├── h5wrapper.R
    │   ├── hdf5r.R
    │   ├── Helper_functions.R
    │   ├── high_level_UI.R
    │   ├── Misc.R
    │   ├── open_objs.R
    │   ├── R6Classes_H5A.R
    │   ├── R6Classes_H5D.R
    │   ├── R6Classes_H5File.R
    │   ├── R6Classes_H5Group.R
    │   ├── R6Classes_H5P.R
    │   ├── R6Classes_H5R.R
    │   ├── R6Classes_H5S.R
    │   ├── R6Classes_H5T.R
    │   ├── R6Classes.R
    │   └── zzz.R
    ├── tests
    │   ├── testthat
    │   │   ├── test-64bit_support.R
    │   │   ├── test-convert.R
    │   │   ├── test-factor_ext.R
    │   │   ├── test-h5a.R
    │   │   ├── test-h5d.R
    │   │   ├── test-h5error.R
    │   │   ├── test-h5file_h5group.R
    │   │   ├── test-h5I.R
    │   │   ├── test-h5p.R
    │   │   ├── test-h5s.R
    │   │   ├── test-h5t.R
    │   │   ├── test-high_level_UI.R
    │   │   ├── test-links.R
    │   │   ├── test-print.R
    │   │   ├── test-reference.R
    │   │   ├── test-zzz-Attribute.R
    │   │   ├── test-zzz-DataSet-extend.R
    │   │   ├── test-zzz-DataSet-IO-NA.R
    │   │   ├── test-zzz-DataSet-IO.R
    │   │   ├── test-zzz-DataSet-scalar.R
    │   │   ├── test-zzz-DataSet-Select-Subset.R
    │   │   ├── test-zzz-DataSet.R
    │   │   ├── test-zzz-enum.R
    │   │   ├── test-zzz-H5File-Subset.R
    │   │   ├── test-zzz-H5File.R
    │   │   ├── test-zzz-H5Group.R
    │   │   ├── test-zzz-io.R
    │   │   └── test-zzz-vlen.R
    │   └── testthat.R
    ├── tools
    │   └── winlibs.R
    └── vignettes
        └── hdf5r.Rmd



---
File: /docker/install_all_packages.R
---

install.packages(c("devtools", "testthat", "bit64", "knitr", "rmarkdown", "formatR", "nycflights13", "reshape2", "R6"), repos='http://cran.us.r-project.org')
library(devtools)
options(unzip = 'internal')
install_github("hhoeflin/roxygen", force=TRUE)
install_github("hadley/pkgdown")






---
File: /inst/CWrappers_1.10.0/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.10.0/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info_helper_t" | name != "val_size")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))

    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
                          "DT_H5E_error2_t", "DT_H5F_info1_helper_t", "DT_H5F_info1_t",
                          "DT_H5F_info2_super_t", "DT_H5F_info2_free_t", "DT_H5F_info2_sohm_t", "DT_H5F_info2_t", 
                          "DT_H5G_info_t",
                          "DT_H5L_info_helper_t", "DT_H5L_info_t", "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info_t", "DT_H5O_stat_t")
struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.10.0/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, "h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  H5free_memory(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

excluded_funcs_manual <- NULL



api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, excluded_funcs_manual, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.10.0/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}

################################
### Replace H5F_info2_t
################################

H5Fpublic_what <- "typedef struct H5F_info2_t \\{.*\\} H5F_info2_t;"

H5Fpublic_replace <- "typedef struct H5F_info2_t {
    H5F_info2_super_t super;
    H5F_info2_free_t free;
    H5F_info2_sohm_t sohm;
} H5F_info2_t;"

H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)


################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info1_t \\{.*\\} H5F_info1_t;"
H5Fpublic_replace <- "typedef struct H5F_info1_t {
    hsize_t		super_ext_size;	
    H5F_info1_helper_t sohm;
} H5F_info1_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_info_what <- "typedef struct H5O_info_t \\{.*\\} H5O_info_t;"

H5Opublic_info_replace  <- "typedef struct H5O_info_t {
    unsigned long 	fileno;		
    haddr_t 		addr;		
    H5O_type_t 		type;		
    unsigned 		rc;		
    time_t		atime;		
    time_t		mtime;		
    time_t		ctime;		
    time_t		btime;		
    hsize_t 		num_attrs;	
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_info_t;"
fileReplace(H5Opublic_file, H5Opublic_info_what, H5Opublic_info_replace)

################################
### Replace H5L_info_t
################################


H5Lpublic_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_what <- "typedef struct \\{.*\\} H5L_info_t;"
H5Lpublic_replace <- "typedef struct H5L_info_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info_helper_t u;
} H5L_info_t;"
fileReplace(H5Lpublic_file, H5Lpublic_what, H5Lpublic_replace)


################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)


################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.10.0/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.10.0/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "PL", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop("Don't know a type that is needed here")
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.10.0/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.10.0/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/CWrappers_1.10.2/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.10.2/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info_helper_t" | name != "val_size")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))

    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
                          "DT_H5E_error2_t", "DT_H5F_info1_helper_t", "DT_H5F_info1_t",
                          "DT_H5F_info2_super_t", "DT_H5F_info2_free_t", "DT_H5F_info2_sohm_t", "DT_H5F_info2_t", 
                          "DT_H5G_info_t",
                          "DT_H5L_info_helper_t", "DT_H5L_info_t", "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info_t", "DT_H5O_stat_t")
struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.10.2/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, "h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  H5free_memory(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

excluded_funcs_manual <- NULL



api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, excluded_funcs_manual, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.10.2/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}

################################
### Replace H5F_info2_t
################################

H5Fpublic_what <- "typedef struct H5F_info2_t \\{.*\\} H5F_info2_t;"

H5Fpublic_replace <- "typedef struct H5F_info2_t {
    H5F_info2_super_t super;
    H5F_info2_free_t free;
    H5F_info2_sohm_t sohm;
} H5F_info2_t;"

H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)


################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info1_t \\{.*\\} H5F_info1_t;"
H5Fpublic_replace <- "typedef struct H5F_info1_t {
    hsize_t		super_ext_size;	
    H5F_info1_helper_t sohm;
} H5F_info1_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_info_what <- "typedef struct H5O_info_t \\{.*\\} H5O_info_t;"

H5Opublic_info_replace  <- "typedef struct H5O_info_t {
    unsigned long 	fileno;		
    haddr_t 		addr;		
    H5O_type_t 		type;		
    unsigned 		rc;		
    time_t		atime;		
    time_t		mtime;		
    time_t		ctime;		
    time_t		btime;		
    hsize_t 		num_attrs;	
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_info_t;"
fileReplace(H5Opublic_file, H5Opublic_info_what, H5Opublic_info_replace)

################################
### Replace H5L_info_t
################################


H5Lpublic_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_what <- "typedef struct \\{.*\\} H5L_info_t;"
H5Lpublic_replace <- "typedef struct H5L_info_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info_helper_t u;
} H5L_info_t;"
fileReplace(H5Lpublic_file, H5Lpublic_what, H5Lpublic_replace)


################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)


################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.10.2/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.10.2/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "PL", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop("Don't know a type that is needed here")
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.10.2/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.10.2/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/CWrappers_1.10.3/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.10.3/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info_helper_t" | name != "val_size")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))

    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
                          "DT_H5E_error2_t", "DT_H5F_info1_helper_t", "DT_H5F_info1_t",
                          "DT_H5F_info2_super_t", "DT_H5F_info2_free_t", "DT_H5F_info2_sohm_t", "DT_H5F_info2_t", 
                          "DT_H5G_info_t",
                          "DT_H5L_info_helper_t", "DT_H5L_info_t", "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info_t", "DT_H5O_stat_t")
struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.10.3/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, "h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  H5free_memory(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

excluded_funcs_manual <- NULL



api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, excluded_funcs_manual, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.10.3/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}

################################
### Replace H5F_info2_t
################################

H5Fpublic_what <- "typedef struct H5F_info2_t \\{.*\\} H5F_info2_t;"

H5Fpublic_replace <- "typedef struct H5F_info2_t {
    H5F_info2_super_t super;
    H5F_info2_free_t free;
    H5F_info2_sohm_t sohm;
} H5F_info2_t;"

H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)


################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info1_t \\{.*\\} H5F_info1_t;"
H5Fpublic_replace <- "typedef struct H5F_info1_t {
    hsize_t		super_ext_size;	
    H5F_info1_helper_t sohm;
} H5F_info1_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_info_what <- "typedef struct H5O_info_t \\{.*\\} H5O_info_t;"

H5Opublic_info_replace  <- "typedef struct H5O_info_t {
    unsigned long 	fileno;		
    haddr_t 		addr;		
    H5O_type_t 		type;		
    unsigned 		rc;		
    time_t		atime;		
    time_t		mtime;		
    time_t		ctime;		
    time_t		btime;		
    hsize_t 		num_attrs;	
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_info_t;"
fileReplace(H5Opublic_file, H5Opublic_info_what, H5Opublic_info_replace)

################################
### Replace H5L_info_t
################################


H5Lpublic_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_what <- "typedef struct \\{.*\\} H5L_info_t;"
H5Lpublic_replace <- "typedef struct H5L_info_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info_helper_t u;
} H5L_info_t;"
fileReplace(H5Lpublic_file, H5Lpublic_what, H5Lpublic_replace)


################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)


################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.10.3/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.10.3/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "PL", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop("Don't know a type that is needed here")
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.10.3/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.10.3/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/CWrappers_1.12.0/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.12.0/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
library(igraph)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))

source("order_struct_by_dependency.R")
struct_info <- order_struct_by_dependency(struct_info)
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info1_helper_t" | name != "val_size")
struct_info <- subset(struct_info, category_name != "H5L_info2_helper_t" | name != "val_size")
struct_info <- subset(struct_info, category_name != "H5R_ref_helper_t" | name != "align")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))
#    code <- c(code, paste0('  Rprintf("Creating DT_', struct_name, '\\n");'))
    
    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
#    	code <- c(code, paste0('  Rprintf("  Working on: ', struct_info$name[i], ' with h5type ', h5_dt_name, '\\n");'))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

# struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
#                          "DT_H5E_error2_t", "DT_H5F_info1_helper_t", "DT_H5F_info1_t",
#                          "DT_H5F_info2_super_t", "DT_H5F_info2_free_t", "DT_H5F_info2_sohm_t", "DT_H5F_info2_t", 
#                          "DT_H5G_info_t",
#                          "DT_H5L_info1_helper_t", "DT_H5L_info1_t", "DT_H5L_info2_helper_t", "DT_H5L_info2_t", 
#			  "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
#                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info2_t", "DT_H5O_stat_t")
# struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.12.0/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  H5free_memory(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

# note: commented lines are excluded as they can't be wrapped anyway; they have functions as
# parameters that can't be used from inside R
func_mapping_112 <- rbind(
    data.frame(func_name="H5Lget_info1", func_mapped="H5Lget_info", exclude="H5Lget_info2", stringsAsFactors=FALSE),
    data.frame(func_name="H5Lget_info_by_idx1", func_mapped="H5Lget_info_by_idx", exclude="H5Lget_info_by_idx2", stringsAsFactors=FALSE),
#    data.frame(func_name="H5Literate1", func_mapped="H5Literate", exclude="H5Literate2", stringsAsFactors=FALSE),
#    data.frame(func_name="H5Literate_by_name1", func_mapped="H5Literate_by_name", exclude="H5Literate_by_name2", stringsAsFactors=FALSE),
#    data.frame(func_name="H5Lvisit1", func_mapped="H5Lvisit", exclude="H5Lvisit2", stringsAsFactors=FALSE),
#    data.frame(func_name="H5Lvisit_by_name1", func_mapped="H5Lvisit_by_name", exclude="H5Lvisit_by_name2", stringsAsFactors=FALSE),
    data.frame(func_name="H5Oget_info1", func_mapped="H5Oget_info", exclude="H5Oget_info3", stringsAsFactors=FALSE),
    data.frame(func_name="H5Oget_info_by_idx1", func_mapped="H5Oget_info_by_idx", exclude="H5Oget_info_by_idx3", stringsAsFactors=FALSE),
    data.frame(func_name="H5Oget_info_by_name1", func_mapped="H5Oget_info_by_name", exclude="H5Oget_info_by_name3", stringsAsFactors=FALSE),
#    data.frame(func_name="H5Ovisit1", func_mapped="H5Ovisit", exclude="H5Ovisit3", stringsAsFactors=FALSE),
#    data.frame(func_name="H5Ovisit_by_name1", func_mapped="H5Ovisit_by_name", exclude="H5Ovisit_by_name3", stringsAsFactors=FALSE),
    data.frame(func_name="H5Sencode1", func_mapped="H5Sencode", exclude="H5Sencode2", stringsAsFactors=FALSE),
    data.frame(func_name="H5Pencode1", func_mapped="H5Pencode", exclude="H5Pencode2", stringsAsFactors=FALSE)
)


api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, func_mapping_112$exclude, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

# ensure that all functions that are to be mapped exists
func_from_not_found <- setdiff(func_mapping_112$func_name, api_info_all$func_name)
if(length(func_from_not_found) > 0) {
    stop(paste("Some functions for mapping could not be found: ", paste(func_from_not_found, collapse=", ")))
}

# map the function names
api_info_all <- dplyr::left_join(api_info_all, func_mapping_112)
has_map <- !is.na(api_info_all$func_mapped)
api_info_all$func_name[has_map] <- api_info_all$func_mapped[has_map]
api_info_all$func_mapped <- NULL

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.12.0/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}

################################
### Replace H5F_info2_t
################################

H5Fpublic_what <- "typedef struct H5F_info2_t \\{.*\\} H5F_info2_t;"

H5Fpublic_replace <- "typedef struct H5F_info2_t {
    H5F_info2_super_t super;
    H5F_info2_free_t free;
    H5F_info2_sohm_t sohm;
} H5F_info2_t;"

H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)


################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info1_t \\{.*\\} H5F_info1_t;"
H5Fpublic_replace <- "typedef struct H5F_info1_t {
    hsize_t		super_ext_size;	
    H5F_info1_helper_t sohm;
} H5F_info1_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_native_info_what <- "typedef struct H5O_native_info_t \\{.*\\} H5O_native_info_t;"

H5Opublic_native_info_replace  <- "typedef struct H5O_native_info_t {
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_native_info_t;"
fileReplace(H5Opublic_file, H5Opublic_native_info_what, H5Opublic_native_info_replace)


H5Opublic_info1_what <- "typedef struct H5O_info1_t \\{.*\\} H5O_info1_t;"

H5Opublic_info1_replace  <- "typedef struct H5O_info1_t {
    unsigned long       fileno;
    haddr_t             addr;
    H5O_type_t          type;
    unsigned            rc;
    time_t              atime;
    time_t              mtime;
    time_t              ctime;
    time_t              btime;
    hsize_t             num_attrs;
    H5O_hdr_info_t      hdr;
    H5O_info_helper_t meta_size;
} H5O_info1_t;"
fileReplace(H5Opublic_file, H5Opublic_info1_what, H5Opublic_info1_replace)

################################
### Replace H5L_info_t
################################

# note that this is very brittle; 
# we do it in this order as otherwise the regexp is too greedy
# and identifies the start of H5L_info2_t struct with the 
# end of H5L_info1_t struct and deletes too much of the file
H5Lpublic_info2_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_info2_what <- "typedef struct {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    union {
        H5O_token_t     token;          
        size_t          val_size;       
    } u;
} H5L_info2_t;"
H5Lpublic_info2_replace <- "typedef struct H5L_info2_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info2_helper_t u;
} H5L_info2_t;"
fileReplace(H5Lpublic_info2_file, H5Lpublic_info2_what, H5Lpublic_info2_replace, fixed=TRUE)

H5Lpublic_info1_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_info1_what <- "typedef struct {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    union {
        haddr_t         address;        
        size_t          val_size;       
    } u;
} H5L_info1_t;"
H5Lpublic_info1_replace <- "typedef struct H5L_info1_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info1_helper_t u;
} H5L_info1_t;"
fileReplace(H5Lpublic_info1_file, H5Lpublic_info1_what, H5Lpublic_info1_replace, fixed=TRUE)



################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)



################################
### Replace H5Rpublic
################################


H5Rpublic_file <- "src_nocomments/H5Rpublic.h.nocomments"
H5Rpublic_what <- "typedef struct {
    union {
        uint8_t __data[H5R_REF_BUF_SIZE];       
        int64_t align;                          
    } u;
} H5R_ref_t;"
H5Rpublic_replace <- "typedef struct H5R_ref_t {
    H5R_ref_helper_t u;
} H5R_ref_t;"

fileReplace(H5Rpublic_file, H5Rpublic_what, H5Rpublic_replace, fixed=TRUE)



################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.12.0/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.12.0/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "PL", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
## As we don't support MPI here, we also remove H5Pget_mpi_params and H5Pset_mpi_params
## also don't need  H5Pset_map_iterate_hints and H5Pget_map_iterate_hints
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink", "H5Pget_mpi_params",
		      "H5Pset_mpi_params", "H5Pget_map_iterate_hints", "H5Pset_map_iterate_hints") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long", "uint8_t")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop(paste("Don't know a type that is needed here", paste(types_undefined, collapse=", ")))
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.12.0/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.12.0/order_struct_by_dependency.R
---


# we want to order the structs appropriately
order_struct_by_dependency <- function(struct_info) {
    # first we define all vertices
    all_types_used <- sort(c("_root", unique(c(struct_info$type, struct_info$category_name))))
    vertices <- data.frame(name=all_types_used, stringsAsFactors=FALSE)
    # now a data frame with all the edges
    # also note that each node should be connected to the root
    root_edges <- data.frame(from="_root", to=all_types_used, stringsAsFactors=FALSE)
    other_edges <- data.frame(from=struct_info$type, to=struct_info$category_name, stringsAsFactors=FALSE)
    all_edges <- rbind(root_edges, other_edges)

    g <- igraph::graph_from_data_frame(all_edges, directed=TRUE, vertices=vertices)
    # reorder
    g_topo_order <- igraph::topo_sort(g, mode="out")
    priority_df <- data.frame(category_name=names(g_topo_order), stringsAsFactors=FALSE)
    priority_df$priority <- seq_along(priority_df$category_name)
    struct_info <- dplyr::left_join(struct_info, priority_df) 
    struct_info <- dplyr::arrange(struct_info, priority)
    return(struct_info)  
}



---
File: /inst/CWrappers_1.12.0/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/CWrappers_1.8.12/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.8.12/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info_helper_t" | name != "val_size")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))

    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
                          "DT_H5E_error2_t", "DT_H5F_info_helper_t", "DT_H5F_info_t",
                          "DT_H5G_info_t",
                          "DT_H5L_info_helper_t", "DT_H5L_info_t", "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info_t", "DT_H5O_stat_t")
struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.8.12/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, "h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  free(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

excluded_funcs_manual <- NULL



api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, excluded_funcs_manual, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.8.12/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}



################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info_t \\{.*\\} H5F_info_t;"
H5Fpublic_replace <- "typedef struct H5F_info_t {
    hsize_t		super_ext_size;	
    H5F_info_helper_t sohm;
} H5F_info_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_info_what <- "typedef struct H5O_info_t \\{.*\\} H5O_info_t;"

H5Opublic_info_replace  <- "typedef struct H5O_info_t {
    unsigned long 	fileno;		
    haddr_t 		addr;		
    H5O_type_t 		type;		
    unsigned 		rc;		
    time_t		atime;		
    time_t		mtime;		
    time_t		ctime;		
    time_t		btime;		
    hsize_t 		num_attrs;	
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_info_t;"
fileReplace(H5Opublic_file, H5Opublic_info_what, H5Opublic_info_replace)

################################
### Replace H5L_info_t
################################


H5Lpublic_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_what <- "typedef struct \\{.*\\} H5L_info_t;"
H5Lpublic_replace <- "typedef struct H5L_info_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info_helper_t u;
} H5L_info_t;"
fileReplace(H5Lpublic_file, H5Lpublic_what, H5Lpublic_replace)


################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)


################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.8.12/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.8.12/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "PL", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop("Don't know a type that is needed here")
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.8.12/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.8.12/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/CWrappers_1.8.14/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.8.14/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info_helper_t" | name != "val_size")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))

    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
                          "DT_H5E_error2_t", "DT_H5F_info_helper_t", "DT_H5F_info_t",
                          "DT_H5G_info_t",
                          "DT_H5L_info_helper_t", "DT_H5L_info_t", "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info_t", "DT_H5O_stat_t")
struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.8.14/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, "h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  H5free_memory(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

excluded_funcs_manual <- NULL



api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, excluded_funcs_manual, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.8.14/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}



################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info_t \\{.*\\} H5F_info_t;"
H5Fpublic_replace <- "typedef struct H5F_info_t {
    hsize_t		super_ext_size;	
    H5F_info_helper_t sohm;
} H5F_info_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_info_what <- "typedef struct H5O_info_t \\{.*\\} H5O_info_t;"

H5Opublic_info_replace  <- "typedef struct H5O_info_t {
    unsigned long 	fileno;		
    haddr_t 		addr;		
    H5O_type_t 		type;		
    unsigned 		rc;		
    time_t		atime;		
    time_t		mtime;		
    time_t		ctime;		
    time_t		btime;		
    hsize_t 		num_attrs;	
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_info_t;"
fileReplace(H5Opublic_file, H5Opublic_info_what, H5Opublic_info_replace)

################################
### Replace H5L_info_t
################################


H5Lpublic_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_what <- "typedef struct \\{.*\\} H5L_info_t;"
H5Lpublic_replace <- "typedef struct H5L_info_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info_helper_t u;
} H5L_info_t;"
fileReplace(H5Lpublic_file, H5Lpublic_what, H5Lpublic_replace)


################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)


################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.8.14/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.8.14/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))
h_files_to_scan <- h_files_to_scan[!grepl("H5PLextern", h_files_to_scan)]

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop("Don't know a type that is needed here")
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.8.14/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.8.14/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/CWrappers_1.8.16/create_constants_wrapper.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(brew)
dir.create("output", showWarnings=FALSE)
dir.create("output_code", showWarnings=FALSE)
all_const <- read.csv("all_const.csv", stringsAsFactors=FALSE)
all_const$name <- gsub("\\s*", "", all_const$name)
all_const$name_enum <- paste0("CONST_", all_const$name)


code_df_all_const <- function(all_const) {
    code <- "SEXP show_all_const_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(CONST_LAST_ITEM));")
    code <- c(code, "  SEXP R_const = PROTECT(NEW_NUMERIC(CONST_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_const, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_const);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(CONST_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < CONST_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Constant\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_const = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_const))) {
        code <- c(code, "")
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_const$name_enum[i], ", mkChar(\"", all_const$category[i], "\"));"))
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_const$name_enum[i], ", mkChar(\"", all_const$name[i], "\"));"))
        code <- c(code, paste0("  ((long long *) REAL(R_const))[", all_const$name_enum[i], "] = (long long) ", all_const$name[i], ";"))
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}


cat(code_df_all_const(all_const), sep="\n", file=file.path("output", "all_const_df_code.txt"))
cat(all_const$name_enum, sep=",\n", file=file.path("output", "all_const_enum_names.txt"))

const_export_h_env <- new.env()
const_export_h_env$const_names <- paste(paste0("  ", all_const$name_enum), collapse = ",\n")
brew(file="const_export_h.brew", file.path("output_code", "const_export.h"), envir = const_export_h_env)

const_export_c_env <- new.env()
const_export_c_env$all_const_code <- paste(code_df_all_const(all_const), collapse = "\n")
brew(file="const_export_c.brew", file.path("output_code", "const_export.c"), envir = const_export_c_env)




---
File: /inst/CWrappers_1.8.16/create_datatype_wrappers.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)

## code for generating the hdf5 data types for the base types; this is only helper code and needs to be edited
all_types <- readRDS(file=file.path("store", "all_types.rds"))
## only do standard data types; enum and struct will be done later
base_types <- subset(all_types, !category %in% c("enum", "struct", "union"))

base_type_wrapping_func <- function(type_name, i, isEnum) {
    dt_type_name <- paste0("DT_", gsub("\\s+", "_", type_name, perl=TRUE))
    return(paste0("h5_datatype[", dt_type_name, "] = get_h5_equiv(sizeof(", type_name, "), issigned(", type_name, "));"))
}

base_type_enum_names <- paste0("DT_", gsub("\\s+", "_", base_types$category_name, perl=TRUE)) 

base_types$wrapping <- character(nrow(base_types))
for(i in seq_len(nrow(base_types))) {
    base_types$wrapping[i] <- base_type_wrapping_func(base_types$category_name[i], i - 1)
}

## write them out in files
base_types$enum_names <- base_type_enum_names
cat(base_types$enum_names, sep=",\n", file=file.path("output", "DT_enum_base_type.txt"))
cat(base_types$wrapping, sep="\n\t", file=file.path("output", "base_type_assign.txt"))

               


###################################
## create the code for enum datatypes
###################################
enum_info <- readRDS(file=file.path("store", "enum_info.rds"))

code_for_datatype_for_enum_c <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    code <- c("", enum_comment)
    
    enum_name <- unique(enum_info$category_name)

    ## check if it is an unnamed enum
    unnamed <- grepl("^typedef\\s+enum\\s*\\{", unique(enum_info$original), perl = TRUE)
    
    code <- c(code, paste0("hid_t create_DT_", enum_name, "(void) {"))

    if(unnamed) {
        code <- c(code, paste0("  ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(", enum_name, "), issigned(", enum_name, "));"))
    }
    else {
        code <- c(code, paste0("  enum ", enum_name, " myenum;"))
        code <- c(code, paste0("  hid_t base_type = get_h5_equiv(sizeof(enum ", enum_name, "), issigned(enum ", enum_name, "));"))
    }
    code <- c(code, paste0("  hid_t dtype_id = H5Tenum_create(base_type);"))

    for(i in seq_len(nrow(enum_info))) {
        code <- c(code, paste0("  myenum = ", enum_info$name[i], ";"))
        code <- c(code, paste0("  H5Tenum_insert(dtype_id, \"", enum_info$name[i], "\", &myenum);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_enum_h <- function(enum_info) {
    ## check which structs are not compatible
    enum_comment <- paste0("/* ", unique(enum_info$original), " */")
    
    enum_name <- unique(enum_info$category_name)
    return(c("", enum_comment, paste0("hid_t create_DT_", enum_name, "(void);")))
}


enum_create_c <- dlply(enum_info, "category_name", code_for_datatype_for_enum_c)
enum_create_h <- dlply(enum_info, "category_name", code_for_datatype_for_enum_h)

enum_names_for_enum <- paste0("DT_", unique(enum_info$category_name))

datatype_generation_enum <- character(length(enum_names_for_enum))
for(i in seq_len(length(enum_names_for_enum))) {
    datatype_generation_enum[i] <- paste0("h5_datatype[", enum_names_for_enum[i], "] = create_", enum_names_for_enum[i], "();")
}


cat(enum_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_enum.txt")) ## not needed; already created in datatype
cat(datatype_generation_enum, sep="\n", file=file.path("output", "enum_assign.txt"))
cat(unlist(enum_create_c), sep="\n", file=file.path("output", "enum_create_code_c.txt"))
cat(unlist(enum_create_h), sep="\n", file=file.path("output", "enum_create_code_h.txt"))


#####################################
## create the data types for structs
#####################################
struct_info <- readRDS(file=file.path("store", "struct_info.rds"))
# take out the "val_size" in H5L_info_helper_t
struct_info <- subset(struct_info, category_name != "H5L_info_helper_t" | name != "val_size")

code_for_datatype_for_struct_c <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }

    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    code <- c("", struct_comment)
    
    struct_name <- unique(struct_info$category_name)
    code <- c(code, paste0("hid_t create_DT_", struct_name, "(void) {"))

    code <- c(code, paste0("  hid_t dtype_id = H5Tcreate(H5T_COMPOUND, sizeof(", struct_name, "));"))

    for(i in seq_len(nrow(struct_info))) {
        h5_dt_name <- paste0("DT_", gsub("\\s+", "_", struct_info$type_bare[i]))
        code <- c(code, paste0("  H5Tinsert(dtype_id, \"", struct_info$name[i],
                  "\", HOFFSET(", struct_name, ", ", struct_info$name[i], "), h5_datatype[", h5_dt_name, "]);"))
    }

    code <- c(code, "  return(dtype_id);")
    code <- c(code, "}")
    
}

code_for_datatype_for_struct_h <- function(struct_info) {
    ## check which structs are not compatible
    if(any(struct_info$type %in% c("void*"))) {
        return(NULL)
    }
    struct_comment <- paste0("/* ", unique(struct_info$original), " */")
    
    struct_name <- unique(struct_info$category_name)
    return(c("", struct_comment, paste0("hid_t create_DT_", struct_name, "(void);")))
}


struct_create_c <- dlply(struct_info, "category_name", code_for_datatype_for_struct_c)
struct_create_h <- dlply(struct_info, "category_name", code_for_datatype_for_struct_h)


struct_names_for_enum <- paste0("DT_", unique(struct_info$category_name))

struct_names_ordered <- c("DT_H5_ih_info_t", "DT_H5AC_cache_config_t", "DT_H5A_info_t", "DT_H5E_error1_t",
                          "DT_H5E_error2_t", "DT_H5F_info_helper_t", "DT_H5F_info_t",
                          "DT_H5G_info_t",
                          "DT_H5L_info_helper_t", "DT_H5L_info_t", "DT_H5O_hdr_info_helper_msg_t", "DT_H5O_hdr_info_helper_space_t",
                          "DT_H5O_hdr_info_t", "DT_H5O_info_helper_t", "DT_H5O_info_t", "DT_H5O_stat_t")
struct_names_for_enum <- c(struct_names_ordered, setdiff(struct_names_for_enum, struct_names_ordered))
datatype_generation_struct <- character(length(struct_names_for_enum))
for(i in seq_len(length(struct_names_for_enum))) {
    datatype_generation_struct[i] <- paste0("h5_datatype[", struct_names_for_enum[i], "] = create_", struct_names_for_enum[i], "();")
}


cat(struct_names_for_enum, sep=",\n", file=file.path("output", "DT_enum_struct.txt"))
cat(datatype_generation_struct, sep="\n", file=file.path("output", "struct_assign.txt"))
cat(unlist(struct_create_c), sep="\n", file=file.path("output", "struct_create_code_c.txt"))
cat(unlist(struct_create_h), sep="\n", file=file.path("output", "struct_create_code_h.txt"))


##########################################################
## extract the built_in datatypes; they are all defined in H5Tpublic.h
## do this so that we can return a named list of things in R
##########################################################
h5t_public_file <- file.path("headers/H5Tpublic.h")
h5t_public <- readLines(h5t_public_file)
h5t_public <- h5t_public[grepl("#define H5T_", h5t_public, fixed=TRUE)]
h5t_public_types <- gsub("^\\#define\\s+([\\w_]+)\\s+.*$", "\\1", h5t_public, perl=TRUE)
not_types <- c("H5T_NCSET", "H5T_NSTR", "H5T_VARIABLE", "H5T_OPAQUE_TAG_MAX")
add_types <- c("H5T_C_S1", "H5T_FORTRAN_S1")
h5t_public_types <- union(setdiff(h5t_public_types, not_types), add_types)
h5t_public_types <- data.frame(name=h5t_public_types)
h5t_public_types$name_enum <- paste0("DT_", h5t_public_types$name)
h5t_public_types$category_output <- gsub("^H5T_([A-Z]+)_.*$", "\\1", h5t_public_types$name, perl=TRUE)
## need to correct string
h5t_public_types$category_output[h5t_public_types$name %in% c("H5T_C_S1", "H5T_FORTRAN_S1")] <- "STRING"


## create a list of all type names; and a list to which category they belong
all_types$category <- factor(all_types$category, levels=c("integer", "char", "float", "enum", "union", "struct"))
all_types <- all_types[order(all_types$category, all_types$category_name),]
category_mapping <- c(integer="C_API_types", char="C_API_types", float="C_API_types", enum="enum", union="struct", struct="struct")
all_types$category_output <- category_mapping[as.character(all_types$category)]
all_types <- all_types[, c("category_name", "category_output")]
colnames(all_types) <- c("name", "category_output")
all_types$name_enum <- paste0("DT_", gsub("\\s+", "_", all_types$name, perl=TRUE))
library(plyr)
all_types <- rbind.fill(h5t_public_types, all_types)

## write out a file with all DT_ names
cat(all_types$name_enum, sep=",\n", file=file.path("output", "DT_enum_all_types.txt"))

## for the h5t_public_types, create code that sets them
h5t_public_types$set_c <- paste0("h5_datatype[", h5t_public_types$name_enum, "] = ", h5t_public_types$name, ";")
cat(h5t_public_types$set_c, sep="\n", file=file.path("output", "h5t_public_types_assign.txt"))

## create C-code that creates a data frame in R that contains the name, the number, the category and the datatype_id
code_df_all_types <- function(all_types) {
    code <- "SEXP show_all_types_data_frame(void) {"
    ## create the basis of the data frame
    code <- c(code, "  SEXP df = PROTECT(allocVector(VECSXP, 3));")
    code <- c(code, "  SET_VECTOR_ELT(df, 0, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SET_VECTOR_ELT(df, 1, NEW_CHARACTER(DT_LAST_ITEM));")
    code <- c(code, "  SEXP R_type = PROTECT(NEW_NUMERIC(DT_LAST_ITEM));")
    code <- c(code, "  SET_CLASS(R_type, ScalarString(mkChar(\"integer64\")));")
    code <- c(code, "  SET_VECTOR_ELT(df, 2, R_type);")
    code <- c(code, "  SEXP df_rownames = PROTECT(NEW_INTEGER(DT_LAST_ITEM));")
    code <- c(code, "  for(R_xlen_t i = 0; i < DT_LAST_ITEM; ++i) {")
    code <- c(code, "    INTEGER(df_rownames)[i] = i + 1;")
    code <- c(code, "  }")
    code <- c(code, "  SET_CLASS(df, mkString(\"data.frame\"));")
    code <- c(code, "  SET_ATTR(df, install(\"row.names\"), df_rownames);")
    code <- c(code, "  SEXP df_names = PROTECT(NEW_CHARACTER(3));")
    code <- c(code, "  SET_STRING_ELT(df_names, 0, mkChar(\"Category\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 1, mkChar(\"Name\"));")
    code <- c(code, "  SET_STRING_ELT(df_names, 2, mkChar(\"Type_id\"));")
    code <- c(code, "  SET_NAMES(df, df_names);")
    ## get pointers to the 4 items for easier use
    code <- c(code, "  SEXP R_categ = VECTOR_ELT(df, 0);")
    code <- c(code, "  SEXP R_name = VECTOR_ELT(df, 1);")
    code <- c(code, "  R_type = VECTOR_ELT(df, 2);")
    ## and now set the actual ids
    for(i in seq_len(nrow(all_types))) {
        code <- c(code, "")
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#if H5_SIZEOF_LONG_DOUBLE !=0")
        }
        code <- c(code, paste0("  SET_STRING_ELT(R_categ, ", all_types$name_enum[i], ", mkChar(\"", all_types$category_output[i], "\"));"))
        ## needed to remove the DT_ in front, but keep the _ in between words for the name in the string
        code <- c(code, paste0("  SET_STRING_ELT(R_name, ", all_types$name_enum[i], ", mkChar(\"",
                               gsub("^DT_", "", all_types$name_enum[i], perl=TRUE), "\"));")) 
        code <- c(code, paste0("  ((long long *) REAL(R_type))[", all_types$name_enum[i], "] = h5_datatype[", all_types$name_enum[i], "];"))
        if(all_types$name_enum[i]=="DT_H5T_NATIVE_LDOUBLE") {
            code <- c(code, "#endif")
        }
    }

    code <- c(code, "  UNPROTECT(4);")
    code <- c(code, "  return(df);")
    code <- c(code, "}")
}

cat(code_df_all_types(all_types), sep="\n", file=file.path("output", "all_types_dt_return_df.txt"))





## and now create datatype_export.h
## as well as datatype_export.c
library(brew)
datatype_export_h_env <- new.env()
datatype_export_h_env$dt_all_names_no_LDOUBLE <- paste(paste0("  ", subset(all_types, name!="H5T_NATIVE_LDOUBLE")$name_enum), collapse=",\n")
datatype_export_h_env$enum_create_func_def <- paste(unlist(enum_create_h), collapse="\n")
datatype_export_h_env$struct_create_func_def <- paste(unlist(struct_create_h), collapse="\n")
brew(file="datatype_export_h.brew", output=file.path("output_code", "datatype_export.h"), envir=datatype_export_h_env)

datatype_export_c_env <- new.env()
datatype_export_c_env$builtin_types_init_no_LDOUBLE <- paste(paste0("  ", subset(h5t_public_types, name!="H5T_NATIVE_LDOUBLE")$set_c), collapse="\n")
datatype_export_c_env$c_api_types_init_no_char_float <- paste(paste0("  ", subset(base_types, category=="integer")$wrapping), collapse = "\n")
datatype_export_c_env$enum_init <- paste(paste0("  ", datatype_generation_enum), collapse = "\n")
datatype_export_c_env$struct_init <- paste(paste0("  ", datatype_generation_struct), collapse = "\n")
datatype_export_c_env$show_all_types_code <- paste(code_df_all_types(all_types), collapse="\n")
datatype_export_c_env$create_enum_types_code <- paste(unlist(enum_create_c), collapse="\n")
datatype_export_c_env$create_struct_types_code <- paste(unlist(struct_create_c), collapse="\n")
brew(file="datatype_export_c.brew", output=file.path("output_code", "datatype_export.c"), envir=datatype_export_c_env)
file.copy("HelperStructs.h", "output_code/HelperStructs.h")



---
File: /inst/CWrappers_1.8.16/createCWrappers.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





library(plyr)
source("helperFunctions.R")
dir.create("output_code", showWarnings=FALSE)

copyright_notice <- readLines("Apache_Copyright_Notice.txt")


## function that copies the robjects as needed
duplicate_object <- function(text, cname, ask=FALSE) {
    rname <- r_name(cname)
    if(ask) {
        boolname <- bool_dupl_name(cname)
        text <- c(text, paste0("  ", "if(SEXP_to_logical(", boolname, ")) {"))
        text <- c(text, paste0("    ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("    vars_protected++;"))
        text <- c(text, "  }")
    }
    else {
        text <- c(text, paste0("  ", rname, " = PROTECT(duplicate(", rname, "));"))
        text <- c(text, paste0("  vars_protected++;"))
    }
    return(text)
}

## function that generates code for unwrapping a variable
unwrap_variable <- function(text, cname, ctype, category, rname=r_name(cname)) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))

    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_longlong(", rname, ", 0);"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", ctype, " ", cname, " = SEXP_to_double(", rname, ");"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, "h5_datatype[", ctype_DT, "], 1));"))
            text <- c(text, paste0("  ", ctype, " ", cname, " = * ((", ctype, "*) VOIDPTR(R_helper));"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype=="const char*") {
            text <- c(text, paste0("  ", ctype, " ", cname, " = CHAR(STRING_ELT(", rname, ", 0));"))
        }
        else if(ctype=="char*") {
            ## need to copy the string
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = R_alloc(strlen(CHAR(STRING_ELT(", rname, ", 0))) + 1, 1);"))
            text <- c(text, paste0("    ", "strcpy(", cname, ", CHAR(STRING_ELT(", rname, ", 0)));"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype_bare=="void") {
            ## simply pass the object
            ## check if the object has size > 0, otherwise set NULL
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", cname, " = (void *) VOIDPTR(", rname, ");"))
            text <- c(text, paste0("  }"))
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT,
                                   "], guess_nelem(", rname, ", h5_datatype[", ctype_DT, "])));"))
            text <- c(text, paste0("  ", ctype, " ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("  vars_protected++;"))

        }
        else if(category %in% c("integer", "float", "enum")) {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Unknown type")
        }
    }
    else if(ctype_ref_depth == 2) {
        ## we only do this for const character vectors
        if(ctype=="const char**") {
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="char**") { ## we copy everything into R_alloced places
            text <- c(text, paste0("  ", ctype, " ", cname, ";"))
            text <- c(text, paste0("  if(XLENGTH(", rname, ") == 0) {"))
            text <- c(text, paste0("    ", cname, " = NULL;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", "R_helper = PROTECT(RToH5(", rname, ", h5_datatype[", ctype_DT, "], XLENGTH(", rname, ")));"))
            text <- c(text, paste0("    ", cname, "= (", ctype, ") VOIDPTR(R_helper);"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("    if(!inherits(", rname, ", \"_RToH5_empty\")) {"))
            text <- c(text, paste0("      for(int i = 0; i < XLENGTH(", rname, "); ++i) {"))
            text <- c(text, paste0("        if(XLENGTH(STRING_ELT(", rname, ", i)) == 0) {"))
            text <- c(text, paste0("          ", cname, "[i] = NULL;"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("        else {"))
            text <- c(text, paste0("          ", cname, "[i] = (char*) R_alloc(XLENGTH(STRING_ELT(", rname, ", i)), 1);"))
            text <- c(text, paste0("          strcpy(", cname, "[i], CHAR(STRING_ELT(", rname, ", i)));"))
            text <- c(text, paste0("        }"))
            text <- c(text, paste0("      }"))
            text <- c(text, paste0("    }"))
            text <- c(text, paste0("  }"))
        }
        else {
            stop("Not supported type for double reference")
        }
    }
    
    return(text)
}    


## function for calling the hdf5 API function
create_API_call <- function(text, func_name, return_type, return_name, cnames) {
    ## now do the API call
    if(return_type != "void") {
        text <- c(text, paste0("  ", return_type, " ", return_name, " = ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    else {
        text <- c(text, paste0("  ", func_name, "(", paste(cnames, collapse=", "), ");"))
    }
    return(text)
}    
    
## function for wrapping the c objects back into R
## function that generates code for unwrapping a variable
wrap_variable <- function(text, cname, ctype, category, rname=r_name(cname), define_r_var=FALSE) {
    ctype_const <- is_const(ctype)
    ctype_ref_depth <- get_ref_depth(ctype)
    ctype_bare <- make_bare(ctype)
    ctype_DT <- paste0("DT_", gsub("\\s+", "_", ctype_bare))
    
    if(define_r_var) { 
        text <- c(text, paste0("  ", "SEXP ", rname, "= R_NilValue;"))
    }
    
    if(ctype_ref_depth==0) {
        ## could be integer, double, enum (same as integer) or struct
        ## for integer, double or enum, we have a specialized function for the conversion
        if(category %in% c("integer")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarInteger64_or_int(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% "enum") {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarFactor(", cname, ", h5_datatype[", ctype_DT, "]));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("float")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(ScalarReal(", cname, "));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("struct", "union")) {
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], 1, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category == "void") {
            ## nothing to do; already set to R_NilValue
        }
        else {
            stop("Unknown category")
        }        
    }
    else if(ctype_ref_depth == 1) {
        ## potentially need to convert an input variable (but preferred not)
        if(ctype_bare=="char") {
            ## need to copy the string
            text <- c(text, paste0("  if(", cname, "==NULL) {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(NEW_CHARACTER(0));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
            text <- c(text, paste0("  else {"))
            text <- c(text, paste0("    ", rname, " = PROTECT(mkString(", cname,"));"))
            text <- c(text, paste0("    vars_protected++;"))
            text <- c(text, paste0("  }"))
        }
        else if(ctype=="void*") {
            ## simply pass the object
            ## do nothing; already worked on the R object itself
        }
        else if(category=="struct") {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
        else if(category %in% c("integer", "float", "enum")) {
            ## treat it like the fixed case; translate from R to h5, then give the pointer instead of the address
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
        }
    }
    else if(ctype_ref_depth == 2 && ctype_bare=="char") {
        ## this is returned and as it is a double redirect, it can be used as output
            text <- c(text, paste0("  ", "size_helper = guess_nelem(", rname, ", h5_datatype[", ctype_DT, "]);"))
            text <- c(text, paste0("  ", rname, " = PROTECT(H5ToR_single_step(", cname, ", h5_datatype[", ctype_DT, "], size_helper, H5TOR_CONV_INT64_NOLOSS));"))
            text <- c(text, paste0("  vars_protected++;"))
    }
    else {
        stop("This case should not have happened")
    }
    
    return(text)
}
    

## function for generating the return list
create_return_list <- function(text, cnames) {
    rnames <- r_name(cnames)
    ## create the list
    text <- c(text, paste0("  ", "SEXP __ret_list;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list = allocVector(VECSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_VECTOR_ELT(__ret_list, ", i - 1, ", ", rnames[i], ");"))
    }
    ## create the names for the list and 
    text <- c(text, paste0("  ", "SEXP __ret_list_names;"))
    text <- c(text, paste0("  ", "PROTECT(__ret_list_names = allocVector(STRSXP, ", length(rnames), "));"))
    ## now set each of the vector elements, by name
    for(i in seq_along(rnames)) {
        text <- c(text, paste0("  ", "SET_STRING_ELT(__ret_list_names, ", i - 1, ", mkChar(\"", cnames[i], "\"));"))
    }
    text <- c(text, paste0("  ", "SET_NAMES(__ret_list, __ret_list_names);"))
    text <- c(text, paste0("  vars_protected += 2;"))
    return(text)
}




    
## wrapping all the above together for creating the function call for the API
## additional injection is a list with 4 components
## start, pre_call, post_call, pre_list, end
## each of these is a named list with funciton names;
## create_wrapper_API searches in there for pieces of code to inject
## at the appropriate places
create_wrapper_API <- function(api_info, add_injection) {
    ## order the input by position
    api_info <- api_info[order(api_info$position, decreasing=FALSE),]
    
    api_info_input <- subset(api_info, io=="input")
    api_info_output <- subset(api_info, io=="output")

    ## all input names that refer to non-const references and add a duplication switch
    api_info_ref_out <- subset(api_info_input, (!is_const(type) & get_ref_depth(type) > 0) | (type_bare=="char" & get_ref_depth(type)==2))
    api_info_ref_out$ask_dupl <- api_info_ref_out$type=="void*"
    all_input_names <- c(r_name(api_info_input$name), bool_dupl_name(with(api_info_ref_out, name[ask_dupl])))

    text_c <- character(0)
    ## comment at the beginning of the function giving the original api
    text_c <- c(text_c, paste0("/* ", unique(api_info$original), " */"))

    ## function definition, both for .h and .c file
    if(length(all_input_names) > 0) {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(", paste("SEXP", all_input_names, collapse=", "), ")")
    }
    else {
        func_def <- paste0("SEXP ", r_name(unique(api_info$func_name)), "(void)")
    }

    func_name <- unique(api_info$func_name)
    text_h <- c(text_c, paste0(func_def, ";", ""))
    text_c <- c(text_c, paste0(func_def, "{"))
    text_exp <- paste0("{\"", r_name(func_name), "\", (DL_FUNC) &", r_name(func_name), ", ", length(all_input_names), "},")


    ## insert counter for number of protected vars
    text_c <- c(text_c, "  int vars_protected=0;")
    
    ## insert start code if it exists
    text_c <- c(text_c, add_injection$start[[func_name]])
    
    ## create the body of the functions
    ## create the necessary function duplication
    for(i in seq_len(nrow(api_info_ref_out))) {
        text_c <- duplicate_object(text_c, cname=api_info_ref_out$name[i], ask=api_info_ref_out$ask_dupl[i])
    }

    ## add the code for unwrapping the input variables
    for(i in seq_len(nrow(api_info_input))) {
        text_c <- unwrap_variable(text_c, cname=api_info_input$name[i], ctype=api_info_input$type[i], category=api_info_input$category[i])
    }


    ## add pre_api call code
    text_c <- c(text_c, add_injection$pre_call[[func_name]])

    ## add code for calling the api
    text_c <- create_API_call(text_c, func_name=unique(api_info$func_name), return_type=api_info_output$type,
                              return_name="return_val", cnames=api_info_input$name)

    text_c <- c(text_c, add_injection$post_call[[func_name]])

    ## create the info for the output
    api_info_output$name <- "return_val"
    api_info_output$define_r_var <- TRUE
    if(nrow(api_info_ref_out) > 0) {
        api_info_ref_out$define_r_var <- FALSE
    }
    api_info_return <- rbind.fill(api_info_output, api_info_ref_out)
    
    ## create the wrapping for the return variables
    for(i in seq_len(nrow(api_info_return))) {
        text_c <- wrap_variable(text_c, cname=api_info_return$name[i], ctype=api_info_return$type[i], category=api_info_return$category[i],
                                define_r_var=api_info_return$define_r_var[i])
    }

    text_c <- c(text_c, add_injection$pre_list[[func_name]])
    
    ## create the return list
    text_c <- create_return_list(text_c, api_info_return$name)

    ## need to free return character string
    if(api_info_output$type=="char*") {
        text_c <- c(text_c, "  H5free_memory(return_val);")
    }
    

    ## define the helper variables and add the beginning, if they are needed
    if(any(grepl("R_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  SEXP R_helper = R_NilValue;", text_c[-(1:2)])
    }
    if(any(grepl("size_helper", text_c, fixed=TRUE))) {
        text_c <- c(text_c[1:2], "  hsize_t size_helper;", text_c[-(1:2)])
    }

    ## code injection before end of function
    text_c <- c(text_c, add_injection$end[[func_name]])

    ## unprotect as needed
    text_c <- c(text_c, "  UNPROTECT(vars_protected);")
    
    ## return and end
    text_c <- c(text_c, "  return(__ret_list);")
    text_c <- c(text_c, "}", "")
    return(list(text_c=text_c, text_h=text_h, text_exp=text_exp))
}





## a function that creates the minimal .h file needed for automatic wrapper functions
minimal_h_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice
    
    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    text <- c(text, "#include \"global.h\"")
}

minimal_c_file <- function(filename, copyright_notice) {
    filename <- gsub(".c", ".h", filename, fixed=TRUE)

    ## put the copyright notice at the top
    text <- copyright_notice

    text <- c(text, paste0("#include \"", filename, "\""))
    return(text)
}


minimal_export_file <- function(filename, copyright_notice) {
    file_variable <- gsub(".", "_", toupper(filename), fixed=TRUE)

    text <- copyright_notice

    text <- paste0("#ifndef _", file_variable, "_")
    text <- c(text, paste0("#define _", file_variable, "_"))
    return(text)
}


write_file <- function(api_info_file, exprt_file, outpath, add_injection, copyright_notice) {
    ## create rudimentary .h and .c files
    text_c <- minimal_c_file(unique(api_info_file$filename_c), copyright_notice)
    text_h <- minimal_h_file(unique(api_info_file$filename_h), copyright_notice)

    libname <- gsub(".H$", "", toupper(unique(api_info_file$filename_h)), perl=TRUE)
    
    func_output <- dlply(api_info_file, c("filename_c", "filename_h", "func_name"), create_wrapper_API, add_injection=add_injection)

    ## get the export file output
    export_content_h <- unlist(llply(func_output, function(x) {return(x$text_exp)}))
    func_c <- unlist(llply(func_output, function(x) {return(x$text_c)}))
    func_h <- unlist(llply(func_output, function(x) {return(x$text_h)}))

    text_c <- c(text_c, func_c)
    text_h <- c(text_h, func_h)
    text_h <- c(text_h, "#endif")

    export_content_h <- c(paste0("R_CallMethodDef library_", libname, "[] = {"), export_content_h)
    export_content_h <- c(export_content_h,  "{NULL, NULL, 0}\n};\n")
    
    ## write it out into the appropriate files
    cat(text_c, file=file.path(outpath, unique(api_info_file$filename_c)), append=FALSE, sep="\n")
    cat(text_h, file=file.path(outpath, unique(api_info_file$filename_h)), append=FALSE, sep="\n")
    cat(export_content_h, file=file.path(outpath, exprt_file), append=TRUE, sep="\n")

    
}

## read in the function definitions
api_info_all <- readRDS( file=file.path("store", "functions_for_wrappping.rds"))

excluded_funcs_obsolete <- c("H5Acreate1", "H5Dcreate1", "H5Dopen1",
                             "H5Eclear1", "H5Epush1", "H5Pget_filter1",
                             "H5Pget_filter_by_id1", "H5Rget_obj_type1", "H5Tcommit1",
                             "H5Tarray_create1", "H5Topen1", "H5Tget_array_dims1", "H5Dextend")
excluded_funcs_not_used <- c("H5Lregister", "H5Sselect_select", "H5Scombine_select", "H5Oget_num_attrs", "H5Scombine_hyperslab", "H5Iobject_verify",
                             "H5Iremove_verify", "H5Pget_driver_info", "H5allocate_memory", "H5resize_memory")

excluded_funcs_needs_parallel <- c("H5Fget_mpi_atomicity", "H5Fset_mpi_atomicity", "H5Pget_all_coll_metadata_ops",
                                   "H5Pget_coll_metadata_write", "H5Pget_mpio_actual_chunk_opt_mode", "H5Pget_mpio_actual_io_mode",
                                   "H5Pget_mpio_no_collective_cause", "H5Pset_all_coll_metadata_ops", "H5Pset_coll_metadata_write")

excluded_funcs_manual <- NULL



api_info_all <- subset(api_info_all, !(func_name %in% c(excluded_funcs_obsolete, excluded_funcs_manual, excluded_funcs_not_used, excluded_funcs_needs_parallel)))

h5_file_start <- function(filename) {
    filename <- gsub("public", "", filename)
    filename <- gsub("\\..*", "", filename)
    return(filename)
}

## define the names for the output_h and output_c files
api_info_all <- within(api_info_all, {
    filename_c <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".c")
    filename_h <- paste0("Wrapper_auto_", h5_file_start(basename(filename)), ".h")
})



files_to_do <- c("Wrapper_auto_H5A.c", "Wrapper_auto_H5D.c", "Wrapper_auto_H5E.c",
                 "Wrapper_auto_H5F.c", "Wrapper_auto_H5G.c", "Wrapper_auto_H5I.c",
                 "Wrapper_auto_H5L.c", "Wrapper_auto_H5O.c", "Wrapper_auto_H5P.c",
                 "Wrapper_auto_H5.c",  "Wrapper_auto_H5R.c", "Wrapper_auto_H5S.c",
                 "Wrapper_auto_H5T.c", "Wrapper_auto_H5Z.c",
                 "Wrapper_auto_H5DS.c", "Wrapper_auto_H5IM.c", "Wrapper_auto_H5LT.c",
                 "Wrapper_auto_H5TB.c",
                 "Wrapper_auto_H5FDcore.c", "Wrapper_auto_H5FDfamily.c",
                 "Wrapper_auto_H5FDlog.c", "Wrapper_auto_H5FDsec2.c", "Wrapper_auto_H5FDstdio.c") 

## exclude "Wrapper_auto_H5FDdirect.c" as it is not necessarily supported and not clear why it would be used ast this point
## get the code for the injection
source("injectionCode.R")



cat(minimal_export_file("export_auto.h", copyright_notice), file=file.path("output_code", "export_auto.h"), sep="\n", append=FALSE)
# write_file(h5t_api, exprt_file = "export.h", outpath="Testing")
d_ply(subset(api_info_all, filename_c %in% files_to_do), c("filename_c", "filename_h"), write_file, exprt_file="export_auto.h", outpath="output_code",
      add_injection=add_injection, copyright_notice=copyright_notice)
cat("#endif", file=file.path("output_code", "export_auto.h"), append=TRUE)

## write out a file with the library names
cat(paste0("library_", toupper(gsub(".c", "", files_to_do, fixed=TRUE))), sep=",\n", file=file.path("output", "library_names.txt"))

## write out list of .h names
cat(paste0("#include \"", gsub(".c", ".h", files_to_do, fixed=TRUE), "\""), sep="\n", file=file.path("output", "include_file_names.txt"))




---
File: /inst/CWrappers_1.8.16/FindAndReplace.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




## we replace nested struct definition by unnested ones
## the nested definitions are written into HelperStructs.h


fileReplace <- function(filename, what, replace, fixed=FALSE) {
    if(!file.exists(filename)) {
        stop(paste("File", filename, "does not exist"))
    }
    L <- readLines(filename)
    L <- paste(L, collapse="\n")

    ## collapse multiple spaces to single space
    replace <- paste(replace, collapse="\n")

    ## check if it can be found
    if(!grepl(what, L, fixed=fixed)) {
        stop(paste("In File:", filename, "\nCould not find:\n", what, "\n\nTo be replaced with:\n", replace))
    }

    L <- gsub(what, replace, L, fixed=fixed)
    cat(c(L, ""), file=filename, collapse="\n")
}



################################
### Replace H5F_info1_t
################################


H5Fpublic_what <- "typedef struct H5F_info_t \\{.*\\} H5F_info_t;"
H5Fpublic_replace <- "typedef struct H5F_info_t {
    hsize_t		super_ext_size;	
    H5F_info_helper_t sohm;
} H5F_info_t;"
H5Fpublic_file <- "src_nocomments/H5Fpublic.h.nocomments"
fileReplace(H5Fpublic_file, H5Fpublic_what, H5Fpublic_replace)




################################
### Replace H5O_hdfr_info_t
################################


## do the same for the other 2 structs in H5Opublic.h.nocomments
H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_hdr_info_what <- "typedef struct H5O_hdr_info_t \\{.*\\} H5O_hdr_info_t;"

H5Opublic_hdr_info_replace <- "typedef struct H5O_hdr_info_t {
    unsigned version;		
    unsigned nmesgs;		
    unsigned nchunks;		
    unsigned flags;             
    H5O_hdr_info_helper_space_t space;
    H5O_hdr_info_helper_msg_t  mesg;
} H5O_hdr_info_t;"
fileReplace(H5Opublic_file, H5Opublic_hdr_info_what, H5Opublic_hdr_info_replace)


################################
### Replace H5O_info_t
################################

H5Opublic_file <- "src_nocomments/H5Opublic.h.nocomments"
H5Opublic_info_what <- "typedef struct H5O_info_t \\{.*\\} H5O_info_t;"

H5Opublic_info_replace  <- "typedef struct H5O_info_t {
    unsigned long 	fileno;		
    haddr_t 		addr;		
    H5O_type_t 		type;		
    unsigned 		rc;		
    time_t		atime;		
    time_t		mtime;		
    time_t		ctime;		
    time_t		btime;		
    hsize_t 		num_attrs;	
    H5O_hdr_info_t      hdr;            
    H5O_info_helper_t meta_size;
} H5O_info_t;"
fileReplace(H5Opublic_file, H5Opublic_info_what, H5Opublic_info_replace)

################################
### Replace H5L_info_t
################################


H5Lpublic_file <- "src_nocomments/H5Lpublic.h.nocomments"
H5Lpublic_what <- "typedef struct \\{.*\\} H5L_info_t;"
H5Lpublic_replace <- "typedef struct H5L_info_t {
    H5L_type_t          type;           
    hbool_t             corder_valid;   
    int64_t             corder;         
    H5T_cset_t          cset;           
    H5L_info_helper_t u;
} H5L_info_t;"
fileReplace(H5Lpublic_file, H5Lpublic_what, H5Lpublic_replace)


################################
### Replace H5C_cache_incr_mode
################################


H5Cpublic_file <- "src_nocomments/H5Cpublic.h.nocomments"
H5Cpublic_what <- "enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
};

enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
};

enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
};"
H5Cpublic_replace <- "typedef enum H5C_cache_incr_mode
{
    H5C_incr__off,
    H5C_incr__threshold
} H5C_cache_incr_mode;

typedef enum H5C_cache_flash_incr_mode
{
     H5C_flash_incr__off,
     H5C_flash_incr__add_space
} H5C_cache_flash_incr_mode;

typedef enum H5C_cache_decr_mode
{
    H5C_decr__off,
    H5C_decr__threshold,
    H5C_decr__age_out,
    H5C_decr__age_out_with_threshold
} H5C_cache_decr_mode;"
fileReplace(H5Cpublic_file, H5Cpublic_what, H5Cpublic_replace, fixed=TRUE)


################################
### Replace H5FD_free_t
################################

## delete something in H5FD
H5FDpublic_file <- "src_nocomments/H5FDpublic.h.nocomments"
H5FDpublic_what <- "typedef struct H5FD_free_t \\{.*\\} H5FD_free_t;"
H5FDpublic_replace <- ""
fileReplace(H5FDpublic_file, H5FDpublic_what, H5FDpublic_replace)

################################
### Replace H5FD_file_image_callbacks_t
################################
H5FDpublic_what <- "typedef struct \\{.*\\} H5FD_file_image_callbacks_t;"
fileReplace(H5FDpublic_file, H5FDpublic_what, "")






---
File: /inst/CWrappers_1.8.16/helperFunctions.R
---

## function to create the names of objects
r_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    ## check if the name already starts with an underscore
    ## we can't do double underscore as some of those variable names are reserved
    prepend <- rep("R_", length(cname))
    return(paste0(prepend, cname))
}

bool_dupl_name <- function(cname) {
    if(length(cname)==0) {
        return(character(0))
    }
    return(paste0("_dupl_", cname))
}


is_const <- function(type) {
    return(grepl("^const", type, perl=TRUE))
}

make_bare <- function(type) {
    return(gsub("(const\\s+|\\**)", "", type, perl=TRUE))
}

get_ref_depth <- function(type) {
    sapply(regmatches(type, gregexpr("*", type, fixed=TRUE)), length)
}

## names for wrapping and unwrapping structs; will also be used for the union (corner case)
unwrap_struct_func_name <- function(struct_name) {
    return(paste0("SEXP_to_", struct_name))
}

wrap_struct_func_name <- function(struct_name) {
    return(paste0(struct_name, "_to_SEXP"))
}

reset_alt_struct_func_name <- function(struct_name) {
    return(paste0("reset_alt_", struct_name))
}



---
File: /inst/CWrappers_1.8.16/identify_prototypes.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



rm(list=ls())
library(plyr)
source("helperFunctions.R")
source("remove_c_comments.R")

hdf5.headers <- c("headers")

dir.create("output", showWarnings=FALSE)
dir.create("store", showWarnings=FALSE)


## This file should be run from the inst/CWrappers directory (that exists after the unpacking on linux)
h_files_to_scan <- list.files(hdf5.headers, pattern=glob2rx("*public.h"), full.names = TRUE)
fd_file_list <- c("H5FDcore.h", "H5FDfamily.h", "H5FDlog.h", "H5FDsec2.h", "H5FDstdio.h")
h_files_to_scan <- c(h_files_to_scan, file.path(hdf5.headers, fd_file_list))

## we also include our HelperStructs.h file
h_files_to_scan <- c(h_files_to_scan, "HelperStructs.h")

## create the command line calls to remove the comments
dir.create("src_nocomments", recursive = TRUE, showWarnings = FALSE)
h_files_output <- file.path("src_nocomments", paste0(basename(h_files_to_scan), ".nocomments"))

for(i in seq_along(h_files_to_scan)) {
    remove_c_comments_from_file(infile=h_files_to_scan[i], outfile=h_files_output[i])
}

## We don't want to scan all of them, only the public ones
h_files_basenames <- paste0("H5", c("DS", "IM", "LT", "PT", "TB" ,"", "A", "D", "E", "F", "G", "I", "L", "O", "P", "PL", "R", "S", "T", "Z"),
                           "public.h.nocomments")
h_files_basenames <- c(h_files_basenames, paste0(fd_file_list, ".nocomments"))
h_files_basenames <- c(h_files_basenames, "HelperStructs.h.nocomments")
h_files_for_proto <- file.path("src_nocomments", h_files_basenames)
h_files_for_proto  <- h_files_for_proto[file.exists(h_files_for_proto)]


## there are some nested struct definitions; these are only few, so we change them 'by hand'
## so that automatic processing works
source("FindAndReplace.R")

## describe various pattern pieces
pattern_var_type <- "((const\\s+)?(signed\\s+|unsigned\\s+|enum\\s+|struct\\s+)?(long\\s+)*[\\w_]*(\\s*\\*+\\s*|\\s+)(const\\s+\\*)?)"
pattern_name <- "([\\w_]+)"
pattern_const_with_numbers <- "([\\w_\\[\\]\\(\\)+\\s-]*)"
pattern_square_brackets <- "(\\[[\\w_+\\s-]*\\])"
pattern_typedef_se <- "typedef\\s+(struct|enum|union)"
pattern_prototype <- "^H5_H?L?DLL\\s*(unsigned|signed)?\\s+(\\w+)(\\s*\\*+\\s*|\\s+)(\\w+)\\s*\\(([^)]*)\\)\\s*;"
pattern_anything_in_curly <- "\\{([^\\}]*)\\}"


post_process_type <- function(type) {
    ## post-process the type information a little
    ## strip the space around the * and at the end
    type <- gsub(pattern_square_brackets, "*", type, perl=TRUE)
    type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", type, perl=TRUE)
    return(type)
}
## function that splits the arguments of a list into a vector (names are the names of the argument;
## content is the type of the variable
split_args <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("^\\s*void\\s*$", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    ## throw away the ...
    args_split <- args_split[!grepl("^\\s*\\.\\.\\.\\s*$", args_split)]
    ## recognize an argument pattern
    pattern <- paste0("^\\s*", pattern_var_type, pattern_name, pattern_square_brackets, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the argument pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_type <- gsub(pattern, "\\1\\8", args_split, perl=TRUE)
    ## remove the words struct or type from the type; we don't want those
    args_type <- gsub("struct\\s*|enum\\s*|union\\s*", "", args_type, perl=TRUE)

    
    args_names <- gsub(pattern, "\\7", args_split, perl=TRUE)
    return(data.frame(type=args_type, name=args_names, position=seq_along(args_type), stringsAsFactors = FALSE))
}


split_enum <- function(dF, split_char=",") {
    args <- dF$arguments
    ## capture the case where the argument is just void
    if(grepl("\\s*void\\s*", args)) {
        return(NULL)
    }
    
    args_split <- strsplit(args, split=split_char)[[1]]
    pattern <- paste0("^\\s*", pattern_name, "\\s*=?\\s*", pattern_const_with_numbers, "?\\s*[|&]?\\s*", pattern_const_with_numbers, "?\\s*$")
    ## check that we don't have an argument that does not fit the pattern
    if(any(!grepl(pattern, args_split, perl=TRUE))) {
        offending_lines <- args_split[!grepl(pattern, args_split, perl=TRUE)]
        stop(paste("Arguments do not fit the enum pattern:", paste(offending_lines, collapse=split_char)))
    }
    args_name <- gsub(pattern, "\\1", args_split, perl=TRUE)
    
    args_value <- gsub(pattern, "\\2", args_split, perl=TRUE)
   
    return(data.frame(name=args_name, value=args_value, stringsAsFactors = FALSE))
}


type_properties <- function(dF) {
    dF$type_bare <- make_bare(dF$type)
    dF$const <- is_const(dF$type)
    dF$ref_depth <- get_ref_depth(dF$type)
    return(dF)    
}

#############################################################################
## Get the prototype definitions
#############################################################################


## simple function that intends to decompose (most) prototype definitions
find_prototypes_in_files <- function(filename) {
    pattern <- pattern_prototype
    ## simple rule; if a line doesn't have a semi-colon, merge with next line, unless next line is empty
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    ## need to remove lines that are only for the preprocessor, i.e. start with a #
    lines <- lines[!grepl("^#", lines, perl=TRUE)]
    
    cur_line_out <- 1
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(";", x=lines[i], fixed=TRUE) || lines[i]=="") {
            cur_line_out <- cur_line_out + 1
        }
    }

    cat(lines_out, file=paste0(filename, ".combined"), sep="\n")
    lines_prototype <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    ## throw away multiple spaces
    lines_prototype <- gsub("\\s+", " ", lines_prototype, perl=TRUE)
    cat(lines_prototype, file=paste0(filename, ".proto"), sep="\n")

    if(length(lines_prototype) > 0) {
        ## and now for every prototype, extract the name, return type and argument list
        info_df <- data.frame(filename=filename,
                              original=lines_prototype, 
                              func_name=gsub(pattern, "\\4", lines_prototype, perl=TRUE),
                              io="output",
                              type=gsub(pattern, "\\1 \\2 \\3", lines_prototype, perl=TRUE),
                              name=NA, position=-1,
                              arguments=gsub(pattern, "\\5", lines_prototype, perl=TRUE),
                              stringsAsFactors = FALSE)
        ## remove leading 0 of type
        info_df$type <- gsub("^\\s*|\\s*$", "", info_df$type)
        
        args_split <- ddply(info_df, c("filename", "original", "func_name"), split_args, split_char=',')
        if(nrow(args_split) > 0) {args_split$io <- "input"}
        info_df$arguments <- NULL
        info_df <- rbind.fill(info_df, args_split)

        ## post-process the type information a little
        ## strip the space around the * and at the end
        info_df$type <- gsub("(\\w)\\s*(\\**)\\s*$", "\\1\\2", info_df$type, perl=TRUE)

        info_df$type <- post_process_type(info_df$type)
        info_df <- type_properties(info_df)
        
        return(info_df)
    }
    else {
        return(NULL)
    }
}

all_functions <- ldply(as.list(h_files_for_proto), find_prototypes_in_files)
## deprecated functions; remove them from the list
funcs_deprecated <- c("H5Glink", "H5Glink2", "H5Gmove", "H5Gmove2", "H5Gopen1", "H5Giterate", "H5Gget_objtype_by_idx", "H5Gcreate1", "H5Gget_comment",
                      "H5Gget_linkval", "H5Gget_num_objs", "H5Gget_objinfo", "H5Gget_objname_by_idx", "H5Gunlink") 
all_functions <- subset(all_functions, !func_name %in% funcs_deprecated)

#############################################################################
## Now deal with the structs
#############################################################################

## simple function that intends to find most structs
find_structs_in_file <- function(filename) {
    pattern <- paste0("^", pattern_typedef_se, "\\s*", pattern_name, "?\\s*", pattern_anything_in_curly, "\\s*", pattern_name, "\\s*;\\s*$")
    lines <- readLines(filename)
    lines_out <- character(length(lines))

    cur_line_out <- 1
    in_struct_enum <- FALSE
    for(i in seq_along(lines)) {
        lines_out[cur_line_out] <- paste(lines_out[cur_line_out], lines[i], sep="")
        if(grepl(pattern_typedef_se, lines[i], perl=TRUE)) { # enter the curly braces or the
            in_struct_enum <- TRUE
        }
        if(in_struct_enum && grepl("\\}", lines[i], perl=TRUE)) { # exit the curly braces
            in_struct_enum <- FALSE
        }
        if(!in_struct_enum) {
            cur_line_out <- cur_line_out + 1
        }
    }

    lines_struct <- lines_out[grepl(pattern, lines_out, perl=TRUE)]
    lines_struct <- gsub("\\s+", " ", lines_struct, perl=TRUE)
    
    ## remove trailing semicolon in arguments list
    lines_struct <- gsub(";\\s*\\}", "\\}", lines_struct, perl=TRUE)

    ## write out the cleaned file
    cat(lines_struct, file=paste0(filename, ".struct"), sep="\n")
    
    if(length(lines_struct)==0) {
        return(NULL)
    }
    
    ## now get the names of the struct, then parse the arguments
    all_df <- data.frame(filename=filename, original=lines_struct,
                            category=gsub(pattern, "\\1", lines_struct, perl=TRUE),
                            category_name=gsub(pattern, "\\4", lines_struct, perl=TRUE),
                            arguments=gsub(pattern, "\\3", lines_struct, perl=TRUE), stringsAsFactors = FALSE)

    struct_df <- subset(all_df, category %in% c("struct", "union"))
    enum_df <- subset(all_df, category=="enum")
    struct_split <- ddply(struct_df, c("filename", "original", "category", "category_name"), split_args, split_char=';')
    struct_split$type <- post_process_type(struct_split$type)
    enum_split <- ddply(enum_df, c("filename", "original", "category", "category_name"), split_enum, split_char=',')

    struct_split$arguments <- NULL
    enum_split$arguments <- NULL
    res <- rbind.fill(struct_split, enum_split)
    res <- type_properties(res)
    return(res)
}

all_struct_enum <- ldply(as.list(h_files_output), find_structs_in_file)
all_struct_enum$has_rtype <- TRUE
all_struct_enum$has_rtype[all_struct_enum$category=="enum"] <- TRUE

struct_no_rtype <- c("H5FD_free_t")
struct_not_used <- c("hvl_t", "H5G_stat_t") # hvl_t is not used in a function itself and H5G_stat_t is only used by a deprecated function
all_struct_enum <- subset(all_struct_enum, !category_name %in% c(struct_no_rtype, struct_not_used))



## first the high level struct and enum types
struct_enum_types <- unique(all_struct_enum[, c("category", "category_name", "has_rtype")])

struct_member_types <- unique(subset(all_struct_enum, category %in% c("struct", "union") & !is.na(has_rtype))$type_bare)

## define various other types
## define the different parameters that are as of yet unknown
## parameters that are pointers to functions:
## which are currently still missing?
types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_struct_enum$category_name)
func_types <- types_undefined[grepl("^H5A_operator|^H5D_operator|^H5E_auto|^H5E_walk|^H5[A-Z]_iterate|^H5I_free_t$|^H5L_elink_traverse_t|^H5MM_free|^H5MM_allocate|H5T_conv_t|func_t|H5DS_iterate_t|H5FD_file_image_callbacks_t|H5D_append_cb_t|H5O_mcdt_search_cb_t|H5F_flush_cb_t$", types_undefined, perl=TRUE)]
ulong_types <- c("ssize_t", "hsize_t", "size_t", "haddr_t", "hssize_t", "unsigned long", "off_t", "uint64_t")
long_types <- c("long int", "int64_t", "time_t")
int_types <- c("hid_t", "herr_t", "htri_t", "int", "unsigned", "hbool_t", "unsigned int", "H5E_major_t", "H5E_minor_t", "H5G_link_t",
               "H5Z_filter_t", "H5FD_mem_t", "H5O_msg_crt_idx_t", "unsigned char", "long", "long long", "short", "unsigned short", "uint32_t", "unsigned long long")
char_types <- c("char")
double_types <- c("double", "float")
void_types <- "void"
file_types <- "FILE"
all_other <- rbind.fill(data.frame(category="function_ptr", category_name=func_types, has_rtype=FALSE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=ulong_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=long_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="integer", category_name=int_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="char", category_name=char_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="float", category_name=double_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="void", category_name=void_types, has_rtype=TRUE, stringsAsFactors = FALSE),
                        data.frame(category="file", category_name=file_types, has_rtype=FALSE, stringsAsFactors = FALSE))


all_types <- rbind.fill(struct_enum_types, all_other)

types_undefined <- setdiff(c(struct_member_types, all_functions$type_bare), all_types$category_name)
if(length(types_undefined) > 0) {
    stop("Don't know a type that is needed here")
}



## now there are structs that contain elements that don't have an r equivalent; sort those out
struct_with_rtype_details <- merge(subset(all_struct_enum, category %in% c("struct", "union")),
                                    all_types, by.x="type_bare", by.y="category_name", suffixes=c("_category", "_type"),
                                    all.x=TRUE, all.y=FALSE)
struct_all_elements_rtype <- ddply(struct_with_rtype_details, c("category_name", "has_rtype_category"),
                                    function(dF) {data.frame(all_rtype=all(dF$has_rtype_type))})
## also don't use H5T_cdata_t
struct_all_elements_rtype$all_rtype[struct_all_elements_rtype$category_name=="H5T_cdata_t"] <- FALSE

struct_all_elements_rtype <- subset(struct_all_elements_rtype, all_rtype)


all_types_with_complete_rtype <- rbind.fill(subset(struct_enum_types, !category %in% c("struct", "union") |
                                               category_name %in% struct_all_elements_rtype$category_name), all_other)
all_types_with_complete_rtype <- subset(all_types_with_complete_rtype, has_rtype)

## merge the type information with the function information
all_functions_merged <- merge(all_functions, all_types_with_complete_rtype, by.x="type_bare", by.y="category_name", all.x=TRUE, all.y=FALSE)

## first we need an overview of the functions itself
function_summary <- function(dF) {
    ## get the return type
    dF_output <- subset(dF, io=="output")
    output_type <- dF_output$type
    if(length(output_type) > 1) {
        stop("There should be only one output type line")
    }
    is_getter <- any(grepl("get_", dF$func_name, fixed=TRUE)) # should only be a single function name
    num_args <- sum(dF$io=="input")
    num_args_reference <- sum(dF$io=="input" & grepl("*", dF$type, fixed=TRUE))
    num_args_non_const_FILE_reference <- sum(dF$io=="input" & dF$ref_depth > 0 & !dF$const &
                                             !grepl("FILE", dF$type, fixed=TRUE))
    has_all_rtype <- all(!is.na(dF$has_rtype))
    has_doubleref_void <- any(dF$ref_depth == 2 & dF$type_bare=="void")

    return(data.frame(output_type=output_type, is_getter=is_getter, num_args=num_args, num_args_reference=num_args_reference,
                      num_args_non_const_FILE_reference=num_args_non_const_FILE_reference,
                      has_all_rtype=has_all_rtype, has_doubleref_void=has_doubleref_void, stringsAsFactors = FALSE))    
}


## make a summary of the functions; for "getter" functions, return all objects that have been passed in by reference
all_functions_summary <- ddply(all_functions_merged, c("filename", "original", "func_name"), function_summary)

## create a list of separate "getter" functions, being those
additional_getters <- c("H5Eautos_is_v2", "H5Inmembers", "H5Pfill_value_defined", "H5Tfind")
all_functions_summary$is_getter[all_functions_summary$func_name %in% additional_getters] <- TRUE



## to the data from all_functions, add the info gained from the summary here
all_functions_merged_summary <- merge(all_functions_merged, all_functions_summary, all.x=TRUE)

all_functions_for_wrapping <- subset(all_functions_merged_summary, has_all_rtype & !has_doubleref_void)




## save the data frames we are interested in
## base types (including enums)
## structs
## and functions
all_types <- subset(all_types, category != "void" & has_rtype)
## subset the tpes with the allowed structs
all_types <- subset(all_types, category != "struct" | category_name %in% struct_all_elements_rtype$category_name)
saveRDS(all_types, file=file.path("store", "all_types.rds"))

## structs
saveRDS(subset(all_struct_enum, category_name %in% struct_all_elements_rtype$category_name), file=file.path("store", "struct_info.rds"))

## all the information on enums
saveRDS(subset(all_struct_enum, category=="enum"), file=file.path("store", "enum_info.rds"))

## functions
saveRDS(all_functions_for_wrapping, file=file.path("store", "functions_for_wrappping.rds"))



---
File: /inst/CWrappers_1.8.16/injectionCode.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



add_injection <- list(start=list(), pre_call=list(), post_call=list(), pre_list=list(), end=list())

## write injection code for H5Tset_size, that takes care of Infinity in the input
add_injection$pre_call$H5Tset_size <- c(
    "  // INJECTION CODE START",
    "  if(isReal(R_size ) && REAL(R_size)[0] == R_PosInf) {",
    "    size = H5T_VARIABLE;",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_call$H5Sset_extent_simple <- c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_max)) {",
    "    hsize_t* max_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_max)[i] == R_PosInf) {",
    "        max_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )
    
add_injection$pre_call$H5Screate_simple <-  c(
    "  // INJECTION CODE START",
    "  // the pointer is to const; need to cast it when I detect an Inf value",
    "  if(isReal(R_maxdims)) {",
    "    hsize_t* maxdims_helper = (hsize_t *) VOIDPTR(R_helper);",
    "    for(int i=0; i < rank; ++i) {",
    "      if(REAL(R_maxdims)[i] == R_PosInf) {",
    "        maxdims_helper[i] = H5S_UNLIMITED;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )


add_injection$pre_list$H5Sget_simple_extent_dims <- c(
    "  // INJECTION CODE START",
    "  // check if it is an int64 vector, and if yes which is H5S_UNLIMITED",
    "  // in that case, the return needs to be a real vector, so that Inf can be set",
    "  if(is_rint64(R_maxdims)) {",
    "    R_maxdims = PROTECT(convert_int64_using_flags(R_maxdims, H5TOR_CONV_INT64_FLOAT_FORCE));",
    "    vars_protected++;",
    "    double  dbl_unlimited = (double) LLONG_MAX;",
    "    R_xlen_t len = XLENGTH(R_maxdims);",
    "    for(R_xlen_t i = 0; i < len; ++i) {",
    "      if(REAL(R_maxdims)[i] == dbl_unlimited) {",
    "        REAL(R_maxdims)[i] = R_PosInf;",
    "      }",
    "    }",
    "  }",
    "  // INJECTION CODE END"
    )

add_injection$pre_call$H5Pset_chunk_cache <- c(
    "  // INJECTION CODE START",
    "  if(SEXP_to_longlong(R_rdcc_nslots, 0)==-1) {",
    "    rdcc_nslots = H5D_CHUNK_CACHE_NSLOTS_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_nbytes, 0)==-1) {",
    "    rdcc_nbytes = H5D_CHUNK_CACHE_NBYTES_DEFAULT;",
    "  }",
    "  if(SEXP_to_longlong(R_rdcc_w0, 0)==-1) {",
    "    rdcc_w0 = H5D_CHUNK_CACHE_W0_DEFAULT;",
    "  }",
    "  // INJECTION CODE END"
    )



---
File: /inst/CWrappers_1.8.16/remove_c_comments.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Remove C-style comments in a character string
##'
##' The function removes all C-style comments from a string vector
##' @title Remove C-style comments in a character string
##' @param lines The lines of the C code
##' @param remove_empty_lines Should empty code lines be removed as well
##' @return Returns the lines, but with the c-comments removed  
##' @author Holger Hoefling
##' @export
remove_c_comments <- function(lines, remove_empty_lines=TRUE) {
    in_slash_star_comment <- FALSE
    for(line_num in seq_along(lines)) {
        ## process one line at a time
        line_finished <- FALSE
        char_pos <- 1
        while(char_pos <= nchar(lines[line_num])) {
            if(in_slash_star_comment) {
                ## see if we can find the end
                hits <- gregexpr("*/", lines[line_num], fixed=TRUE)[[1]]
                hits <- hits[hits >=char_pos]
                if(length(hits) > 0) {
                    ## found end of comment in current line
                    ## remove the comment
                    lines[line_num] <- paste0(substr(lines[line_num], start=1, stop=char_pos-1),
                                              substr(lines[line_num], start=hits[1]+2, stop=nchar(lines[line_num])))
                    char_pos <- hits[1] + 2
                    in_slash_star_comment <- FALSE
                }
                else {
                    ## if an entire line is removed ... set to NA so that we can later delete it
                    ## line from char_pos to end is a comment 
                    lines[line_num] <- substr(lines[line_num], start=1, stop=char_pos - 1)
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
            else {
                ## search for the beginning of any style comment
                hits_dblslash <- gregexpr("//", lines[line_num], fixed=TRUE)[[1]]
                hits_dblslash <- hits_dblslash[hits_dblslash >= char_pos]
                hits_slash_star <- gregexpr("/*", lines[line_num], fixed=TRUE)[[1]]
                hits_slash_star <- hits_slash_star[hits_slash_star >= char_pos]

                if(length(hits_dblslash) > 0 && length(hits_slash_star) > 0) {
                    if(hits_dblslash[1] < hits_slash_star[1]) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                    }
                    else {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                    }
                }
                else if(length(hits_dblslash) > 0) {
                        ## delete everything to the end of the line
                        lines[line_num] <- substr(lines[line_num], start=1, stop=hits_dblslash[1] -1)
                }
                else if(length(hits_slash_star) > 0) {
                        char_pos <- hits_slash_star[1]
                        in_slash_star_comment <- TRUE
                }
                else {
                    ## nothing to do on this line
                    char_pos <- nchar(lines[line_num]) + 1
                }
            }
        }
    }
    if(remove_empty_lines) {
        empty_lines <- grepl("^\\s*$", lines, perl=TRUE)
        lines[empty_lines]  <- ""
    }
    return(lines)
}

##' Remove comments from a file and write it out again
##'
##' Reads in a file, removes the C-style comments and writes it back out
##' @title Remove comments from a file and write it out again
##' @param infile The original file to remove the comments from
##' @param outfile The file were the content without comments is written
##' @return invisible \code{NULL}
##' @author Holger Hoefling
##' @export
remove_c_comments_from_file <- function(infile, outfile) {
    lines <- readLines(infile)
    lines <- remove_c_comments(lines)
    cat(lines, file=outfile, sep="\n")
    return(invisible(NULL))
}



---
File: /inst/function_overview/createFunctionOverview.R
---

#############################################################################
##
## Copyright [2016] Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

library(bit64)
library(R6)
library(plyr)
library(brew)
library(knitr)


extract_dotcall <- function(expr, c_func_pattern) {
    if(length(expr) > 1) {
        if(is.call(expr)) {
            if(expr[[1]]==".Call") {
                if(is.character(expr[[2]])) {
                    last <- length(expr)
                    expr_names <- names(expr)
                    if(length(expr_names) > 0 && expr_names[last] == "PACKAGE" && is.character(expr[[last]])) {
                        if(c_func_pattern=="" || grepl(c_func_pattern, expr[[2]])) {
                            return(data.frame(c_function=expr[[2]], package=expr[[last]], stringsAsFactors=FALSE))
                        }
                        else {
                            return(NULL)
                        }
                    }
                    else {
                        return(data.frame(c_function=expr[[2]], package=NA, stringsAsFactors=FALSE))
                    }
                }
                else {
                    return(NULL)
                }
            }
            else {
                res <- ldply(as.list(expr), extract_dotcall, c_func_pattern=c_func_pattern)
                if(nrow(res)==0) {
                    return(NULL)
                }
                else {
                    return(res)
                }
            }
        }
        else {
            return(NULL)
        }
    }
    else {
        if(is.function(expr)) {
            return(extract_dotcall(body(expr), c_func_pattern=c_func_pattern))
        }
        else {
            return(NULL)
        }
    }
}


summarize_list <- function(x, c_func_pattern) {
    obj_names <- names(x)

    obj_info <- vector("list", length(obj_names))

    for(i in seq_along(obj_names)) {
        obj <- .subset2(x, obj_names[i])
        if(is.function(obj)) {
            obj_info[i] <- list(extract_dotcall(obj, c_func_pattern=c_func_pattern))
            if(is.null(obj_info[[i]])) {
                obj_info[[i]] <- data.frame(c_function=NA, package=NA, stringsAsFactors = FALSE)

            }
            deparse_func <- as.character(deparse(args(obj)))
            ## drop the NULL at the end
            if(deparse_func[length(deparse_func)] == "NULL") {
                deparse_func <- deparse_func[-length(deparse_func)]
            }
            deparse_func <- gsub("^\\s*", "", deparse_func)
            obj_info[[i]]$args <- paste(deparse_func, collapse = "")
            obj_info[[i]]$name <- obj_names[i]
        } else {
            obj_info[i] <- list(NULL)
        }
    }
    return(ldply(obj_info))
}


summarize_r6classgenerator <- function(r6class_gen, c_func_pattern) {
    if(!inherits(r6class_gen, "R6CalssGenerator")) {
        classname <- r6class_gen$classname
        if(!is.null(r6class_gen$inherit)) {
            cls_inherits <- as.character(r6class_gen$inherit)
        }
        else {
            cls_inherits <- NA
        }
    }
    public_methods <- summarize_list(r6class_gen$public_methods, c_func_pattern=c_func_pattern)
    active_methods <- summarize_list(r6class_gen$active, c_func_pattern=c_func_pattern)

    if(nrow(active_methods) > 0) {
        active_methods$active <- TRUE
    }
    if(nrow(public_methods) > 0) {
        public_methods$active <- FALSE
    }
    all_methods <- rbind(active_methods, public_methods)
    all_methods$class <- classname
    all_methods$inherits <- cls_inherits
    all_methods$h5_link <- create_h5_html_ref(all_methods$c_function)
    all_methods$rd_link <- create_h5_html_ref(all_methods$c_function, in_Rd=TRUE)

    return(all_methods[, c("class", "inherits", "name", "active", "c_function", "package", "h5_link", "rd_link", "args")])
}




create_h5_html_ref <- function(c_function, in_Rd=FALSE) {
    ## first check if it is an h5 name
    res <- data.frame(c_function=c_function)
    res$is_h5 <- grepl("R_H5", c_function)
    res$group <- NA
    res$group[res$is_h5] <- gsub("^R_(H5[A-Z]*)[a-z].*$", "\\1", res$c_function[res$is_h5], perl=TRUE)
    res$h5_name_in_group <- NA
    res$h5_name_in_group[res$is_h5] <- gsub("^R_(H5[A-Z]+)([a-z].*)$", "\\2", res$c_function[res$is_h5], perl=TRUE)

    res$h5_name_in_group_camel <- NA
    res$h5_name_in_group_camel[res$is_h5] <- gsub("^([a-z])", "\\U\\1\\E", res$h5_name_in_group[res$is_h5], perl=TRUE)
    res$h5_name_in_group_camel[res$is_h5] <- gsub("_([a-z])", "\\U\\1\\E", res$h5_name_in_group_camel[res$is_h5], perl=TRUE)
    
    group_names_base <- c(H5="Library", H5A="Annot", H5D="Dataset", H5E="Error", H5F="File", H5G="Group",
                          H5I="Identify", H5L="Link", H5O="Object", H5P="Property", H5R="Reference", H5S="Dataspace",
                          H5T="Datatype", H5Z="Compression")

    res$name_on_page <- NA
    res$doc_dir <- NA
    res <- within(res, {
        is_base_group <- group %in% names(group_names_base);
        name_on_page[is_base_group] <- paste0(group_names_base[group[is_base_group]], "-", h5_name_in_group_camel[is_base_group]);
        name_on_page[!is_base_group] <- gsub("^_", "", c_function[!is_base_group], perl=TRUE);
        doc_dir[is_base_group] <- "RM";
        doc_dir[!is_base_group] <- "HL"
    })

    if(!in_Rd) {
        res$h5_manual_link <- NA
        res$h5_manual_link[res$is_h5] <- with(subset(res, is_h5), paste0("https://www.hdfgroup.org/HDF5/doc/", doc_dir, "/RM_", group,
                                                                         ".html#", name_on_page))
        res$h5_manual_link[res$is_h5] <- with(subset(res, is_h5), make_HTML_link(h5_manual_link, name_on_page))
        return(res$h5_manual_link)
    }
    else {
        res$h5_rd_link <- NA
        res$h5_rd_link[res$is_h5] <- with(subset(res, is_h5), paste0("\\\\url{https://www.hdfgroup.org/HDF5/doc/", doc_dir, "/RM_", group,
                                                                     ".html#", name_on_page, "}"))

        return(res$h5_rd_link)
    }
                                          
}


create_HTML_table <- function(data_frame, table_name) {
    output.html <- kable(data_frame, "html", table.attr= paste("id=\"", table_name, "\"", sep=""), escape=FALSE)    
    javascript <- c("<script type=\"text/javascript\">", "$(document).ready(function() {", paste("$('#", table_name, "').DataTable();", sep=""),
                    "} );", "</script>")
    output.html <- c(output.html, javascript)
    return(output.html)
}

make_HTML_link <- function(url, text=url) {
    return(paste("<a href=\"", url, "\">", text, "</a>\n", sep=""))
}


brew_overview <- function(tbl_with_inheritance, tbl_no_inheritance, brew_file="function_overview.brew") {
    env <- new.env()
    env$table_no_inheritance.html <- create_HTML_table(replace_NA_with_empty(tbl_no_inheritance), "tbl_no_inheritance")
    env$table_with_inheritance.html <-     create_HTML_table(replace_NA_with_empty(tbl_with_inheritance), "tbl_with_inheritance")

    brew(brew_file, output=gsub("brew$", "html", brew_file), envir=env)
}

replace_NA_with_empty <- function(df) {
    for(i in seq_along(df)) {
        col <- df[[i]]
        col[is.na(col)] <- ""
        df[[i]] <- col
    }
    return(df)
}

add_inherited_functions <- function(df) {

    ## split the rest into the parts that inherits from a base class and that doesn't
    ## inherit from a base class
    base_class_funcs <- df[is.na(df$inherits),]
    base_classes <- unique(base_class_funcs$class)
    inherits_from_base_class <- df[!is.na(df$inherits) & df$inherits %in% base_classes,]
    inherits_from_other_class <- df[!is.na(df$inherits) & !(df$inherits %in% base_classes),]

    ## for the classes that inherit from the base classes, add the function of said class
    class_inherits_from_base <- unique(inherits_from_base_class$class)
    func_expanded <- NULL
    for(cls in class_inherits_from_base) {
        base_class <- unique( subset(inherits_from_base_class, class==cls)$inherits)
        funcs_inherited <- subset(base_class_funcs, class==base_class)
        funcs_inherited$class <- cls
        func_expanded <- rbind(func_expanded, subset(inherits_from_base_class, class==cls),
                               funcs_inherited)
    }
    if(!is.null(func_expanded) && nrow(func_expanded) > 0) {
        func_expanded$inherits <- NA
    }

    ## now check if there are any other classes left
    if(nrow(inherits_from_other_class) > 0) {
        res <- add_inherited_functions(rbind(base_class_funcs, func_expanded, inherits_from_other_class))
    }
    else {
        res <- rbind(base_class_funcs, func_expanded)
    }
    return(res)
}

## get all the functions that are in the classes

## first source all the R-scripts into an environment
r_files <- list.files("../../R", pattern=glob2rx("*.R"), full.names=TRUE)
source_env <- new.env()
for(r_file in r_files) {
    source(r_file, local=source_env)
}
## remove the Chunk_sort_tracker
rm(list="Chunk_sort_tracker", envir=source_env)

## first, get all R6ClassGenerators
obj_names <- ls(envir=source_env)
r6classes <- NULL
for(obj_name in obj_names) {
    obj <- get(obj_name, envir=source_env)
    if(inherits(obj, "R6ClassGenerator")) {
        r6classes <- c(r6classes, list(obj))
    }
}
all_classes_summary <- ldply(r6classes, summarize_r6classgenerator, c_func_pattern="")
all_classes_h5only_summary <- ldply(r6classes, summarize_r6classgenerator, c_func_pattern="_H5")


no_package <- subset(all_classes_summary, !is.na(c_function) & (is.na(package) | package!="hdf5r"))
if(nrow(no_package) > 0) {
    stop("There are functions with a .Call that don't point to this package")
}

## for the tables, we don't need "active" or "package"
all_classes_h5only_summary_pretty <- all_classes_h5only_summary[, c("class", "inherits", "name", "c_function", "h5_link")]
all_classes_inherited <- add_inherited_functions(all_classes_h5only_summary_pretty)
all_classes_inherited$inherits <- NULL


tbl_inherited_for_brew <- all_classes_inherited
tbl_inherited_for_brew$c_function <- gsub("^_", "", tbl_inherited_for_brew$c_function)
tbl_no_inheritance_for_brew <- all_classes_h5only_summary_pretty
tbl_no_inheritance_for_brew$c_function <- gsub("^_", "", tbl_no_inheritance_for_brew$c_function)

rownames(tbl_inherited_for_brew) <- NULL
rownames(tbl_no_inheritance_for_brew) <- NULL
brew_overview(tbl_inherited_for_brew, tbl_no_inheritance_for_brew, brew_file="function_overview.brew")


###########################################################
## Now will create the field and methods section for the
## documentation of R6 classes
###########################################################


## this function is currently unused 
extract_comment <- function(func) {
    ## first need to get the deparse function
    func_deparsed <- deparse(func, control="useSource")

    ## now delete the top of the function (up to and including the first {
    all_curly <- grep(pattern="\\{", func_deparsed)
    if(length(all_curly) == 0) {
        return(character(0))
    }

    first_curly <- min(all_curly)
    func_deparsed <- func_deparsed[- seq_len(first_curly)]
    
    ## now check if there is a comment at the beginning; it has to start with ##
    ## grab all the comments
    ## remove the ## and return the rest
    has_comment <- grepl("\\s*#'", func_deparsed)
    if(!all(has_comment)) {
        ## use only the beginning
        first_not_comment <- which(!has_comment)[1]
        comment_section <- func_deparsed[seq_len(first_not_comment - 1)]
    }
    else {
        comment_section <- func_deparsed
    }
    
    ## remove the spaces and ##
    comment_section <- gsub("\\s*#'\\s*", "", comment_section)
    ## check that it contains the document keyword
    return(comment_section)
}


## Now will also write out a file that contains a default docstring for all
## functions that contain a call to an HDF5 file
## this is to make the task of writing docstrings for these functions easier.
## we will just have to copy/paste

template_docstring <- with(subset(all_classes_h5only_summary, !is.na(rd_link)), {
    template_docstring <- paste0(class, "-", name, "\n\"This function implements the HDF5-API function ", substr(c_function, 3, nchar(c_function)),".\"\n\"Please see the documentation at ", rd_link, " for details.\"\n")
})

cat(template_docstring, file="docstring_templates.txt", sep="\n")
                           



---
File: /inst/speed_check/Speed_test.R
---

## in this file some very simple read/write tests will be stored in order
## to diagnose and improve performance of the package
## Possible issues revolve around the time it takes to create R6 objects, which
## are currently used in the read/write process

library(profvis)
library(hdf5r)

dim1 <- dim2 <- 10
num_slices <- 1000

## In this test, we create a file with dim1 x dim2 x num_slices array in which we write
## one slice (third dimension) row at a time the data out of another array
## and after, we read it back out one slice at a time and compare

file_h5_name <- tempfile(fileext=".h5")
file_h5 <- H5File$new(file_h5_name, mode="a")

test_array <- array(data=rnorm(dim1 * dim2 * num_slices), dim=c(dim1, dim2, num_slices))

test_array_h5 <- file_h5$create_dataset("test_array", dtype=h5types$H5T_NATIVE_DOUBLE, space=H5S$new(type="simple", dims=c(dim1, dim2, num_slices)))
                    
profvis_write <- profvis({
    for(i in seq_len(num_slices)) {
        test_array_h5[,,i] <- test_array[,,i]
    }
})

profvis_read <- profvis({
    for(i in seq_len(num_slices)) {
        res <- test_array_h5[,,i]
        if(any(test_array[,,i] != res)) {
            stop("Problem with the output at slice", i)
        }
    }
})

print(profvis_write)
print(profvis_read)

file_h5$close_all()




---
File: /inst/test_implementations/reorder.R
---

## intended method for H5D to reorder a dataset
reorder=function(reorder_dim, start, end, new_order, max_mem, dataset_xfer_pl=h5const$H5P_DEFAULT, key_info=NULL) {
    "Reorder a subset of an HDF5 dataset along a specific dimension. It is mostly intended as a function to be"
    "used by a sorting algorithm and is not checked for correct inputs. Incorrect use can corrupt a dataset"
    "@param reorder_dim The number of the dimension along which the reordering should occur."
    "@param start,end The start and end index where the reordering should occur (can be vectors of equal length)"
    "@param new_order The new ordering of the items to re-order. The ith item gives the index in the source for the i-th item in"
    "the destination (for the \\code{reorder_dim})"
    "@param max_mem Memory usage of the function in bytes (a rough guide, can be somewhat exceeded)"
    "@param dataset_xfer_pl The dataset transfer propery list"
    "@param key_info The key_info returned by the \\code{key_info} method of the dataset"
    
    check_pl(dataset_xfer_pl, "H5P_DATASET_XFER")
    
    if(is.null(key_info)) {
        key_info <- self$key_info
    }
    ## divide memory by two as at least 2 buffers will be needed
    max_mem <- max_mem / 2
    
    ds_dims <- key_info$dims
    chunk_dims <- key_info$chunk_dims
    if(any(is.na(chunk_dims))) {
        ## not chunked, every element separate
        chunk_dims <- rep(1, length(ds_dims))
    }
    chunk_dims[reorder_dim] <- sum(end - start + 1)
    
    ## calculate number of chunks that can be fitted into
    ## memory size
    ds_type_size <- key_info$type_size_raw
    chunk_size <- ds_type_size * prod(chunk_dims)
    
    ## check if we can then read in even one datapoint
    if(chunk_size > max_mem) {
        chunk_dims <- rep(1, length(ds_dims))
        chunk_dims[reorder_dim] <- sum(end - start + 1)
        chunk_size <- ds_type_size * prod(chunk_dims)
        if(chunk_size > max_mem) {
            stop("max_mem too small to read in necessary data for reordering")
        }
        else {
            warning("Cannot process data along chunk lines, reverting to smaller sizes")
        }
    }
    
    ## calculate the number of chunks per dimension we can read in at the same time
    num_chunks <- ceiling(ds_dims / chunk_dims)
    num_chunks[reorder_dim] <- 1
    ## repurposing the function that calculates the number of elements in a chunk
    ## to calculate the number of chunks in a hyperslab
    ## for s
    chunk_mult <- guess_chunks(space_maxdims=num_chunks, dtype_size=chunk_size, chunk_size=max_mem)
    metachunk_dims <- chunk_dims * chunk_mult
    metachunk_dims[reorder_dim] <- sum(end - start + 1)
    num_metachunks <- ceiling(ds_dims / metachunk_dims)
    num_metachunks[reorder_dim] <- 1
    
    ## now we have defined the optimal chunk size; now need to read it in, reorder it
    ## and write it back out one item at a time
    ## will use the lowest level read function to get optimal speed
    total_chunks <- prod(num_metachunks)
    ## need to get a buffer of sufficient size
    buffer_size <- ds_type_size * prod(metachunk_dims)
    buffer <- raw(buffer_size)
    
    ds_file_space <- key_info$space
    ds_mem_space <- H5S$new(type="simple", dims=metachunk_dims, maxdims=metachunk_dims)
    ds_mem_space_start <- rep(1, length(ds_dims))
    ds_mem_space_count <- rep(1, length(ds_dims))
    ds_mem_space_stride <- rep(1, length(ds_dims))
                                        # print(metachunk_dims)
    is_vlen_type <- key_info$type$is_vlen()
    for(i in seq_len(prod(num_metachunks))) {
        ds_file_space$select_none()
        ds_mem_space$select_none()
        chunk_indices <- array_counter(count=i-1, dims=num_metachunks)
                                        # print(chunk_indices)
        
        ## create a return similar to that of the evaluate_arugments function so that we can re-use the
        ## space_selection function
        slab_start <- chunk_indices * metachunk_dims + 1
        slab_count <-  rep(1, length(ds_dims))
        slab_stride <- rep(1, length(ds_dims))
        slab_block <- pmin(metachunk_dims, ds_dims - slab_start + 1)
        
        ## the memory block is simply one contiguous set
        ds_mem_space_block <- slab_block
        ds_mem_space_block[reorder_dim] <- metachunk_dims[reorder_dim] # this one is always maximal
        ds_mem_space$select_hyperslab(start=ds_mem_space_start, count=ds_mem_space_count, stride=ds_mem_space_stride,
                                      block=ds_mem_space_block, op=h5const$H5S_SELECT_SET)
        ## need to build a complex selection here for the file space
        for(i in seq_along(start)) {
            slab_start[reorder_dim] <- start[i]
            slab_block[reorder_dim] <- end[i] - start[i] + 1
            ds_file_space$select_hyperslab(start=slab_start, count=slab_count, stride=slab_stride, block=slab_block,
                                           op=h5const$H5S_SELECT_OR)                               
        }
                                        # print(ds_file_space$get_select_hyper_blocklist())
        ## now read the data into the buffer; the buffer may be larger than the data
        res_read <- .Call("R_H5Dread", self$id, key_info$type$id, ds_mem_space$id, ds_file_space$id, dataset_xfer_pl$id,
                          buffer, FALSE, PACKAGE="hdf5r")
        if(res_read$return_val < 0) {
            stop("Error reading dataset")
        }
        
        ## reorder the columns; here we set the dimensions of the dataset to the metachunk dimensions
        ## on the re-ordering dimension, this is exact, but it may be larger on the others.
        ## in this case, we may be re-ordering a part of the larger array, that contains data that is not part
        ## of the current selection; this is fine, as we ignore this part again later when writing the data back out
        buffer_reordered <- array_reorder(res_read$buf, dims=metachunk_dims, reorder_dim=reorder_dim, new_order=new_order,
                                          item_size = ds_type_size)
        
        ## write the buffer back out
        res_write <- .Call("R_H5Dwrite", self$id, key_info$type$id, ds_mem_space$id, ds_file_space$id, dataset_xfer_pl$id,
                           buffer_reordered, PACKAGE="hdf5r")
        
        ## reclaim vlen data if the mem_type is vlen
        if(is_vlen_type) {
            self$vlen_reclaim(buffer=res_read$buf, type=key_info$type, space=ds_mem_space, dataset_xfer_pl=dataset_xfer_pl)
        }                          
        
    }                     
    ## only close the memory space we created here
    ds_mem_space$close()
    
    return(self)
}



---
File: /R/adapt_during_onLoad.R
---

adapt_classes <- function() {
    ## in 1.10.3 new version of H5Oget_info was introduced, so that we now have
    ## to use H5Oget_info2 and we have a "fields" paramater now
    ## similarly for H5Oget_info_by_idx as well as H5Oget_info_by_name
    if(compareVersion(h5version(verbose=FALSE), "1.10.3") >= 0) {
        commonFG_adapt <- list(
            obj_info_by_idx=function(n, group_name=".", index_field=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, remove_internal_use_only=TRUE) {
                "This function implements the HDF5-API function H5Oget_info_by_idx."
                "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."
                if(group_name!="." && !self$exists(group_name)) {
                    stop(paste(group_name, " does not exist"))
                }

                if(remove_internal_use_only) {
                    fields <- bitwOr(h5const$H5O_INFO_BASIC, h5const$H5O_INFO_NUM_ATTRS)
                }
                else {
                    fields <- h5const$H5O_INFO_ALL
                }

                res <- .Call("R_H5Oget_info_by_idx2", self$id, group_name, index_field, order, n, request_empty(1),
                             fields, h5const$H5P_DEFAULT$id,
                             PACKAGE = "hdf5r")
                if(res$return_val < 0) {
                    stop("Could not retrieve object info by index")
                }
                
                return(res$oinfo)
            },
            obj_info_by_name=function(object_name, remove_internal_use_only=TRUE) {
                "This function implements the HDF5-API function H5Oget_info_by_name."
                "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."
                
                if(!self$exists(object_name)) {
                    stop(paste(object_name, " does not exist"))
                }
                
                if(remove_internal_use_only) {
                    fields <- bitwOr(h5const$H5O_INFO_BASIC, h5const$H5O_INFO_NUM_ATTRS)
                }
                else {
                    fields <- h5const$H5O_INFO_ALL
                }
                
                res <- .Call("R_H5Oget_info_by_name2", self$id, object_name, request_empty(1),
                             fields, h5const$H5P_DEFAULT$id,
                             PACKAGE = "hdf5r")
                if(res$return_val < 0) {
                    stop("Could not retrieve object info by index")
                }
                return(res$oinfo)
            })
        
        commonFGDT_adapt <- list(
            obj_info=function(remove_internal_use_only=TRUE) {
                "This function implements the HDF5-API function H5Oget_info."
                "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."
                
                                        # request all info; could also make this more efficient
                if(remove_internal_use_only) {
                    fields <- bitwOr(h5const$H5O_INFO_BASIC, h5const$H5O_INFO_NUM_ATTRS)
                }
                else {
                    fields <- h5const$H5O_INFO_ALL
                }
                res <- .Call("R_H5Oget_info2", self$id, request_empty(1), fields, PACKAGE = "hdf5r")
                if(res$return_val < 0) {
                    stop("Error getting object info")
                }
                return(res$oinfo)
            })

        ## now it needs to be inserted into all relevant classes
        ## in there it will overwrite the already existing functions with these newer ones
        R6_set_list_of_items(H5File, "public", commonFG_adapt, overwrite=TRUE)
        R6_set_list_of_items(H5Group, "public", commonFG_adapt, overwrite=TRUE)
        R6_set_list_of_items(H5File, "public", commonFGDT_adapt, overwrite=TRUE)
        R6_set_list_of_items(H5Group, "public", commonFGDT_adapt, overwrite=TRUE)
        R6_set_list_of_items(H5D, "public", commonFGDT_adapt, overwrite=TRUE)
        R6_set_list_of_items(H5T, "public", commonFGDT_adapt, overwrite=TRUE)
    }
}



---
File: /R/Common_functions.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





interface <- list(
    get_file_id=function() {
        "This function implements the HDF5-API function H5Iget_file_id."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."

        fid <- .Call("R_H5Iget_file_id", self$id, PACKAGE="hdf5r")$return_val
        return(H5File$new(id=fid))
    },
    get_obj_type=function() {
        "This function implements the HDF5-API function H5Iget_type."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."

        res <- .Call("R_H5Iget_type", self$id, PACKAGE="hdf5r")$return_val
        return(res)
    },
    get_ref=function() {
        "This function implements the HDF5-API function H5Iget_ref."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."

        res <- .Call("R_H5Iget_ref", self$id, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop("Error retrieving refernce count")
        }
        return(res)
    },
    inc_ref=function() {
        "This function implements the HDF5-API function H5Iinc_ref."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."

        res <- .Call("R_H5Iinc_ref", self$id, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop("Error retrieving refernce count")
        }
        return(invisible(self))
    },
    dec_ref=function() {
        "This function implements the HDF5-API function H5Idec_ref."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."

        res <- .Call("R_H5Idec_ref", self$id, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop("Error retrieving refernce count")
        }
        return(invisible(self))
    }
    )

commonFG <- list(
    open=function(name, link_access_pl=h5const$H5P_DEFAULT, dataset_access_pl=h5const$H5P_DEFAULT, type_access_pl=h5const$H5P_DEFAULT) {
        "Opens groups, datasets or types using the appropriate HDF5-API functions. Please see the documentation at"
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for datasets, "
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for types and "
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for general objects."

        if (length(name)!=1 || !is.character(name)) stop("'name' must be a character string of length 1")

        ## check the property lists and get their ids if they aren't already default
        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(dataset_access_pl, "H5P_DATASET_ACCESS")
        check_pl(type_access_pl, "H5P_TYPE_ACCESS")

        if(self$exists(name, link_access_pl=link_access_pl)) {
            ## check if any of the other properties are set; if yes - use them
            if(dataset_access_pl$id != h5const$H5P_DEFAULT$id) {
                ## use specialized method as it seems to be a dataset
                oid <- .Call("R_H5Dopen", self$id, name, dataset_access_pl$id, PACKAGE = "hdf5r")$return_val
            }
            else if(type_access_pl$id != h5const$H5P_DEFAULT$id) {
                oid <- .Call("R_H5Topen2", self$id, name, type_access_pl$id, PACKAGE = "hdf5r")$return_val
            }
            else {
                oid <- .Call("R_H5Oopen", self$id, name, link_access_pl$id, PACKAGE = "hdf5r")$return_val
            }
            if(oid < 0) {
                stop("Error opening object")
            }
            return(H5GTD_factory(oid))
        }
        else {
            stop(paste("An object with name", name, "does not exist"))
        }
    },
    open_by_idx=function(n, group_name=".", index_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Oopen_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."

        if (length(group_name)!=1 || !is.character(group_name)) stop("'group_name' must be a character string of length 1")

        ## check the property lists and get their ids if they aren't already default
        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(group_name=="." || self$exists(group_name, link_access_pl=link_access_pl)) {
            ## check if any of the other properties are set; if yes - use them
            oid <- .Call("R_H5Oopen_by_idx", self$id, group_name, index_type, order, n, link_access_pl$id, PACKAGE = "hdf5r")$return_val
            if(oid < 0) {
                stop("Error opening object")
            }
            return(H5GTD_factory(oid))
        }
        else {
            stop(paste("An object with name", group_name, "does not exist"))
        }
    },
    ls=function(recursive=FALSE, detailed=FALSE, index_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT,
        dataset_access_pl=h5const$H5P_DEFAULT, type_access_pl=h5const$H5P_DEFAULT) {
        "Returns the contents of a file or group as a data.frame."

        ls_res <- .Call("R_H5ls", self$id, recursive, index_type, order, link_access_pl$id,
                        dataset_access_pl$id, type_access_pl$id, PACKAGE='hdf5r')$return_val
        ls_res <- clean_ls_df(ls_res)
        if(detailed) {
            return(ls_res)
        }
        else {
            ls_res <- flatten_df(ls_res)
            ls_res_summary <- ls_res[, c("name", "link.type", "obj_type", "num_attrs", "group.nlinks", "group.mounted", "dataset.rank",
                                         "dataset.dims", "dataset.maxdims", "dataset.type_class", "dataset.space_class", "committed_type")]
            return(ls_res_summary)
        }
    },
    exists=function(name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lexists."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        res <- .Call("R_H5Lexists", self$id, name, link_access_pl$id, PACKAGE = "hdf5r")$return_val
        if(res < 0) {
            stop("Error trying to ascertain if link exists")
        }
        return(res > 0)
    },
    path_valid=function(path, check_object_valid=TRUE) {
        "This function implements the HDF5-API function H5LTpath_valid."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l_t.html} for details."

        res <- .Call("R_H5LTpath_valid", self$id, path, check_object_valid, PACKAGE = "hdf5r")$return_val
        if(res < 0) {
            stop("Error trying to ascertain if path is valid")
        }
        return(res > 0)
    },
    link=function(obj, new_link_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Olink."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."

        if(!(inherits(obj, "H5D") || inherits(obj, "H5Group") || inherits(obj, "H5T"))) {
            stop("obj has to be a group, dataset or type")
        }

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")
        herr <- .Call("R_H5Olink", obj$id, self$id, new_link_name, link_create_pl$id, link_access_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error trying to create a new link")
        }
        return(invisible(self))
    },
    obj_copy_to=function(dst_loc, dst_name, src_name, object_copy_pl=h5const$H5P_DEFAULT, link_create_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Ocopy."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."

        if(!(inherits(dst_loc, "H5File") || inherits(dst_loc, "H5Group"))) {
            stop("dst_loc has to be a file or group")
        }
        check_pl(link_create_pl, "H5P_LINK_CREATE")
        check_pl(object_copy_pl, "H5P_OBJECT_COPY")

        herr <- .Call("R_H5Ocopy", self$id, src_name, dst_loc$id, dst_name, object_copy_pl$id, link_create_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error copying object")
        }
        return(invisible(self))
    },
    obj_copy_from=function(src_loc, src_name, dst_name, object_copy_pl=h5const$H5P_DEFAULT, link_create_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Ocopy."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."

        if(!(inherits(src_loc, "H5File") || inherits(src_loc, "H5Group"))) {
            stop("src_loc has to be a file or group")
        }
        check_pl(link_create_pl, "H5P_LINK_CREATE")
        check_pl(object_copy_pl, "H5P_OBJECT_COPY")

        herr <- .Call("R_H5Ocopy", src_loc$id, src_name, self$id, dst_name, object_copy_pl$id, link_create_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error copying object")
        }
        return(invisible(self))
    },
    obj_info_by_idx=function(n, group_name=".", index_field=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, remove_internal_use_only=TRUE) {
        "This function implements the HDF5-API function H5Oget_info_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."
        if(group_name!="." && !self$exists(group_name)) {
            stop(paste(group_name, " does not exist"))
        }
        res <- .Call("R_H5Oget_info_by_idx", self$id, group_name, index_field, order, n, request_empty(1), h5const$H5P_DEFAULT$id,
                     PACKAGE = "hdf5r")
        if(res$return_val < 0) {
            stop("Could not retrieve object info by index")
        }

        if(remove_internal_use_only) {
            oinfo <- res$oinfo
            oinfo$meta_size <- NULL
            return(oinfo)
        }
        else {
            return(res$oinfo)
        }
    },
    obj_info_by_name=function(object_name, remove_internal_use_only=TRUE) {
        "This function implements the HDF5-API function H5Oget_info_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."

        if(!self$exists(object_name)) {
            stop(paste(object_name, " does not exist"))
        }
        res <- .Call("R_H5Oget_info_by_name", self$id, object_name, request_empty(1), h5const$H5P_DEFAULT$id,
                     PACKAGE = "hdf5r")
        if(res$return_val < 0) {
            stop("Could not retrieve object info by index")
        }
        if(remove_internal_use_only) {
            oinfo <- res$oinfo
            oinfo$meta_size <- NULL
            return(oinfo)
        }
        else {
            return(res$oinfo)
        }
    },
    group_info=function() {
        "This function implements the HDF5-API function H5Gget_info."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_g.html} for details."

        res <- .Call("R_H5Gget_info", self$id, request_empty(1), PACKAGE = "hdf5r")
        if(res$return_val < 0) {
            stop("Error getting object info")
        }
        return(res$ginfo)
    },
    group_info_by_name=function(name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Gget_info_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_g.html} for details."

        res <- .Call("R_H5Gget_info_by_name", self$id, name, request_empty(1), link_access_pl$id,
                     PACKAGE = "hdf5r")
        if(res$return_val < 0) {
            stop("Could not retrieve object info by index")
        }
        return(res$ginfo)
    },
    group_info_by_idx=function(n, group_name=".",  index_field=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE,
        link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Gget_info_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_g.html} for details."

        if(group_name!="." && !self$exists(group_name)) {
            stop(paste(group_name, " does not exist"))
        }
        res <- .Call("R_H5Gget_info_by_idx", self$id, group_name, index_field, order, n, request_empty(1), link_access_pl$id,
                     PACKAGE = "hdf5r")
        if(res$return_val < 0) {
            stop("Could not retrieve object info by index")
        }
        return(res$ginfo)
    },
    create_group=function(name, link_create_pl=h5const$H5P_DEFAULT, group_create_pl=h5const$H5P_DEFAULT,
        group_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Gcreate2 and H5Gcreate_anon (if name is NULL). Please see the documentation at"
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_g.html} for regular groups and"
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_g.html} for anonymous groups for details."

        if(!(is.null(name) || is.character(name))) {
            stop("name has to be NULL or a character vector")
        }
        if(length(name) > 1) {
            stop("name has to be of length at most 1")
        }

        check_pl(link_create_pl, "H5P_LINK_CREATE")
        check_pl(group_create_pl, "H5P_GROUP_CREATE")
        check_pl(group_access_pl, "H5P_GROUP_ACCESS")

        if(length(name)==0) { ## create anonymous group
            id <- .Call("R_H5Gcreate_anon", self$id, group_create_pl$id, group_access_pl$id, PACKAGE = "hdf5r")$return_val
        }
        else {
            id <- .Call("R_H5Gcreate2", self$id, name, group_create_pl$id, link_create_pl$id, group_access_pl$id, PACKAGE = "hdf5r")$return_val
        }
        if(id < 0) {
            stop("Error when creating group")
        }
        return(H5Group$new(id))
    },
    create_dataset=function(name, robj=NULL, dtype=NULL, space=NULL, dims=NULL, chunk_dims="auto", gzip_level=4,
        link_create_pl=h5const$H5P_DEFAULT, dataset_create_pl=h5const$H5P_DEFAULT, dataset_access_pl=h5const$H5P_DEFAULT) {
        "This function is the main interface to create a new dataset. Its parameters allow for customization of the default"
        "behavior, i.e. in order to get a specific datatype, a certain chunk size or dataset dimensionality."
        "Also note that this function implements the HDF5-API function H5Dcreate2 and H5Dcreate_anon (if name is NULL). Please see the documentation at"
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for regular groups and"
        "\\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for anonymous groups for details."
        "@param name The name of the new dataset. If missing, an anonymous dataset is created"
        "@param robj An R-object to take as a template for creating the dataset. Either \\code{robj} or both \\code{dtype} and \\code{space} have to be provided"
        "@param dtype The datatype to use for the creation of the object. Can be null if \\code{robj} is given."
        "@param space The space to use for the object creation. Can be null if \\code{robj} is given. Otherwise an object of type \\code{H5S} which specifies the dimensions of the dataset."
        "@param dims Dimension of the new dataset; used if \\code{space} is \\code{NULL}. overwrite the dimension guessed from \\code{robj}"
        "if \\code{robj} is given."
        "@param chunk_dims Size of the chunk. Has to have the same length as the dataset dimension. If \\code{\"auto\"}"
        "then the size of each chunk is estimated so that each chunk is roughly as large in bytes as the value in"
        "the \\code{hdf5r.chunk_size} option. See also \\code{\\link{guess_chunks}} for a more detailed explanation."
        "If set to \\code{NULL}, then no chunking is used, unless explicitly set in \\code{dataset_create_pl}."
        "@param gzip_level Only if \\code{chunk_dims} is not null. If given, then the \\code{dataset_create_pl} is set to enable zipping"
        "at the level given here. If set to NULL, then gzip is not set (but could be set otherwise in \\code{dataset_create_pl}"
        "@param link_create_pl Link creation property list. See \\code{\\link{H5P_LINK_CREATE}}"
        "@param dataset_create_pl Dataset creation property list. See \\code{\\link{H5P_DATASET_CREATE}}"
        "@param dataset_access_pl Dataset access property list. See \\code{\\link{H5P_DATASET_ACCESS}}"


        if(missing(name)) {
            name <- character(0)
        }
        else {
            if(self$exists(name)) {
                stop(paste("Can't create dataset", name, "- already exists!"))
            }
        }
        ## check that all parameters are of the expected type
        if(!is.character(name) && !is.null(name)) {
            stop("Name has to be a character vector or null")
        }
        if(length(name) > 1) {
            stop("name has to be of length at most 1")
        }

        ## check that enough data is given to determine size of space
        if(is.null(robj)) {
            if(is.null(dtype)) {
                stop("If a sample robj is not provided, then dtype has to be given")
            }
            else {
                if(is.null(space) && is.null(dims)) {
                    stop("If a sample robj is not provided, space or dims has to be given")
                }
            }
        }
        ## adapt dtype, space as necessary
        if(is.null(dtype)) {
            dtype <- guess_dtype(x=robj, scalar=FALSE, string_len=Inf)
        }
        if(is.null(space)) {
            if(is.null(dims)) {
                if(!is.null(chunk_dims)) {
                    space <- guess_space(x=robj, dtype=dtype, chunked=TRUE)
                }
                else {
                    space <- guess_space(x=robj, dtype=dtype, chunked=FALSE)
                }
            }
            else {
                if(!is.null(chunk_dims)) {
                    space <- H5S$new(type="simple", dims=dims, maxdims=rep(Inf, length(dims)))
                }
                else {
                    space <- H5S$new(type="simple", dims=dims, maxdims=dims)
                }
            }
        }

        ## now manipulate the dataset_create_pl
        if(!is.null(chunk_dims)) {
            if(dataset_create_pl$id == h5const$H5P_DEFAULT$id) {
                dataset_create_pl <- H5P_DATASET_CREATE$new()
            }
            else {
                dataset_create_pl <- dataset_create_pl$copy()
            }
            if(length(chunk_dims) == 1 && chunk_dims=="auto") {
                if(inherits(dtype, "H5T_STRING")) {
                    dtype_size <- dtype$get_size(variable_as_inf=FALSE)
                }
                else {
                    dtype_size <- dtype$get_size()
                }
                space_extent <- space$get_simple_extent_dims()
                chunk_dims <- guess_chunks(space_maxdims=space_extent$maxdims, dtype_size=dtype_size)
            }
            ## check that chunk_dims has the same rank as space
            if(!space$is_simple()) {
                stop("When chunking is enable, the space has to be simple")
            }
            space_rank <- space$get_simple_extent_ndims()
            if(space_rank != length(chunk_dims)) {
                stop(paste("The length of the chunk_dims is", length(chunk_dims), "and has to be the same as the rank of the space", space_rank))
            }
            dataset_create_pl$set_chunk(chunk_dims)
            if(!is.null(gzip_level)) {
                if(0 > gzip_level || gzip_level > 9) {
                    stop(paste("gzip_level has to be between 0 and 9, but is", gzip_level))
                }
                dataset_create_pl$set_deflate(gzip_level)
            }
        }

        check_class(dtype, "H5T")
        check_class(space, "H5S")
        check_pl(link_create_pl, "H5P_LINK_CREATE")
        check_pl(dataset_create_pl, "H5P_DATASET_CREATE")
        check_pl(dataset_access_pl, "H5P_DATASET_ACCESS")

        if(is.character(name) && length(name)==1) {
            id <- .Call("R_H5Dcreate2", self$id, name, dtype$id, space$id, link_create_pl$id, dataset_create_pl$id,
                        dataset_access_pl$id, PACKAGE="hdf5r")$return_val
        }
        else if(length(name)==0) {
            id <- .Call("R_H5Dcreate_anon", self$id, dtype$id, space$id,  dataset_create_pl$id,
                        dataset_access_pl$id, PACKAGE="hdf5r")$return_val
        }
        else {
            stop("This should not have happened! name has to be character or null")
        }
        if(id < 0) {
            stop("An error occured creating the dataset")
        }
        ds <- H5D$new(id)
        if(!is.null(robj)) {
            ## need to write the sample object data
            ds$write_low_level(robj)
        }
        return(invisible(ds))
    },
    commit=function(name, dtype, link_create_pl=h5const$H5P_DEFAULT, type_create_pl=h5const$H5P_DEFAULT,
        type_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Tcommit2."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

        if(missing(name)) {
            name <- character(0)
        }
        ## check that all parameters are of the expected type
        if(!is.character(name) && !is.null(name)) {
            stop("Name has to be a character vector or null")
        }
        if(length(name) > 1) {
            stop("name has to be of length at most 1")
        }

        check_pl(link_create_pl, "H5P_LINK_CREATE")
        check_pl(type_create_pl, "H5P_TYPE_CREATE")
        check_pl(type_access_pl, "H5P_TYPE_ACCESS")

        if(is.character(name) && length(name)==1) {
            herr <- .Call("R_H5Tcommit2", self$id, name, dtype$id, link_create_pl$id, type_create_pl$id,
                        type_access_pl$id, PACKAGE="hdf5r")$return_val
        }
        else if(length(name)==0) {
            herr <- .Call("R_H5Tcommit_anon", self$id, dtype$id, type_create_pl$id,
                        type_access_pl$id, PACKAGE="hdf5r")$return_val
        }
        else {
            stop("This should not have happened! name has to be character or null")
        }
        if(herr < 0) {
            stop("An error occured creating the dataset")
        }
        return(invisible(dtype))

    },
    ## functions around the link interface
    link_create_hard=function(obj_loc, obj_name, link_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lcreate_hard."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        if(!(inherits(obj_loc, "H5File") || inherits(obj_loc, "H5Group"))) {
            stop("src_loc has to be a file or group")
        }
        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lcreate_hard", obj_loc$id, obj_name, self$id, link_name, link_create_pl$id,
                      link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(herr < 0) {
            stop(paste("Error creating hard link for object", obj_name, "with link_name", link_name))
        }
        return(invisible(self))
    },
    link_create_soft=function(target_path, link_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lcreate_soft."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lcreate_soft", target_path, self$id, link_name, link_create_pl$id,
                      link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(herr < 0) {
            stop(paste("Error creating soft link for path", target_path, "with link_name", link_name))
        }
        return(invisible(self))

    },
    link_create_external=function(target_filename, target_obj_name, link_name, link_create_pl=h5const$H5P_DEFAULT,
        link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lcreate_external."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lcreate_external", target_filename, target_obj_name, self$id, link_name, link_create_pl$id,
                      link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(herr < 0) {
            stop(paste("Error creating external link for file", target_filename, "with target object", target_obj_name, " and link_name", link_name))
        }
        return(invisible(self))

    },
    link_exists=function(name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lexists."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        htri <- .Call("R_H5Lexists", self$id, name, link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(htri < 0) {
            stop(paste("Error verifying existence of link", name))
        }
        return(as.logical(htri))
    },
    link_move_from=function(src_loc, src_name, dst_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lmove."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        if(!(inherits(src_loc, "H5File") || inherits(src_loc, "H5Group"))) {
            stop("src_loc has to be a file or group")
        }
        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lmove", src_loc$id, src_name, self$id, dst_name, link_create_pl$id, link_access_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error copying object")
        }
        return(invisible(self))

    },
    link_move_to=function(dst_loc, dst_name, src_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lmove."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        if(!(inherits(dst_loc, "H5File") || inherits(dst_loc, "H5Group"))) {
            stop("src_loc has to be a file or group")
        }
        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lmove", self$id, src_name, dst_loc$id, dst_name, link_create_pl$id, link_access_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error copying object")
        }
        return(invisible(self))

    },
    link_copy_from=function(src_loc, src_name, dst_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lcopy."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        if(!(inherits(src_loc, "H5File") || inherits(src_loc, "H5Group"))) {
            stop("src_loc has to be a file or group")
        }
        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lcopy", src_loc$id, src_name, self$id, dst_name, link_create_pl$id, link_access_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error copying object")
        }
        return(invisible(self))

    },
    link_copy_to=function(dst_loc, dst_name, src_name, link_create_pl=h5const$H5P_DEFAULT, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lcopy."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        if(!(inherits(dst_loc, "H5File") || inherits(dst_loc, "H5Group"))) {
            stop("src_loc has to be a file or group")
        }
        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        check_pl(link_create_pl, "H5P_LINK_CREATE")

        herr <- .Call("R_H5Lcopy", self$id, src_name, dst_loc$id, dst_name, link_create_pl$id, link_access_pl$id, PACKAGE = "hdf5r")$return_val
        if(herr < 0) {
            stop("Error copying object")
        }
        return(invisible(self))

    },
    link_delete=function(name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Ldelete."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        herr <- .Call("R_H5Ldelete", self$id, name, link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(herr < 0) {
            stop(paste("Error deleting link", name))
        }
        return(invisible(self))

    },
    link_delete_by_idx=function(n, group_name=".", index_field=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE,
        link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Ldelete_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(group_name!="." && !self$exists(group_name)) {
            stop(paste(group_name, " does not exist"))
        }

        herr <- .Call("R_H5Ldelete_by_idx", self$id, group_name, index_field, order, n, link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(herr < 0) {
            stop(paste("Error deleting link number", n, "in group", group_name))
        }
        return(invisible(self))

    },
    link_info=function(name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lget_info."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        res <- .Call("R_H5Lget_info", self$id, name, request_empty(1), link_access_pl$id, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop(paste("Error getting info for link", name))
        }
        return(res$linfo)
    },
    link_info_by_idx=function(n, group_name=".", index_field=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE,
        link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lget_info_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(group_name!="." && !self$exists(group_name)) {
            stop(paste(group_name, " does not exist"))
        }

        res <- .Call("R_H5Lget_info_by_idx", self$id, group_name, index_field, order, n, request_empty(1),
                      link_access_pl$id, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop(paste("Error getting info for link number", n, "in group", group_name))
        }
        return(res$linfo)
    },
    link_value=function(name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lget_val."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        ## first check if it is a soft or external link, otherwise return NA
        linfo <- self$link_info(name=name, link_access_pl=link_access_pl)
        if(!(as.character(linfo$type) %in% c("H5L_TYPE_SOFT", "H5L_TYPE_EXTERNAL"))) {
            return(NA)
        }
        ## first get the link-value; then unpack if necessary
        buffer <- raw(linfo$u$address) ## isn't the haddr, is the size_val; as it is a union, has been dropped
        res <- .Call("R_H5Lget_val", self$id, name, buffer, linfo$u$address, link_access_pl$id, FALSE, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop(paste("Error retrieving link value of link", name))
        }
        if(as.character(linfo$type) == "H5L_TYPE_SOFT") {
            ## link is a character vector
            val <- rawToChar(res$buf)
            return(val)
        }
        else { ## external
            ## needs to be unpacked
            ## can do this here; just 2 null terminated strings; have it as raw, so just unpack it
            buffer <- res$buf
            string_ends <- which(buffer==0)
            if(length(string_ends) != 3) {
                stop("Expected 2 strings with a null at the beginning; received more")
            }
            file_name <- rawToChar(buffer[2:string_ends[2]])
            obj_name <- rawToChar(buffer[(string_ends[2] + 1):string_ends[3]])
            return(list(file_name=file_name, obj_name=obj_name))
        }
    },
    link_value_by_idx=function(n, group_name=".", index_field=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE,
        link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lget_val_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(group_name!="." && !self$exists(group_name)) {
            stop(paste(group_name, " does not exist"))
        }

        linfo <- self$link_info_by_idx(n=n, group_name=group_name, index_field=index_field, order=order, link_access_pl=link_access_pl)
        if(!(as.character(linfo$type) %in% c("H5L_TYPE_SOFT", "H5L_TYPE_EXTERNAL"))) {
            return(NA)
        }
        ## first get the link-value; then unpack if necessary
        buffer <- raw(linfo$u$address) ## isn't the haddr, is the size_val; as it is a union, has been dropped
        res <- .Call("R_H5Lget_val_by_idx", self$id, group_name, index_field, order, n, buffer, linfo$u$address,
                     link_access_pl$id, FALSE, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop(paste("Error retrieving link value of link", name))
        }
        if(as.character(linfo$type) == "H5L_TYPE_SOFT") {
            ## link is a character vector
            val <- rawToChar(res$buf)
            return(val)
        }
        else { ## external
            ## needs to be unpacked
            ## can do this here; just 2 null terminated strings; have it as raw, so just unpack it
            buffer <- res$buf
            string_ends <- which(buffer==0)
            if(length(string_ends) != 3) {
                stop("Expected 2 strings with a null at the beginning; received more")
            }
            file_name <- rawToChar(buffer[2:string_ends[2]])
            obj_name <- rawToChar(buffer[(string_ends[2] + 1):string_ends[3]])
            return(list(file_name=file_name, obj_name=obj_name))
        }

    },
    link_name_by_idx=function(n, group_name, idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Lget_name_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_l.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(group_name!="." && !self$exists(group_name)) {
            stop(paste(group_name, " does not exist"))
        }
        name_size <- .Call("R_H5Lget_name_by_idx", self$id, group_name, idx_type, order, n, character(0), 0,
                           link_access_pl$id, PACKAGE="hdf5r")$return_val
        char_buf <- paste(rep(" ", name_size+1), collapse="")
        res <- .Call("R_H5Lget_name_by_idx", self$id, group_name, idx_type, order, n, char_buf, name_size+1,
                     link_access_pl$id, PACKAGE="hdf5r")

        if(res$return_val < 0) {
            stop("Problem getting name of link by index")
        }
        return(res$name)

    },
    mount=function(name, child) {
        "This function implements the HDF5-API function H5Fmount."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."
        if(!is.character(name) || length(name) != 1) {
            stop("name has to be a character vector of length 1")
        }
        ## check that name actually exists
        if(!self$path_valid(name)) {
            stop(paste("path", name, "does not exist"))
        }
        check_class(child, "H5File")
        file_mount_pl <- h5const$H5P_DEFAULT
        res <- .Call("R_H5Fmount", self$id, name, child$id, file_mount_pl$id, PACKAGE="hdf5r")$return_val
        if(res <- 0) {
            stop("Error mounting file onto group")
        }
        return(self$open(name))
    },
    unmount=function(name) {
        "This function implements the HDF5-API function H5Funmount."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."
        if(!is.character(name) || length(name) != 1) {
            stop("name has to be a character vector of length 1")
        }
        ## check that name actually exists
        if(!self$path_valid(name)) {
            stop(paste("path", name, "does not exist"))
        }
        res <- .Call("R_H5Funmount", self$id, name, PACKAGE="hdf5r")$return_val
        if(res <- 0) {
            stop("Error mounting file onto group")
        }
        return(self)
    }
    )




commonFG_active <- list(
        names=function(link_access_pl=h5const$H5P_DEFAULT) {
        "Returns the names of the items in the group or at the root of the file"
        "@param link_access_pl The link-access property list. See \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___l_a_p_l.html} for more detail."
        ginfo <- self$group_info()
        nlinks <- ginfo$nlinks
        res <- character(nlinks)
        for(i in seq_len(nlinks)) {
            res[i] <- self$link_name_by_idx(i-1, ".", idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_INC,
                                         link_access_pl=link_access_pl)
        }
        return(res)
    }
)







commonFGDT <- list(
    obj_info=function(remove_internal_use_only=TRUE) {
        "This function implements the HDF5-API function H5Oget_info."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_o.html} for details."

        res <- .Call("R_H5Oget_info", self$id, request_empty(1), PACKAGE = "hdf5r")
        if(res$return_val < 0) {
            stop("Error getting object info")
        }
        if(remove_internal_use_only) {
            oinfo <- res$oinfo
            oinfo$meta_size <- NULL
            return(oinfo)
        }
        else {
            return(res$oinfo)
        }
    },
    get_obj_name=function() {
        "This function implements the HDF5-API function H5Iget_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."

        ## get size of the name
        name_size <- .Call("R_H5Iget_name", self$id, character(0), 0, PACKAGE="hdf5r")$return_val
        if(name_size < 0) {
            stop("Error returning name of object")
        }
        if(name_size == 0) {
            return(NA)
        }
        ## create a character vector of sufficient size (it will be copied in the internal C function as is available for writign
        char_buf=paste(rep(" ", name_size), collapse="")
        res <- .Call("R_H5Iget_name", self$id, char_buf, name_size + 1, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop("Error returning name of object")
        }
        return(res$name)
    },
    ## functions that work on attributes
    create_attr=function(attr_name, robj=NULL, dtype=NULL, space=NULL) {
        "This function implements the HDF5-API function H5Acreate2."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        if(self$attr_exists(attr_name)) {
            stop("Can't create attribute; already exists")
        }

        attr_create_pl <- h5const$H5P_DEFAULT
        attr_access_pl <- h5const$H5P_DEFAULT

        ## adapt dtype, space as necessary
        if(is.null(robj) && (is.null(dtype) || is.null(space))) {
            stop("If a sample robj is not provided, both dtype and space have to be given")
        }
        if(is.null(dtype)) {
            dtype <- guess_dtype(x=robj, scalar=FALSE, string_len=Inf)
        }
        if(is.null(space)) {
            space <- guess_space(x=robj, dtype=dtype, chunked=FALSE)
        }

        id <- .Call("R_H5Acreate2", self$id, attr_name, dtype$id, space$id,
                     attr_create_pl$id, attr_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem creating new attribute")
        }
        attr <- H5A$new(id=id)
        if(!is.null(robj)) {
            attr$write(robj)
        }
        return(attr)
    },
    attr_open=function(attr_name) {
        "This function implements the HDF5-API function H5Aopen."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        attr_access_pl=h5const$H5P_DEFAULT
        id <- .Call("R_H5Aopen", self$id, attr_name, attr_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem creating new attribute")
        }
        return(H5A$new(id=id))
    },
    create_attr_by_name=function(attr_name, obj_name, robj=NULL, dtype=NULL, space=NULL, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Acreate_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        attr_create_pl <- h5const$H5P_DEFAULT
        attr_access_pl <- h5const$H5P_DEFAULT

        if(is.null(robj) && (is.null(dtype) || is.null(space))) {
            stop("If a sample robj is not provided, both dtype and space have to be given")
        }
        if(is.null(dtype)) {
            dtype <- guess_dtype(x=robj, scalar=FALSE, string_len=Inf)
        }
        if(is.null(space)) {
            space <- guess_space(x=robj, dtype=dtype, chunked=FALSE)
        }

        id <- .Call("R_H5Acreate_by_name", self$id, obj_name, attr_name, dtype$id, space$id,
                     attr_create_pl$id, attr_access_pl$id, link_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem creating new attribute")
        }
        attr <- H5A$new(id=id)
        if(!is.null(robj)) {
            attr$write(robj)
        }
        return(attr)

    },
    attr_open_by_name=function(attr_name, obj_name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Aopen_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        attr_access_pl=h5const$H5P_DEFAULT
        id <- .Call("R_H5Aopen_by_name", self$id, obj_name, attr_name, attr_access_pl$id, link_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem creating new attribute")
        }
        return(H5A$new(id=id))
    },
    attr_open_by_idx=function(n, obj_name, idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Aopen_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        attr_access_pl=h5const$H5P_DEFAULT
        id <- .Call("R_H5Aopen_by_idx", self$id, obj_name, idx_type, order, n, attr_access_pl$id, link_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem creating new attribute")
        }
        return(H5A$new(id=id))

    },
    attr_exists_by_name=function(attr_name, obj_name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Aexists_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."
        check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        res <- .Call("R_H5Aexists_by_name", self$id, obj_name, attr_name, link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop(paste("Error trying to check existence of attribute", attr_name))
        }
        return(as.logical(res))
    },
    attr_exists=function(attr_name) {
        "This function implements the HDF5-API function H5Aexists."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        res <- .Call("R_H5Aexists", self$id, attr_name, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop(paste("Error trying to check existence of attribute", attr_name))
        }
        return(as.logical(res))
    },
   attr_rename_by_name=function(old_attr_name, new_attr_name, obj_name, link_access_pl=h5const$H5P_DEFAULT) {
       "This function implements the HDF5-API function H5Arename_by_name."
       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

       check_pl(link_access_pl, "H5P_LINK_ACCESS")

        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        if(!is.character(old_attr_name) || length(old_attr_name) != 1) {
            stop("'old_attr_name' has to be a character vector of length 1")
        }
        if(!is.character(new_attr_name) || length(new_attr_name) != 1) {
            stop("'new_attr_name' has to be a character vector of length 1")
        }
        res <- .Call("R_H5Arename_by_name", self$id, obj_name, old_attr_name, new_attr_name, link_access_pl$id, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop(paste("Error renaming attribute from", old_attr_name, "to", new_attr_name))
        }
        return(invisible(self))
    },
    attr_rename=function(old_attr_name, new_attr_name) {
        "This function implements the HDF5-API function H5Arename."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        if(!is.character(old_attr_name) || length(old_attr_name) != 1) {
            stop("'old_attr_name' has to be a character vector of length 1")
        }
        if(!is.character(new_attr_name) || length(new_attr_name) != 1) {
            stop("'new_attr_name' has to be a character vector of length 1")
        }
        res <- .Call("R_H5Arename", self$id, old_attr_name, new_attr_name, PACKAGE="hdf5r")$return_val
        if(res < 0) {
            stop(paste("Error renaming attribute from", old_attr_name, "to", new_attr_name))
        }
        return(invisible(self))
    },
    attr_delete=function(attr_name) {
        "This function implements the HDF5-API function H5Adelete."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        herr <- .Call("R_H5Adelete", self$id, attr_name, PACKAGE="hdf5r")$return_val
        if(herr < 0) {
            stop(paste("Error trying to delete attribute", attr_name))
        }
        return(invisible(self))
    },
    attr_delete_by_name=function(attr_name, obj_name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Adelete_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        id <- .Call("R_H5Adelete_by_name", self$id, obj_name, attr_name, link_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem deleting attribute by name")
        }
        return(invisible(self))
    },
    attr_delete_by_idx=function(n, obj_name, idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Adelete_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        id <- .Call("R_H5Adelete_by_idx", self$id, obj_name, idx_type, order, n, link_access_pl$id, PACKAGE="hdf5r")$return_val

        if(id < 0) {
            stop("Problem deleting attribute by index")
        }
        return(invisible(self))

    },
    attr_info_by_name=function(attr_name, obj_name, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Aget_info_by_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        if(!is.character(attr_name) || length(attr_name) != 1) {
            stop("'attr_name' has to be a character vector of length 1")
        }
        res <- .Call("R_H5Aget_info_by_name", self$id, obj_name, attr_name, request_empty(1), link_access_pl$id, PACKAGE="hdf5r")

        if(res$return_val < 0) {
            stop("Problem getting attribute info by name")
        }
        return(res$ainfo)
    },
    attr_info_by_idx=function(n, obj_name, idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Aget_info_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        res <- .Call("R_H5Aget_info_by_idx", self$id, obj_name, idx_type, order, n, request_empty(1), link_access_pl$id, PACKAGE="hdf5r")

        if(res$return_val < 0) {
            stop("Problem getting atribute info by index")
        }
        return(res$ainfo)
    },
    attr_name_by_idx=function(n, obj_name, idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_NATIVE, link_access_pl=h5const$H5P_DEFAULT) {
        "This function implements the HDF5-API function H5Aget_name_by_idx."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

        check_pl(link_access_pl, "H5P_LINK_ACCESS")
        if(!is.character(obj_name) || length(obj_name) != 1) {
            stop("'obj_name' has to be a character vector of length 1")
        }
        name_size <- .Call("R_H5Aget_name_by_idx", self$id, obj_name, idx_type, order, n, character(0), 0,
                           link_access_pl$id, PACKAGE="hdf5r")$return_val
        char_buf=paste(rep(" ", name_size+1), collapse="")
        res <- .Call("R_H5Aget_name_by_idx", self$id, obj_name, idx_type, order, n, char_buf, name_size+1,
                     link_access_pl$id, PACKAGE="hdf5r")

        if(res$return_val < 0) {
            stop("Problem getting attribute name by index")
        }
        return(res$name)
    },
    attr_get_number=function() {
        "This function implements the HDF5-API function H5Aget_num_attrs."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."
        res <- .Call("R_H5Aget_num_attrs", self$id, PACKAGE="hdf5r")
        return(res$return_val)
    }
)


## create reference for datasets is implemented separately to allower for better ease of use in creating
## H5R_DATASET_REGION references
commonFGT <- list(
    create_reference=function(name=".", space=NULL) {
        "This function implements the HDF5-API function H5Rcreate. If \\code{space=NULL} then a \\code{H5R_OBJECT} reference"
        "is created, otherwise a \\code{H5R_DATASET_REGION} reference"
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_r.html} for details."

        if(is.null(space)) {
            ref_type <- h5const$H5R_OBJECT
            space_id <- -1
            ref_obj <- H5R_OBJECT$new(1, self)
        }
        else {
            ref_type <- h5const$H5R_DATASET_REGION
            space_id <- space$id
            ref_obj <- H5R_DATASET_REGION$new(1, self)
        }

        res <- .Call("R_H5Rcreate", ref_obj$ref, self$id, name, ref_type, space_id, FALSE, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop("Error creating object reference")
        }
        ref_obj$ref <- res$ref
        return(ref_obj)
    }
)

commonFGDTA <- list(
    flush=function(scope=h5const$H5F_SCOPE_GLOBAL) {
        "This function implements the HDF5-API function H5Fflush."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."

        if(self$is_valid) {
            res <- .Call("R_H5Fflush", self$id, scope, PACKAGE="hdf5r")$return_val
            if(res < 0) {
                stop("Error flushing associated file")
            }
            return(invisible(self))
        }
        else {
            return(invisible(self))
        }
    },
    get_filename=function() {
        "This function implements the HDF5-API function H5Fget_name."
        "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."

        ## get size of the name
        name_size <- .Call("R_H5Fget_name", self$id, character(0), 0, PACKAGE="hdf5r")$return_val
        if(name_size < 0) {
            stop("Error returning name of object")
        }
        if(name_size == 0) {
            return(NA)
        }
        ## create a character vector of sufficient size (it will be copied in the internal C function as is available for writign
        char_buf=paste(rep(" ", name_size), collapse="")
        res <- .Call("R_H5Fget_name", self$id, char_buf, name_size + 1, PACKAGE="hdf5r")
        if(res$return_val < 0) {
            stop("Error returning name of object")
        }
        return(res$name)
    }
)



---
File: /R/Compound.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################






## implements a data type in R that stores (and manipulates) a raw HDF5 compound datatype
## this can be practical for the direct manipulation of tables
## as well as for creating the structs in c code (that we need as input for the API interface functions)

## for now we implement this as a simple S3 class that can then be passed into an out of the RToH5 and H5ToR
create_RCOMPOUND <- function(dtype, len) {
    if(!inherits(dtype, "H5T_COMPOUND")) {
        stop("The dtype has to be of class H5T_COMPOUND")
    }
    cpd_size <- dtype$get_size()
    x <- raw(cpd_size * len)
    class(x) <- "RCOMPOUND"
    attr(x, "dtype") <- dtype
}


## a function that converts a data frame to an RCOMPOUND
dataframe_to_RCOMPOUND <- function(dF, dtype) {
    if(!inherits(dtype, "H5T_COMPOUND")) {
        stop("The dtype has to be of class H5T_COMPOUND")
    }
    x <- RToH5(dF, dtype=dtype)
    class(x) <- "RCOMPOUND"
    attr(x, "dtype") <- dtype
}

## and from an RCOMPOUND back to R
RCOMPOUND_to_dataframe <- function(x) {
    if(!inherits(x, "RCOMPOUND")) {
        stop("x needs to be an RCOMPOUND object")
    }
    dtype <- attr(x, "dtype")
    retRobj <- H5ToR_Pre(dtype, nelem)
    dtype_size <- dtype$get_size()
    ## need to guess the number of elements -> length of the x vector / size of the compound
    nelem <- length(x) / dtype_size
    retRobj <- copyRVec(retRobj, x, nelem * dtype_size);
    retRobj <- H5ToR_Post(retRobj, dtype, nelem)
    return(retRobj)
}





---
File: /R/convert.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################






##' Low-level conversion functions from R to HDF5 and vice versa
##'
##' These are the low-level function that dispatch the R object to HDF5 object conversion to the underlying C code.
##' None of these should be accessed by the end-user under normal circumstances. See also \code{\link{convertRoundTrip}}
##' for an example of how to use them.
##' @title Low-level conversion functions from R to HDF5 and vice versa
##' @param Robj The R-object to transfer to HDF5
##' @param dtype Datatype of the HDF5 object. Of class \code{\link{H5T}}
##' @param nelem Number of elements to copy
##' @param flags Some flags governing edge cases of conversion from HDF5 to R. This is related to how integers are being treated and
##' the issue of R not being able to natively represent 64bit integers and not at all being able to represent unsigned 64bit integers
##' (even using add-on packages). The constants governing this are part of \code{\link{h5const}}. The relevant ones start with the term
##' \code{H5TOR} and are documented there. The default set here returns a regular 32bit integer if it doesn't lead to an overflow
##' and returns a 64bit integer from the \code{bit64} package otherwise. For 64bit unsigned int that are larger than 64bit signed int,
##' it is truncated (the default; but can also be set to NA).
##' @param id When creating a reference, an id for the file (or an object in the file) is needed. By default \code{-1}, which will work
##' with everything except references.
##' @return The converted object or the buffer into which the object is written. 
##' @author Holger Hoefling
##' @keywords internal
RToH5 <- function(Robj, dtype, nelem) {
    return(.Call("R_RToH5", Robj, dtype$id, nelem, PACKAGE="hdf5r"))
}

##' @rdname RToH5
H5ToR_Pre <- function(dtype, nelem) {
    return(.Call("R_H5ToR_Pre", dtype$id, nelem, PACKAGE="hdf5r"))
}

##' @rdname RToH5
H5ToR_Post <- function(Robj, dtype, nelem, flags=getOption("hdf5r.h5tor_default"), id=-1) {
    return(.Call("R_H5ToR_Post", Robj, dtype$id, nelem, flags, id, PACKAGE="hdf5r"))
}



##' Create an empty R-object according to a given HDF5 datatype
##'
##' With complex datatypes it can be useful to have a template that can be used so that the
##' data input into a dataset conforms to expectations.
##'
##' Given a datatype, this function creates an object of length \code{nelem}.
##' Here, an empty datatype refers to objects with value 0 for numeric objects and
##' empty strings.
##' @title Create an empty R-object according to a given HDF5 datatype
##' @param nelem The number of elements to use for the object
##' @param dtype The datatype based on which an empty R-object should be created
##' @return An empty R object corresponding to the datatype that was passed in
##' @author Holger Hoefling
##' @export
create_empty <- function(nelem, dtype) {
    flags <- h5const$H5TOR_CONV_INT64_NOLOSS ## in this case, does not matter

    ## create an r-object that represents a request to give HDF5-space of nelem elements
    Robj <- request_empty(nelem)
    h5val_raw <- RToH5(Robj, dtype, nelem)
    ## initialize to make sure
    
    retRobj <- H5ToR_Pre(dtype, nelem)
    dtype_size <- dtype$get_size()
    if(dtype_size==Inf) {
        dtype_size <- dtype$get_size(variable_as_inf=FALSE)
    }
    retRobj <- copyRVec(retRobj, h5val_raw, nelem * dtype_size);
    retRobj <- H5ToR_Post(retRobj, dtype, nelem, flags)
    return(retRobj)
}




copyRVec <- function(dst, src, nbytes) {
    return(.Call("copy_rvec", dst, src, as.integer(nbytes), PACKAGE="hdf5r"))
}


##' @rdname guess_dtype
##' @export
guess_nelem <- function(x, dtype) {
    return(.Call("R_guess_nelem", x, dtype$id, PACKAGE="hdf5r"))
}

##' @rdname guess_dtype
##' @export
guess_dim <- function(x) {
    if(inherits(x, "data.frame")) {
        return(nrow(x))
    }
    else if(!is.null(dim(x))) {
        return(dim(x))
    }
    else {
        return(length(x))
    }
}

##' Guess the HDF5 datatype of an R object
##'
##' Given an object, it creates a datatype in HDF5 that would match this object. For simple datasets like arrays, this
##' function is not so useful, but is very good for creating dataframes or hierarchical objects (like lists of dataframes) etc.
##' @title Guess the HDF5 datatype of an R object
##' @param x The object for which to guess the HDF5 datatype or the dimension or the number of elements
##' @param dtype datatype; used in guessing the number of dataset elements of an r object
##' @param ds_dim Can explicitly set the dimension of the dataset object. For \code{scalar}, this is one. Otherwise, this can be
##' used so that a multi-dimensional object can be represented so that some of its dimension are in the dataset, and some are inside an
##' \code{\link{H5T_ARRAY}}
##' @param scalar Should the datatype be created so that \code{x} can be represented as a scalar with that datatype? This is intended
##' to know if a vector/array should be represented as an \code{\link{H5T_ARRAY}} or not.
##' @param string_len If a string is in the R object, the length to which the corresponding HDF5 type should be set. If it is a
##' positive integer, the string is of that length. If it is \code{Inf}, it is variable length. If it is set to \code{estimate},
##' it is set to the length of the longest string in the \code{x}.
##' @return An object of class \code{\link{H5T}} that represents the HDF5-type of the Robj that was passed in
##' @author Holger Hoefling
##' @importFrom bit64 is.integer64
##' @export
guess_dtype <- function(x, ds_dim=NULL, scalar=FALSE, string_len=getOption("hdf5r.default_string_len")) {
    ## check for the different classes
    ## if could be:
    ## a data frame
    ## an regular array
    ## a ragged array (VLEN)
    ## a string
    ## an enumeration
    ## a complex number
    ## integer
    ## float
    ## reference data type
    
    guessed_dim <- guess_dim(x)

    if(is.null(ds_dim)) {
        if(scalar) {
            ds_dim <- 1
        }
        else {
            ds_dim <- guessed_dim
        }
    }
    
    ## first check if we need an array; for this look if the number of elements is the same
    ## as the number of elements in the Robj
    if(length(ds_dim) != length(guessed_dim) || any(ds_dim != guessed_dim)) {
        ## it could be an array, or it might simply not match
        if(ds_dim==1) { ## simply create an array
            dtype_base <- guess_dtype(x, ds_dim=guessed_dim, scalar=FALSE, string_len=string_len)
            array_type <- H5T_ARRAY$new(dims=guessed_dim, dtype_base=dtype_base)
            return(array_type)
        }
        else { ## check that the outer dimensions match
             ## equal also captured here; with equal size, all items  would have to be the same, but aren't
            ## as seen by previous if query
            if(length(ds_dim) >= length(guessed_dim)) {
                stop(paste("Dimensions don't match. Should be", str_dim(ds_dim), "but is", str_dim(guessed_dim)))
            }
            if(any(ds_dim != guessed_dim[seq_along(ds_dim)])) {
                stop(paste("Dimensions don't match. Should be", str_dim(ds_dim), "but is", str_dim(guessed_dim)))
            }
            rest_dim <- guessed_dim[-seq_along(ds_dim)]
            dtype_base <- guess_dtype(x, ds_dim=guessed_dim, scalar=FALSE, string_len=string_len)
            array_type <- H5T_ARRAY$new(dims=rest_dim, dtype_base=dtype_base)
            return(array_type)
        }
    }
    else { ## just find the appropriate data type
        if(inherits(x, "data.frame")) {
            dtypes <- lapply(x, guess_dtype, ds_dim=ds_dim, scalar=FALSE, string_len=string_len)
            dtype <- H5T_COMPOUND$new(labels=names(x), dtypes=dtypes)
            return(dtype)
        }
        else if(inherits(x, "list")) {
            ## if each item is of the same class, this could be a ragged array
            dtype_ids <- vector("list", length=length(x))
            item_dim <- vector("list", length=length(x))
            for(i in seq_along(x)) {
                dtype_ids[[i]] <- guess_dtype(x[[i]], ds_dim=length(x[[i]]), scalar=FALSE, string_len=string_len)
                item_dim[[i]] <- guess_dim(x[[i]])
            }
            ## now check that they are all the same
            if(length(x) == 0) {
                stop("Empty list; can't guess datatype")
            }
            type_equal <- TRUE
            length_equal <- TRUE
            if(length(x) > 1) {
                for(i in 2:length(x)) {
                    if(!(dtype_ids[[1]]$equal(dtype_ids[[i]]))) {
                        type_equal <- FALSE
                    }
                    if(any(item_dim[[1]] != item_dim[[i]])) {
                        length_equal <- FALSE
                    }
                }
            }

            if(!type_equal & !length_equal) {
                stop("Found a list where neither the length nor the types are the same. Cannot match h5-datatype.")
            }
            if(!type_equal & length_equal) {
                ## if some of these are not identical - can make a compound object out of it
                ## if all lengths are the same, a regular compound object;
                ## for all intents and purposed, this is a data.frame
                attr(x, "class") <- "data.frame"
                attr(x, "row.names") <- 1:item_dim[[1]][1]
                return(guess_dtype(x, ds_dim=item_dim[[1]][1], scalar=scalar, string_len=string_len))
            }
            if(type_equal) {
                ## note; if the length are equal, we could handle it as a regular array; but for now we will do a
                ## variable length array
                dtype_base <- dtype_ids[[1]]
                return(H5T_VLEN$new(dtype_base=dtype_base))
            }
            
        }
        else if(inherits(x, "factor_ext")) {
            return(H5T_ENUM$new(labels=levels(x), values=values(x)))
        }
        else if(is.factor(x)) {
            return(H5T_ENUM$new(labels=levels(x)))
        }
        else if(is.character(x)) {
            if(string_len=="estimate") {
                string_len <- max(nchar(x)) + 1
            }
            return(H5T_STRING$new(type="c", size=string_len))
        }
        else if(is.logical(x)) {
            return(H5T_LOGICAL$new(include_NA=TRUE))
        }
        else if(is.integer64(x)) {
            return(h5types$H5T_NATIVE_LLONG)
        }
        else if(is.integer(x)) {
            return(h5types$H5T_NATIVE_INT)
        }
        else if(is.double(x)) {
            return(h5types$H5T_NATIVE_DOUBLE)
        }
        else if(is.complex(x)) {
            return(H5T_COMPLEX$new())
        }
        else if(inherits(x, "H5R")) {
            if(inherits(x, "H5R_OBJECT")) {
                return(h5types$H5T_STD_REF_OBJ)
            }
            else if(inherits(x, "H5R_DATASET_REGION")) {
                return(h5types$H5T_STD_REF_DSETREG)
            }
            else {
                stop("Unknown reference type")
            }
        }
        else {
            stop("unknown type")
        }
    }
    stop("the function should never have reached this place")
}


##' Guess the dataspace of an object
##'
##' Creates a dataspace that fits an R object so that it can be written into a dataset. This is used
##' for example in dataset creation based on an R-object, not a specifically defined dimensions.
##' @title Guess the dataspace of an object
##' @param x The R object for which to guess the space
##' @param dtype Object of type \code{\link{H5T}}, that represents that datatype to use.
##' @param chunked Is the datatype chunked? If yes, \code{maxdims} of the space will be set to infinity,
##' otherwise \code{maxdims} will be set to the original extent of the space.
##' @return An object of type \code{\link{H5S}}
##' @author Holger Hoefling
##' @export
guess_space <- function(x, dtype, chunked=TRUE) {
    ## if a datatype is given and it is an array, take out that part of the dimension guess
    x_dim <- guess_dim(x)

    dtype_dim <- NULL
    if(inherits(dtype, "H5T")) {
        if(dtype$get_class() == h5const$H5T_ARRAY) {
            dtype_dim <- dtype$get_array_dims()
        }
    }

    ## check if the dtype_dimensions fit the guessed dimensions
    space_dim <- x_dim
    dtype_rank <- length(dtype_dim)
    x_rank <- length(x_dim)
    if(dtype_rank > 0) {
        if(x_rank < dtype_rank) {
            stop("rank of x is smaller than rank of dtype_dim; types don't fit")
        }
        else if(x_rank == dtype_rank) {
            if(any(x_dim != dtype_dim)) {
                stop("dimensions of x and dtype are different")
            }
            else {
                space_dim <- 1
            }
        }
        else {
            space_dim <- x_dim[1:(x_rank-dtype_rank)]
        }
    }
  
    ## now create the appropriate space
    if(chunked) {
        maxdims=rep(Inf, length(space_dim))
    }
    else {
        maxdims <- space_dim
    }
    return(H5S$new(type="simple", dims=space_dim, maxdims=maxdims))
}

##' Guess the dimension of a chunk
##'
##' The size of the chunk in bytes is first divided by the size of the datatype, giving the number of elements
##' to be stored in each chunk. This is taken as a rough guideline. Then, the number of dimensions of the dataset is used.
##' By default, the chunk is assumed to have the same size in each dimension, yielding an initial guess.
##'
##' If the resulting chunk is larger than the entire dataset for a maximal dimension, this dimension of the chunk is reduced and
##' redistributed to the other dimensions.
##'
##' As a chunk is never allowed to be larger than the maximum dimension of the dataset itself, 
##' @title Guess the dimension of a chunk
##' @param space_maxdims Maximal dimensions of the dataset
##' @param dtype_size Size of the datatype that is stored
##' @param chunk_size Size of each chunk in bytes
##' @return An integer vector giving the dimension of the chunk
##' @author Holger Hoefling
##' @export
guess_chunks <- function(space_maxdims, dtype_size, chunk_size=getOption("hdf5r.chunk_size")) {
    chunk_num_elem <- floor(chunk_size / dtype_size)

    ## now, given the dimension of the space, decide on the dimension of the chunks
    ## each dimension is, if possible identical in chunk size
    ## if the total dimension is too small, they are redistributed to other dimensions
    ## if the whole space is too small, the first dimension is being increased
    space_rank <- length(space_maxdims)
    chunk_dim <- rep(ceiling(chunk_num_elem^(1/space_rank)), space_rank)

    chunk_dim <- pmin(space_maxdims, chunk_dim)
    bounded <- chunk_dim == space_maxdims
    while(prod(chunk_dim) < chunk_num_elem & !all(bounded)) {
        mult_factor <- (chunk_num_elem / prod(chunk_dim))^(1/ sum(!bounded))
        chunk_dim[!bounded] <- ceiling(chunk_dim[!bounded] * mult_factor)
        chunk_dim <- pmin(space_maxdims, chunk_dim)
        bounded <- chunk_dim == space_maxdims
    }

    return(chunk_dim)
}

##' Get the correct dimensions for a space and datatype
##'
##' This function uses the space and the selection in it to get the correct dimension
##' for the resulting object (but without dropping dimensions). Furthermore, if the
##' datatype is an array, those dimensions are correctly determined as well.
##'
##' Internal use only; currently unused
##' @title Extract the dimension of a space and datatype
##' @param space The space with the selection that was used to read the dataset
##' @param dtype The datatype of the dataset
##' @return \code{x}, but with a new dimension attribute
##' @author Holger Hoefling
##' @keywords internal
extract_dim <- function(space, dtype) {
    dtype_dim <- NULL
    if(inherits(dtype, "H5T")) {
        if(dtype$get_class() == h5const$H5T_ARRAY) {
            dtype_dim <- dtype$get_array_dims()
        }
    }

    ## check if the dtype_dimensions fit the guessed dimensions
    if(!space$is_simple()) {
        space_dim <- NULL
    }
    else {
        ## now we need to check what the dimension of the dataspace-selection is
        space_sel_type <- space$get_select_type()
        if(space_sel_type == h5const$H5S_SEL_HYPERSLABS) {
            nblocks <- space$get_select_hyper_nblocks()
            if(nblocks == 1) {
                blocklist <- space$get_select_hyper_blocklist()
                space_dim <- blocklist[2,] - blocklist[1,] + 1
            }
            else {## cannot infer easily the size of each dimension
                space_dim <- space$get_select_npoints()
            }
        }
        else if(space_sel_type == h5const$H5S_SEL_POINTS) {
            space_dim <- space$get_select_npoints()
        }
        else if(space_sel_type == h5const$H5S_SEL_ALL) {
            space_dim <- space$get_simple_extent_dims()$dims
        }
        else if(space_sel_type == h5const$H5S_SEL_NONE) {
            return(NULL)
        }
        else {
            stop("Unknown selection in space")
        }
    }

    all_dim <- as.integer(c(space_dim, dtype_dim))

    return(all_dim)
}


##' Reorder an array
##'
##' Reorders an array using a fast underlying c-function. It is implemented
##' for its simple generality and only intended for internal use in the package.
##' @title Reorder an array
##' @param x The array; doesn't have to have a dim attribute; is just assumed to be a vector
##' @param dims The dimensionality of the array
##' @param reorder_dim The dimension to reorder
##' @param new_order The new ordering of the reorder_dim; not checked for correctness; 1-based
##' @param item_size The size in bytes of each array item; not discovered automatically
##' @return The re-ordered array
##' @author Holger Hoefling
##' @keywords internal
array_reorder <- function(x, dims, reorder_dim, new_order, item_size) {
    pre_reorder_dims <- dims[seq_len(reorder_dim -1)]
    post_reorder_dims <- dims[reorder_dim + seq_len(length(dims) - reorder_dim)]

    ## item size is the number of items in the dimensions before the re-order times the size of each item
    item_size <- prod(pre_reorder_dims) * item_size
    num_rows <- dims[reorder_dim]
    num_cols <- prod(post_reorder_dims)

    return(.Call("R_reorder", x, num_rows, num_cols, item_size, new_order - 1, PACKAGE="hdf5r"))
}



##' Round-trip of converting data to HDF5 and back to R
##'
##' Take an R-object, convert it to HDF5, convert it back and return input, output and intermediate steps
##' This is mainly intended for use in tests.
##' @title Round-trip of converting data to HDF5 and back to R
##' @param Robj The object to convert
##' @param dtype The datatype to convert it into
##' @param nelem The number of elements in the object
##' @param flags conversion flags from HDF5 to R
##' @return A list with input, number of elements, raw vector for intermediate storage and output
##' @author Holger Hoefling
##' @keywords internal
convertRoundTrip <- function(Robj, dtype, nelem=length(Robj), flags=h5const$H5TOR_CONV_INT64_NOLOSS) {
    if(missing(nelem)) {
        if(!is.data.frame(Robj)) {
            nelem <- length(Robj)
        }
        else {
            nelem <- nrow(Robj)
        }
    }
    h5val_raw <- RToH5(Robj, dtype, nelem)
    retRobj <- H5ToR_Pre(dtype, nelem)
    dtype_size <- dtype$get_size()
    if(dtype_size==Inf) {
        dtype_size <- dtype$get_size(variable_as_inf=FALSE)
    }
    retRobj <- copyRVec(retRobj, h5val_raw, nelem * dtype_size);
    retRobj <- H5ToR_Post(retRobj, dtype, nelem, flags)
    return(list(input=Robj, nelem=nelem, h5val_raw=h5val_raw, output=retRobj))
}



---
File: /R/factor_ext.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################







setOldClass("factor_ext")


INT_MIN <- as.integer64(-2^31)
INT_MAX <- as.integer64(2^31 - 1)


##' Create an extended factor
##'
##' An extended version of a regular \code{factor} variable. Instead of the levels having values from
##' 1 to n where n is the number of levels, any integer value can be used for any level (including 64bit integers). If
##' all values are in the range of a regular 32-bit integer, it is coerced to int. Automatic coercion of extended factors
##' to factors in \code{\link{H5ToR_Post}} for enums only works for 32-bit integer base types.
##' In this page this is heavily used, as constants in HDF5 can be arbitrary integer values.
##' @title Create an extended factor
##' @param x The object to convert to an \code{factor_ext}
##' @param values The values used for the levels; This is were \code{factor_ext} is different from a
##' \code{factor}, as values for levels do not have to be consecutive or start at 1.
##' @param levels The levels of the object; character string
##' @param drop Should non-occurring levels be dropped
##' @return An object of S3 class \code{factor_ext}
##' @author Holger Hoefling
##' @importFrom methods setOldClass
##' @export
factor_ext <- function(x, values, levels, drop=FALSE) {
    if(inherits(x, "factor_ext") && missing(values)) {
        values <- attr(x, "values")
    }
    if(inherits(x, "factor_ext") && missing(levels)) {
        levels <- attr(x, "levels")
    }
    if(is.numeric(x) && missing(values)) {
        values <- sort(unique(x))
    }
    
    ## treat values first
    if(is.integer(values)) {
        values <- as.integer(values)
    }
    else if(is.numeric(values) && !is.integer64(values)) {
        if(any(as.numeric(as.integer64(values)) != values)) {
            stop("x needs to be integer valued")
        }
        values <- as.integer64(values)
    }

    if(is.integer64(values)) {
        ## check if it can be forced into an integer
        if(all(values >= INT_MIN & values <= INT_MAX)) {
            values <- as.integer(values)
        }
    }
    
    if(is.numeric(x)) {
        if(missing(levels)) {
            stop("For x numeric, levels have to be set")
        }
        if(missing(values)) {
            ## already taken care of above; not relevant anymore
        }
        if(length(values) != length(levels)) {
            stop("values and levels have to have the same length")
        }
        if(drop) {
            incl <- values %in% x
            values <- unname(values[incl])
            levels <- levels[incl]
        }
        ## coerce x to the same type as values
        if(is.integer64(values)) {
            x <- as.integer64(x)
        }
        else {
            x <- as.integer(x)
        }
        
        x[!(x %in% values)] <- NA
    }
    else if(is.character(x)) {
        if(missing(values)) {
            stop("For x character, values have to be set")
        }
        if(missing(levels)) {
            levels <- sort(unique(x))
        }
        if(length(values) != length(levels)) {
            stop("values and levels have to have the same length")
        }
        if(drop) {
            incl <- levels %in% x
            values <- unname(values[incl])
            levels <- levels[incl]
        }
        x[!(x %in% levels)] <- NA
        x <- values[match(x, levels)]        
    }
    else {
        stop("x has to be numeric or character")
    }

    ## now sort the levels by increasing values
    val_order <- order(values, decreasing=FALSE)
    levels <- levels[val_order]
    values <- values[val_order]

    if(is.integer64(x)) {
        class(x) <- c("factor_ext", "integer64")
    }
    else {
        class(x) <- "factor_ext"
    }
    levels(x) <- levels
    attr(x, "values") <- values
    return(x)
}

## need to overload the same functions that are also available for factors
## also, is.factor and a conversion function as.factor (which should be really simple)




##' Various functions for \code{factor_ext} objects
##'
##' \describe{
##'   \item{values}{Extracts the underlying values of an object (the generic here)}
##'   \item{values.factor_ext}{Extracts the underlying values of a \code{factor_ext} object}
##'   \item{values.factor}{Extracts the underlying values of a \code{factor}}
##'   \item{values.default}{Default of the values function; currently returns an error}
##'   \item{as.character}{Coerces \code{factor_ext} to a character-representation using it levels, not values}
##'   \item{[[.factor_ext}{Single-item subsetting of a \code{factor_ext} object}
##'   \item{[[<-.factor_ext}{Single-item subset assignment to a \code{factor_ext} object}
##'   \item{[.factor_ext}{Subsetting of a \code{factor_ext} object}
##'   \item{[<-.factor_ext}{Subset assignment to a \code{factor_ext} object}
##'   \item{is.factor_ext}{Check if it is a \code{factor_ext} object. Returns a logical}
##'   \item{coercible_to_factor}{Checks if a \code{factor_ext} could be coerced to a \code{factor}. Return a logical.}
##'   \item{coerce_to_factor}{Coerces to a \code{factor}, otherwise throws an error if not possible.}
##'   \item{print.factor_ext}{Prints a \code{factor_ext} object.}
##'   \item{==.factor_ext}{Compare two \code{factor_ext} for equality.}
##'   \item{!=.factor_ext}{Compare two \code{factor_ext} for inequality.}
##'   \item{c.factor_ext}{Concatenate objects of type \code{factor_ext}.}
##' }
##' @title Various functions for \code{factor_ext} objects
##' @param x Object of type \code{factor_ext}
##' @param quote logical, indicating whether or not strings should be printed with surrounding quotes.
##' @param max.levels integer, indicating how many levels should be printed. if '0', no extra "Levels" line will be printed.  The
##' default, 'NULL', entails choosing 'max.levels' such that the levels print on one line of width 'width' (same for values).
##' @param width only used when \code{max.levels} is NULL (see above)
##' @param e1,e2 The two objects in the equality or inequality comparison.
##' @param ... Currently ignored
##' @param drop Should dimensions of size 1 be dropped?
##' @param value The object to assign; here has be a level of \code{factor_ext}
##' @return Depending on the function
##' @author Holger Hoefling
##' @name factor_ext_functions
NULL


##' @export
##' @rdname factor_ext_functions 
values <- function(x, ...) {
    UseMethod("values")
}

##' @export
##' @rdname factor_ext_functions 
values.factor_ext <- function(x, ...) {
    attr(x, "values")
}

##' @export
##' @rdname factor_ext_functions 
values.factor <- function(x, ...) {
    as.numeric(x)
}

##' @export
##' @rdname factor_ext_functions 
values.default <- function(x, ...) {
    stop("Currently not implemented")
}

## internal helper function
position <- function(x) {
    .match <- function(x, y) match(unclass(x), unclass(y))
    if(is.integer64(values(x)) && is.integer(x)) {
        .match(as.integer64(unclass(x)), as.integer64(values(x)))
    }
    else if(is.integer(values(x)) && is.integer64(x)) {
        .match(x, as.integer64(values(x)))
    }
    else {
        .match(x, values(x))
    }
}

##' @export
##' @rdname factor_ext_functions 
as.character.factor_ext <- function (x, ...) {
    levels(x)[position(x)]
}

##' @export
##' @rdname factor_ext_functions 
"[[.factor_ext" <- function (x, ...) {
    y <- NextMethod("[[")
    attr(y, "contrasts") <- attr(x, "contrasts")
    attr(y, "levels") <- attr(x, "levels")
    attr(y, "values") <- attr(x, "values")
    class(y) <- oldClass(x)
    y
}

##' @export
##' @rdname factor_ext_functions 
"[[<-.factor_ext" <- function(x, ..., value) {    
    lx <- levels(x)
    vx <- values(x)
    cx <- oldClass(x)
    if (is.factor_ext(value)) 
        value <- levels(value)[position(value)]
    m <- vx[match(value, lx)]
    if (any(is.na(m) & !is.na(value))) 
        warning("invalid factor_ext level, NA generated")
    class(x) <- NULL
    x[[...]] <- m
    attr(x, "levels") <- lx
    attr(x, "values") <- vx
    class(x) <- cx
    x
}


##' @export
##' @rdname factor_ext_functions 
"[.factor_ext" <- function (x, ..., drop = FALSE) 
{
    y <- NextMethod("[")
    attr(y, "contrasts") <- attr(x, "contrasts")
    attr(y, "levels") <- attr(x, "levels")
    attr(y, "values") <- attr(x, "values")
    class(y) <- oldClass(x)
    if (drop) 
        factor(y, exclude = if (anyNA(levels(x))) 
            NULL
        else NA)
    else y
}

##' @export
##' @rdname factor_ext_functions 
"[<-.factor_ext" <- function(x, ..., value) {
    lx <- levels(x)
    vx <- values(x)
    cx <- oldClass(x)
    if (is.factor_ext(value)) 
        value <- levels(value)[position(value)]
    m <- vx[match(value, lx)]
    if (any(is.na(m) & !is.na(value))) 
        warning("invalid factor_ext level, NA generated")
    class(x) <- NULL
    x[...] <- m
    attr(x, "levels") <- lx
    attr(x, "values") <- vx
    class(x) <- cx
    x
}

##' @export
##' @rdname factor_ext_functions 
is.factor_ext <- function(x) {
    return(inherits(x, "factor_ext"))
}

##' @export
##' @rdname factor_ext_functions 
coercible_to_factor <- function(x) {
    if(!inherits(x, "factor_ext")) {
        stop("Only for objects of factor_ext classes")
    }
    vx <- values(x)
    if(all(vx == seq_along(vx))) {
        return(TRUE)
    }
    else {
        return(FALSE)
    }
}

##' @export
##' @rdname factor_ext_functions 
coerce_to_factor <- function(x) {
    if(!inherits(x, "factor_ext")) {
        stop("Only for objects of factor_ext classes")
    }
    if(coercible_to_factor(x)) {
        y <- factor(as.character(x), levels=levels(x))
        return(y)
    }
    else {
        stop("Cannot coerce to factor; values not a sequence starting at 1")
    }
}


##' @export
##' @rdname factor_ext_functions 
print.factor_ext <- function (x, quote = FALSE, max.levels = NULL, width = getOption("width"), ...) {
    if (length(x) == 0L) 
        cat("factor_ext", "(0)\n", sep = "")
    else {
        xx <- x
        class(xx) <- NULL
        levels(xx) <- NULL
        attr(xx, "values") <- NULL
        xx[] <- as.character(x)
        print(xx, quote = quote, ...)
    }
    maxl <- if (is.null(max.levels)) 
        TRUE
    else max.levels
    if (maxl) {
        n <- length(lev <- encodeString(levels(x), quote = ifelse(quote, 
            "\"", "")))
        colsep <- " "
        T0 <- "Levels: "
        if (is.logical(maxl)) 
            maxl <- {
                width <- width - (nchar(T0, "w") + 3L + 1L + 
                  3L)
                lenl <- cumsum(nchar(lev, "w") + nchar(colsep, 
                  "w"))
                if (n <= 1L || lenl[n] <= width) 
                  n
                else max(1L, which.max(lenl > width) - 1L)
            }
        drop <- n > maxl
        cat(if (drop) 
            paste(format(n), ""), T0, paste(if (drop) 
            c(lev[1L:max(1, maxl - 1)], "...", if (maxl > 1) lev[n])
        else lev, collapse = colsep), "\n", sep = "")
    }
    if (maxl) {
        n <- length(val <- encodeString(values(x), quote = ifelse(quote, 
                                                       "\"", "")))
        colsep <- " "
        T0 <- "Values: "
        if (is.logical(maxl)) 
            maxl <- {
                width <- width - (nchar(T0, "w") + 3L + 1L + 
                  3L)
                lenl <- cumsum(nchar(val, "w") + nchar(colsep, 
                  "w"))
                if (n <= 1L || lenl[n] <= width) 
                  n
                else max(1L, which.max(lenl > width) - 1L)
            }
        drop <- n > maxl
        cat(if (drop) 
            paste(format(n), ""), T0, paste(if (drop) 
            c(val[1L:max(1, maxl - 1)], "...", if (maxl > 1) val[n])
        else val, collapse = colsep), "\n", sep = "")
    }
    invisible(x)
}

##' @export
##' @rdname factor_ext_functions 
"==.factor_ext" <- function(e1, e2){
    if(inherits(e2, "factor_ext")) {
        e1 <- as.character(e1)
        e2 <- as.character(e2)
        return(e1==e2)
    }
    if(is.character(e2)) {
        e1 <- as.character(e1)
        return(e1 == e2)
    }
    else {
        class(e1) <- NULL
        return(e1 == e2)
    }
}

##' @export
##' @rdname factor_ext_functions 
"!=.factor_ext" <- function(e1, e2){
    if(inherits(e2, "factor_ext")) {
        e1 <- as.character(e1)
        e2 <- as.character(e2)
        return(e1!=e2)
    }
    if(is.character(e2)) {
        e1 <- as.character(e1)
        return(e1 != e2)
    }
    else {
        class(e1) <- NULL
        return(e1 != e2)
    }
}


##' @export
##' @rdname factor_ext_functions 
c.factor_ext <- function(...) {
    l <- list(...)
    ## check that the values and the levels for all of them the same and the class is all the same
    inherits_factor_ext <- unique(unlist(lapply(l, inherits, what="factor_ext")))
    if(all(inherits_factor_ext)) {
        item1_levels <- levels(l[[1]])
        item1_values <- values(l[[1]])
        all_levels <- unique(unlist(lapply(l, levels)))
        all_values <- unique(unlist(lapply(l, values)))
        if(length(item1_levels)==length(all_levels) && length(item1_values)==length(all_values)) {
            y <- do.call("c", lapply(l, as.integer))
            class(y) <- "factor_ext"
            attr(y, "levels") <- item1_levels
            attr(y, "values") <- item1_values
            return(y)
        }
        else {
            stop("Not all factor_ext the same levels")
        }
    }
    else {
        stop("Can only concatenate with factor_ext object if all are of the same class")        
    }
}



---
File: /R/globalVariables.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





## This is a hack to ensure that the warnings about non-visible bindings don't show up anymore
globalVariables("Category")
globalVariables("Name")
globalVariables("self")



---
File: /R/H5constants.R
---




#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' These are all types that are used in HDF5
##'
##' HDF5 provides many native datatypes. These are all stored in the \code{h5types}
##' environment. An overview of all available types can be seen using \code{h5types$overview}.
##' Any specific type can be accessed using the \code{$}-operator. See also the examples below.
##'
##' @author Holger Hoefling
##' @export
##' @name h5types
##' @examples
##' h5types$overview
##' h5types$H5T_NATIVE_INT
##' h5types$H5T_NATIVE_DOUBLE
NULL




##' All constants used in HDF5
##' 
##' These are all constants used in HDF5. They are stored in an environment with locked bindings so that
##' they cannot be changed. An overview of all constants can be seen with \code{h5const$overview}, listing all of them.
##' Each constant can be accessed using \code{$} and the name of the constant. See the examples below.
##'
##' There are also some flags that govern edge cases of conversion from HDF5 to R. This is related to how integers are being treated and
##' the issue of R not being able to natively represent 64bit integers and not at all being able to represent unsigned 64bit integers
##' (even using add-on packages).
##' The constants all start with the term \code{H5TOR}. There are currently possible values
##' \describe{
##'   \item{H5TOR_CONV_NONE}{Doesn't do any conversion. Every integer datatype with more than 32 bit is returned as 64bit integers. For
##'   unsigned 64bit integers, the conversion to signed 64bit integers is done by truncation}
##'   \item{H5TOR_CONV_INT64_INT_NOLOSS}{Under this setting, whenever a 64 bit integer would be returned, it is checked if it would also
##'   fit into a 32 bit integer without data loss and returned as such if possible}
##'   \item{H5TOR_CONV_INT64_FLOAT_NOLOSS}{Under this setting, whenever a 64 bit integer would be returned, it is checked if it would also
##'   fit into a 64 bit floating point value without data loss and returned as such if possible}
##'   \item{H5TOR_CONV_INT64_NOLOSS}{Combines \code{H5TOR_CONV_INT64_INT_NOLOSS} and \code{H5TOR_CONV_INT64_FLOAT_NOLOSS} and is set
##'   as the default in the \code{hdf5r.h5tor_default} option.}
##'   \item{H5TOR_CONV_INT64_FLOAT_FORCE}{Under this setting, whenever a 64 bit integer would be returned, it is coerced to a double
##'   even if this results in a loss of precision. If a loss of precision occurs, a warning is issued. Please note that this also overrides
##'   the use of \code{H5TOR_CONV_UNIT64_NA}. As loss of precision is already accepted, UINT64-values that are larger than LLONG_MAX will be represented
##'   as their next possible floating point value.}
##'   \item{H5TOR_CONV_UINT64_NA}{When converting an unsigned 64bit integer, any values that don't fit into a signed 64bit integer are
##'   set to NA. If this flag is not set, then the values will be truncated to \code{LLONG_MAX}, the largest 64bit signed integer.}
##'   \item{H5TOR_CONV_DEFAULT}{Is both \code{H5TOR_CONV_INT64_INT} and \code{H5TOR_CONV_UNIT64_FLOAT}}
##' }
##' 
##' @author Holger Hoefling
##' @export
##' @name h5const
##' @examples
##' h5const$overview
##' h5const$H5F_ACC_RDWR
##' h5const$H5F_ACC_DEFAULT
##' # Combining flags
##' bitwOr(h5const$H5TOR_CONV_UINT64_NA, h5const$H5TOR_CONV_INT64_INT_NOLOSS)
NULL

h5types <- new.env()
h5const <- new.env()




##' Retrieving a copy of a type
##'
##' The types are stored in the environment \code{\link{h5types}}. These types should not be accessed
##' directly. Therefor, the \code{$}-operator is overloaded to ensure that every type that is accessed is a copy of the
##' original type
##' @title Retrieving a copy of a type
##' @param x The environment to request it from
##' @param name The name of the type that is requested
##' @return Returns an object that is a copy of a type that was requested
##' @author Holger Hoefling
##' @export
##' @rdname types_env_access
"$.types_env" <- function(x, name) {
    a <- get(name, envir=x)
    if(inherits(a, "H5T")) {
        return(a$copy())
    }
    else {
        return(a)
    }
}


##' @rdname types_env_access
##' @export
"[[.types_env" <- function(x, name) {
    a <- get(name, envir=x)
    if(inherits(a, "H5T")) {
        return(a$copy())
    }
    else {
        return(a)
    }
}

install_types_const <- function(h5types, h5const) {
    all_types_frame <- .Call("show_all_types_data_frame", PACKAGE="hdf5r")
    all_const_frame <- .Call("show_all_const_data_frame", PACKAGE="hdf5r") 

    ## exclude H5F_ACC_DEBUG; listed as 0; not supported for end-users
    all_const_frame <- all_const_frame[all_const_frame$Name != "H5F_ACC_DEBUG",]
    
    ## of all the datatypes, get all individual values
    all_types_unique <- unique(all_types_frame$Type_id)
    names(all_types_unique) <- as.character(all_types_unique)

    all_types_unique_list <- H5T_factory(all_types_unique, do_copy=TRUE)
    
    ## now assign the types
    for(i in seq_len(nrow(all_types_frame))) {
        h5types[[all_types_frame$Name[i]]] <- all_types_unique_list[[as.character(all_types_frame$Type_id[i])]]
        lockBinding(all_types_frame$Name[i], h5types)
    }
   
    class(h5types) <- c("types_env", "environment")

    ## want to add an H5T_LOGICAL and H5T_LOGICAL_NA
    ## need to do it after class is assigned, otherwise copy doesn't work
    dtype_logical <- H5T_LOGICAL$new(include_NA=FALSE)
    dtype_logical_na <- H5T_LOGICAL$new(include_NA=TRUE)
    h5types[["H5T_LOGICAL"]] <- dtype_logical
    lockBinding("H5T_LOGICAL", h5types)
    h5types[["H5T_LOGICAL_NA"]] <- dtype_logical_na
    lockBinding("H5T_LOGICAL_NA", h5types)
    
    
    ## and assign the overview table
    all_types_frame <- rbind(all_types_frame, data.frame(Category=c("Custom", "Custom"), Name=c("H5T_LOGICAL", "H5T_LOGICAL_NA"),
                                                         Type_id=as.integer64(c(dtype_logical$id, dtype_logical_na$id))))
    h5types$overview <- all_types_frame
    lockBinding("overview", h5types)
    lockEnvironment(h5types)

    ## now extract constants from the enums
    all_enums <- subset(all_types_frame, Category=="enum")
    all_enum_const_list <- vector("list", length=nrow(all_enums))
    for(i in seq_len(nrow(all_enums))) {
        enum_df <- extract_enum_const(h5types[[all_enums$Name[i]]], all_enums$Name[i])
        enum_df$Constant <- as.integer64(enum_df$Constant)
        all_enum_const_list[[i]] <- enum_df
    }
    all_enum_const <- do.call("rbind", all_enum_const_list)

    all_const_frame <- rbind(all_const_frame, all_enum_const)
    
    ## split it by category into lists;
    ## add the overview, the lists and the individual numbers
    h5const$overview <- all_const_frame
    lockBinding("overview", h5const)

    ## take H5P_DEFAULT out and treat it separately;
    ## will not be a constant, but a special H5P object
    h5p_default_val <- all_const_frame$Constant[all_const_frame$Name=="H5P_DEFAULT"]
    all_const_frame <- subset(all_const_frame, Name!="H5P_DEFAULT")
    h5const$H5P_DEFAULT <- H5P_DEFAULT$new(id=h5p_default_val)
    lockBinding("H5P_DEFAULT", h5const)

    ## same for H5S_ALL, make it into a H5S object
    h5s_all_val <- all_const_frame$Constant[all_const_frame$Name=="H5S_ALL"]
    all_const_frame <- subset(all_const_frame, Name!="H5S_ALL")
    h5const$H5S_ALL <- H5S_ALL$new(id=h5s_all_val)
    lockBinding("H5S_ALL", h5const)
        
    ## each constant category as a named vector
    all_const_frame_split <- split(all_const_frame, all_const_frame$Category)
    for(i in seq_along(all_const_frame_split)) {
        labels <- all_const_frame_split[[i]]$Name
        values <- all_const_frame_split[[i]]$Constant
        h5const[[unique(all_const_frame_split[[i]]$Category)]] <- factor_ext(values, values=values, levels=labels)
        lockBinding(unique(all_const_frame_split[[i]]$Category), h5const)

        ## now make the constants into extended factors
        for(j in seq_len(nrow(all_const_frame_split[[i]]))) {
            item <- all_const_frame_split[[i]]$Constant[j]
            name <- all_const_frame_split[[i]]$Name[j]
            h5const[[name]] <- factor_ext(item, values=values, levels=labels)
            lockBinding(name, h5const)
        }
    }

    # if we use HDF5 version 1.12 or higher, we have
    # H5R_OBJECT1 and H5R_OBJECT2, not H5R_OBJECT
    # H5R_DATASET_REGION1 and H5R_DATASET_REGION2, not H5R_DATASET_REGION
    if(compareVersion(h5version(verbose=FALSE), "1.12.0") >= 0) {
        h5const[["H5R_OBJECT"]] <- h5const$H5R_OBJECT1
        lockBinding("H5R_OBJECT", h5const)
        h5const[["H5R_DATASET_REGION"]] <- h5const$H5R_DATASET_REGION1
        lockBinding("H5R_DATASET_REGION", h5const)
    }
    ## and each constant individually
    lockEnvironment(h5const)
    
    return(invisible(NULL))
}

extract_enum_const <- function(h5type, name) {
    return(data.frame(Category=name, Name=h5type$get_labels(), Constant=h5type$get_values(), stringsAsFactors=FALSE))
}




---
File: /R/h5errorHandling.R
---




---
File: /R/h5wrapper.R
---

#' Wrapper functions to provide an \pkg{h5} compatible interface.
#' 
#' The functions listed below provide a wrapper-interface compatible to 
#' functions specified in the \pkg{h5} package. The author(s)
#' have decided to deprecate \pkg{h5} and join forces and still 
#' make the transition for \pkg{h5} users as smooth as possible.
#' Additionally, almost all testcases could be transferred to \pkg{hdf5r} 
#' to improve test coverage even more.
#' 
#' Below you can find a list of all \strong{h5} functions including \strong{hdf5r} \emph{mappings}.
#' \describe{
#'   \item{h5file}{Directly maps to \code{H5File$new}, see also \code{\link{H5File}}.}
#'   \item{createGroup}{Maps to \code{object$create_group} where object implements \emph{CommonFG}.}
#'   \item{openLocation}{Uses \code{object$open} where object implements \emph{CommonFG}.}
#'   \item{createDataSet}{Maps to \code{object$create_dataset} where object implements \emph{CommonFG}.}
#'   \item{readDataSet}{Maps to \code{object$read}, see also \code{\link{H5D}}.}
#'   \item{h5close}{Maps to \code{object$close_all} for \code{\link{H5File}} and \code{object$close} 
#'     for other.}
#'   \item{h5flush}{Maps to \code{object$flush} where object implements \emph{CommonFGDTA}.}
#' }
#' 
#' The following \strong{interfaces} are defined:
#' \describe{
#'   \item{CommonFG}{Implemented by objects of class 
#'     \code{\link{H5File}} and 
#'     \code{\link{H5Group}}.}
#'   \item{CommonFGDTA}{Implemented by objects of class
#'     \code{\link{H5File}}, 
#'     \code{\link{H5Group}}, 
#'     \code{\link{H5D}}, 
#'     \code{\link{H5T}} and
#'     \code{\link{H5A}}.}
#' }
#' 
#' @references Mario Annau (2017). \emph{\pkg{h5}: Interface to the 'HDF5' Library}. R package version 0.9.9.
#' \url{https://github.com/mannau/h5}
#' @name h5-wrapper
#' @aliases h5
NULL

#' @rdname h5-wrapper
#' @export
h5file <- H5File$new

#' @rdname h5-wrapper
#' @param object \code{CommonFG}; Object implementing the CommonFG Interface (e.g. \code{\link{H5File}}, \code{\link{H5Group}}).
#' @param name Name of the group to create.
#' @param ... Additional parameters passed to \code{create_group} or \code{h5file}.
#' @export
createGroup <- function(object, name, ...) {
  paths <- strsplit(name, "/")[[1]]
  paths <- paths[paths != ""]
  currentpath <- ""
  currentgroup <- NULL
  for(p in paths) {
    currentpath <- paste(currentpath, p, sep = "/")
    currentpath <- gsub("^\\/", "", currentpath)
    if (! object$exists(currentpath) ) {
      currentgroup <- object$create_group(currentpath, ...)
    }
  }
  currentgroup
}

#' @rdname h5-wrapper
#' @export
openLocation <- function(object, name) object$open(name=name)

#' @rdname h5-wrapper
#' @export
openGroup <- openLocation

#' @rdname h5-wrapper
#' @export
createDataSet <- function(object, name, ...) object$create_dataset(name, ...)

#' @rdname h5-wrapper
#' @export
readDataSet <- function(object) object$read()

#' @rdname h5-wrapper
#' @export
h5close <- function(object) {
    if(inherits(object, "H5File")) {
        object$close_all()
    }
    else {
        object$close()
    }
}

#' @rdname h5-wrapper
#' @export
h5flush <- function(object) object$flush()

#' @rdname h5-wrapper
#' @export
existsGroup <- function(object, name) {
  out <- tryCatch({
    object$exists(name)
  }, error = function(e) FALSE)
  out
}

#' @rdname h5-wrapper
#' @export
is.h5file <-
function(name) {
  res <- FALSE
  if(file.exists(name)) {
    res <- as.logical(.Call('R_H5Fis_hdf5', PACKAGE = 'hdf5r', name))
  } else {
    warning("File does not exist.")
  }
  res
}

#' List Groups and Datasets in object
#' 
#' List all Group (\code{\link{H5Group}}) and Dataset (\code{\link{H5D}}) 
#' names in the current object. This function is part of the \strong{h5} wrapper classes and
#' uses \code{$ls()} to retrieve group names.
#' 
#' @param object \code{CommonFG}; Object implementing the CommonFG Interface (e.g. \code{\link{H5File}}, \code{\link{H5Group}}).
#' @param path character; Path named to be used for iteration.
#' @param full.names character; Specify if absolute DataSet path names should be returned.
#' @param obj_type character; Object type to be returned.
#' @param recursive logical; Specify if object should be traversed recursively.
#' @param ... Additional Parameters passed to \code{$ls()}
#' @return \code{\link{character}}
#' @name list-groups-datasets
NULL

#' @rdname list-groups-datasets
#' @export
list.groups <- function(object, path = "/", full.names = FALSE, recursive = TRUE, ...) {
  list.objects(object, "H5I_GROUP", path, full.names, recursive, ...)
}

#' @rdname list-groups-datasets
#' @export
list.datasets <- function(object, path = "/", full.names = FALSE, recursive = TRUE, ...) {
  list.objects(object, "H5I_DATASET", path, full.names, recursive, ...)
}

#' @rdname list-groups-datasets
#' @export
list.objects <- function(object, obj_type = c("H5I_GROUP", "H5I_DATASET", "H5I_DATATYPE"), 
  path = "/", full.names = FALSE, recursive = TRUE, ...) {
  
  obj_type = match.arg(obj_type, several.ok = TRUE)
  if (path != "/") object <- object[[path]]
  df <- object$ls(... , recursive = recursive)
  onames <- df[as.character(df$obj_type) %in% obj_type, "name"]
  if (full.names) {
    onames <- sprintf("%s/%s", object$get_obj_name(), onames)
    onames <- gsub("^/+", "/", onames)
  }
  onames
}

GetDimensions <- function(data) {
  datadim <- NULL
  if(is.vector(data)) {
    datadim <- length(data)
  } else if (is.matrix(data)) {
    datadim <- dim(data)
  } else if (is.array(data)) {
    datadim <- dim(data)
  } else {
    stop("Argument data must be of type vector, matrix or array.")
  }
  datadim
}

#' @rdname h5-wrapper
#' @param dims numeric; Dimension vector to which dataset should be extended.
#' @export
extendDataSet <- function(object, dims) {
  ddset <- object$dims
  #dobj <- GetDimensions(object)
  if (length(dims) != length(ddset)) {
    stop("Number of extendible dimensions must agree with DataSet dimensions.")
  }
  if(!all(dims >= ddset)) {
    stop("Number of extendible dimensions must be greater or equal than DataSet dimensions.")
  }

  if(!all(dims <= object$maxdims)) {
    stop("Number of extendible dimensions exceeds maximum dimensions of DataSet.")
  }

  object$set_extent(dims = dims)
  invisible(object)
}

#' @rdname h5-wrapper
#' @param x An object of class H5D; the dataset to add rows or columns to; Needs to be a matrix
#' @param mat The matrix to add to x
#' @param deparse.level Set to 1; ignored otherwise; only present as required by generic
#' @export
rbind.H5D <- function(x, mat, ..., deparse.level=1) {
  xdims <- x$dims
  if(length(xdims) != 2) {
      stop("x needs to be a matrix (2-dimensionsal)")
  }
  startx <- xdims[1] + 1
  endx <- xdims[1] + nrow(mat)

  if(xdims[2] != ncol(mat)) {
    stop(sprintf("Data to append does not match dataset dimensions (%d != %d).",
                 xdims[2], ncol(mat)))
  }

  x[startx:endx, 1:xdims[2]] <- mat
  invisible(x)
}

#' @rdname h5-wrapper
#' @export
cbind.H5D <- function(x, mat, ..., deparse.level=1) {
  xdims <- x$dims
  if(length(xdims) != 2) {
      stop("x needs to be a matrix (2-dimensionsal)")
  }
  starty <- xdims[2] + 1
  endy <- xdims[2] + ncol(mat)

  if(xdims[1] != nrow(mat)) {
    stop(sprintf("Data to append does not match dataset dimensions (%d != %d).",
                 xdims[1], nrow(mat)))
  }

  x[1:xdims[1], starty:endy] <- mat
  invisible(x)
}

#' @rdname h5-wrapper
#' @export
c.H5D <- function(x, ...) {
  vec <- do.call(c, list(...))
  start <- x$dims + 1
  end <- x$dims + length(vec)

  if(length(x$dims) != length(GetDimensions(vec))) {
    stop(sprintf("Data to append does not match dataset dimensions (%d != %d).",
                 length(x$dims), length(GetDimensions(vec))))
  }
  x[start:end] <- vec
  invisible(x)
}

#' @rdname h5-wrapper
#' @export
h5unlink <- function(object, name) {
  out <- sapply(name, function(n) {
    tryCatch({
      object$link_delete(n)
      TRUE
      }, error = function(e) FALSE)
  })
  invisible(out)
}

#' @rdname h5-wrapper
#' @export
list.attributes <- function(object) {
  h5attr_names(object)
}



---
File: /R/hdf5r.R
---




#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' @useDynLib hdf5r, .registration = TRUE
NULL



##' hdf5r: A package to provide an interface to hdf5 from R
##'
##' 
##' A package that allows to interface with the HDF5 C-library. Provides access to most of its
##' functionality from inside R using R6 classes. For more details please see the README at
##' the github page \url{https://github.com/hhoeflin/hdf5r}.
##' 
##' @name hdf5r-package
##' @docType package
##' @examples 
##' test_file <- tempfile(fileext=".h5")
##' file.h5 <- H5File$new(test_file, mode="w")
##' 
##' data(cars)
##' file.h5$create_group("test")
##' file.h5[["test/cars"]] <- cars
##' cars_ds <- file.h5[["test/cars"]]
##' h5attr(cars_ds, "rownames") <- rownames(cars)
##' 
##' # Close the file at the end
##' # the 'close' method closes only the file-id, but leaves object inside the file open
##' # This may prevent re-opening of the file. 'close_all' closes the file and all objects in it
##' file.h5$close_all()
##' # now re-open it 
##' file.h5 <- H5File$new(test_file, mode="r+")
##' 
##' # lets look at the content
##' file.h5$ls(recursive=TRUE)
##' 
##' cars_ds <- file.h5[["test/cars"]]
##' # note that for now tables in HDF5 are 1-dimensional, not 2-dimensional
##' mycars <- cars_ds[]
##' h5attr_names(cars_ds)
##' h5attr(cars_ds, "rownames")
##' 
##' file.h5$close_all()
NULL






---
File: /R/Helper_functions.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################






## Helper function that installs a list of functions in a class
R6_set_list_of_items <- function(r6class, type, item_list, overwrite=FALSE) {
    if(is.null(names(item_list))) {
        stop("The item_list has to be named!")
    }
    for(i in seq_along(item_list)) {
        r6class$set(which=type, name=names(item_list)[i], value=item_list[[i]], overwrite=overwrite)
    }
    return(invisible(NULL))
}


check_pl <- function(x, class) {
    xlab <- deparse(substitute(x))
    if(!inherits(x, "H5P_DEFAULT") && !inherits(x, class)) {
        stop(paste0(xlab, " has to be 'H5P_DEFAULT' or of class '", class, "'"))
    }
    return(invisible(NULL))
}

check_class <- function(x, class) {
    xlab <- deparse(substitute(x))
    if(!inherits(x, class)) {
        stop(paste0(xlab, " has to be of class '", class, "'"))
    }
    return(invisible(NULL))
}

request_empty <- function(len) {
    x <- raw(len)
    class(x) <- "R_RToH5_empty"
    return(x)
}

str_dim <- function(x) {
    if(length(x) == 0) {
        return("")
    }
    return(paste("(", paste(x, collapse=", "), ")", sep=""))
}



##' Flatten a nested data.frame
##'
##' HDF5 Compounds allow for nesting. Correspondingly, nested data.frames are being produced.
##' This function flattens such a nested data.frame.
##'
##' For easier printing to the screen, it also allows for coercion of \code{\link{factor_ext}} to
##' character variables.
##' @title Flatten a nested data.frame
##' @param df The data.frame to flatten
##' @param factor_ext_to_char Should extended factor variables be converted to characters (mainly for easy printing)
##' @return A flattened \code{\link{data.frame}}
##' @author Holger Hoefling
##' @export
flatten_df <- function(df, factor_ext_to_char=FALSE) {
    out_df <- NULL
    for(i in seq_len(length(df))) {
        if(inherits(df[[i]], "data.frame")) {
            flattened_df <- flatten_df(df[[i]], factor_ext_to_char = factor_ext_to_char)
            names(flattened_df) <- paste(names(df)[i], names(flattened_df), sep=".")
            to_bind <- flattened_df
        }
        else if(factor_ext_to_char && inherits(df[[i]], "factor_ext")) {
            df[[i]] <- as.character(df[[i]])
            to_bind <- df[i]
        }
        else {
            to_bind <- df[i]
        }
        if(is.null(out_df)) {
            out_df <- to_bind
        }
        else {
            out_df <- cbind(out_df, to_bind)
        }
    }
    rownames(out_df) <- rownames(df)
    class(out_df) <- class(df)
    return(out_df)
}


##' Cleaning result of internal \code{_H5ls} function
##'
##' For every \code{*_success} item that is \code{FALSE}, the corresponding row of the data.frame will be set to NA.
##' @title Cleaning result of internal \code{R_H5ls} function
##' @param df The result of the C-function \code{R_H5ls}
##' @return A data frame with content that was not successfully gathered set to \code{NA} and \code{*_success} columns removed
##' @author Holger Hoefling
##' @keywords internal
clean_ls_df <- function(df) {
    if(is.null(df) || nrow(df) == 0) {
        return(df)
    }
    df <- within(df, {
        ## make them into logical for now, will drop them at the end
        link_success <- as.logical(link_success)
        obj_type_success <- as.logical(obj_type_success)
        group_success <- as.logical(group_success)
        dataset_success <- as.logical(dataset_success)
        type_success <- as.logical(type_success)
    })
    df <- within(df, {
        link[!link_success,] <- NA
        obj_type[!obj_type_success] <- NA
        num_attrs[!obj_type_success] <- NA
        group[!group_success,] <- NA
        dataset[!dataset_success,] <- NA
        committed_type[!type_success] <- NA
    })
    df$link_success <- NULL
    df$obj_type_success <- NULL
    df$group_success <- NULL
    df$dataset_success <- NULL
    df$type_success <- NULL
    class(df) <- c("data.frame_ext", class(df))
    return(df)
    
}


##' Print a data frame that includes extended factor objects
##'
##' The regular print function for data-frames has special methods built-in for factors so that
##' the label is printed instead of the constant. This function is intended to provide the same functionality
##' for data frames with extended factors, by adding the class \code{data.frame_ext} to the class vector.
##' @title Print a data frame with extended factor objects
##' @param x The \code{data.frame_ext} object to print; Is returned by ls from \code{\link{H5File}}
##' and \code{\link{H5Group}} and this function allows for petter printing of \code{\link{factor_ext}}
##' so that the label instead of the value is printed.
##' @param ... Parameters to be passed on directly to \code{\link{print.data.frame}}
##' @return The object to print itself, invisibly
##' @author Holger Hoefling
##' @export
print.data.frame_ext <- function(x, ...) {
    df_flat <- flatten_df(x, factor_ext_to_char = TRUE)
    print.data.frame(df_flat, ...)
    return(invisible(x))
}


##' Cycle through n-dimensional array indices
##'
##' Cycles through all indices of an n-dimensional array. The first dimension
##' moves fastest. The counter is 0-based and the output is 0-based as well.
##' @title Cycle through n-dimensional array indices
##' @param count The counter (0-based)
##' @param dims The sizes of the dimension
##' @return An integer vector of the same length as \code{dim}, with 0-based indices 
##' @author Holger Hoefling
##' @keywords internal
array_counter <- function(count, dims) {
    dims_prod_for_div <- c(1, cumprod(dims)[1:(length(dims) - 1)])

    return((count %/% dims_prod_for_div) %% dims)
    
}



##' Print the class and ID
##'
##' Used by the print-methods
##' @title Print the class and ID
##' @param obj The object for which to print the class and id
##' @param is_valid is the object valid
##' @return invisible NULL
##' @author Holger Hoefling
##' @keywords internal
print_class_id <- function(obj, is_valid) {
    myclass <- class(obj)[1]
    cat("Class: ", myclass, "\n", sep="")
    if(!is_valid) {
        cat("ID: Object invalid\n")
    }
    else {
        if(getOption("hdf5r.print_id")) {
            id_as_hex <- as_hex(obj$id)
            cat("ID: ", id_as_hex, "\n", sep="")
        }
    }
    return(invisible(NULL))
}

##' Print attributes
##'
##' Prints the names of the attributes up to a given maximum number
##' @title Print attributes
##' @param obj The obj for which to print the attributes
##' @param max_to_print Maximum number of attributes to print
##' @return Invisible NULL
##' @author Holger Hoefling
##' @keywords internal
print_attributes <- function(obj, max_to_print) {
    obj_attr_names <- h5attr_names(obj)
    if(length(obj_attr_names) > 0) {
        if(length(obj_attr_names) <= max_to_print) {
            cat("Attributes: ", paste(obj_attr_names, collapse=", "), "\n", sep="")
        }
        else {
            cat("Attributes: ", paste(obj_attr_names[seq_len(max_to_print)], collapse=", "),
                " ... < truncated at ", max_to_print, " out of ", length(obj_attr_names), ">\n", sep="")
        }
    }
    return(invisible(NULL))
}

##' Print listing
##'
##' Prints a smaller part of the \code{ls} output of an object, up to a maximum number
##' @title Print listing 
##' @param obj Object for which to print the listing
##' @param max_to_print Maximum number of listing items to print
##' @return Invisible NULL
##' @author Holger Hoefling
##' @keywords internal
print_listing <- function(obj, max_to_print) {
    listing <- obj$ls(recursive=FALSE, detailed=FALSE)
    listing <- listing[, c("name", "obj_type", "dataset.dims", "dataset.type_class")]
    if(nrow(listing) > 0) {
        cat("Listing:\n")
        if(nrow(listing) <= max_to_print) {
            print(listing, row.names=FALSE)
        }
        else {
            print(listing[seq_len(max_to_print),], row.names=FALSE)
            cat("< Printed ", max_to_print, ", out of ", nrow(listing), ">\n", sep="")
        }
    }
    return(invisible(NULL))
}



---
File: /R/high_level_UI.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################










###################################################
## UI for operating on groups and files
###################################################

##' Get the names of the items in the group or at the \code{/} root of the file
##'
##' Works similar to the regular \code{names} function for a list. The names of the items of either a
##' \code{\link{H5File}} at the root or a \code{\link{H5Group}} are returned as a character vector.
##' The items are then accessed, again similar to a list, using \code{[[}.
##' @title Get the names of the items in the group or at the \code{/} root of the file
##' @param x An object of class \code{\link{H5File}} or \code{\link{H5Group}}
##' @return A character vector with the names of the items in the group/file.
##' @author Holger Hoefling
##' @export
names.H5Group <- function(x) {
    link_access_pl <- h5const$H5P_DEFAULT
    ginfo <- x$group_info()
    nlinks <- ginfo$nlinks
    res <- character(nlinks)
    for(i in seq_len(nlinks)) {
        res[i] <- x$link_name_by_idx(i-1, ".", idx_type=h5const$H5_INDEX_NAME, order=h5const$H5_ITER_INC,
                                     link_access_pl=link_access_pl)
    }
    return(res)
}

##' @rdname names.H5Group
##' @export
names.H5File <- names.H5Group

##' Retrieve object from a group of file
##'
##' Works similar to retrieving objects in a list. \code{x[["my_name"]]} retrieves object \code{my_name} from the
##' HDF5-File or HDF5-Group \code{x}.
##'
##' One can also assign objects under a not yet existing name. For either a  \code{\link{H5Group}} or \code{\link{H5D}},
##' a hard link is created. If it is a datatype, \code{\link{H5T}}, this is committed under the chosen name \code{name}.
##' @title Retrieve object from a group of file
##' @param x An object of class \code{\link{H5File}} or \code{\link{H5Group}}
##' @param name Name of the object to retrieve. Has to be a character vector of length one. No integer values allowed.
##' @param ... Currently ignored
##' @param link_access_pl An object of class \code{\link{H5P_LINK_ACCESS}}.
##' @param dataset_access_pl An object of class \code{\link{H5P_DATASET_ACCESS}}.
##' @param type_access_pl Currently always \code{h5const$H5P_DEFAULT}
##' @param value What to assign. Has to be one of \code{\link{H5Group}},  \code{\link{H5D}} or  \code{\link{H5T}}
##' @return A \code{\link{H5Group}},  \code{\link{H5D}} or  \code{\link{H5T}}, depending on the object saved in the group under
##' the requested name.
##' @author Holger Hoefling
##' @rdname H5Group_access
##' @name H5Group_access
##' @export
'[[.H5Group' <- function(x, name, ..., link_access_pl=h5const$H5P_DEFAULT, dataset_access_pl=h5const$H5P_DEFAULT, type_access_pl=h5const$H5P_DEFAULT) {
    if(x$exists(name)) {
        return(x$open(name=name, link_access_pl=link_access_pl, dataset_access_pl=dataset_access_pl, type_access_pl=type_access_pl))
    }
    else {
        stop(paste("An object with name", name, "does not exist in this group"))
    }
}

##' @rdname H5Group_access
##' @export
'[[.H5File' <- get("[[.H5Group")


##' @rdname H5Group_access
##' @export
'[[<-.H5Group' <- function(x, name, ..., value) {
    ## if a group is given, make a link
    ## if a dataset is given, make a link
    ## if another r-obj is given, create a dataset for that object and write it
    ## if the object already exists, just fail
    if(x$exists(name)) {
        ## it is a peculiarity of the way R works that when assigning attributes,
        ## as it is done by value, the resulting object is written over itself (with the attribute attached)
        ## so here, we need to check if the object being assigned is itself
        if(inherits(value, "H5File") || inherits(value, "H5Group") || inherits(value, "H5D") || inherits(value, "H5T")) {
            value_oinfo <- value$obj_info()
            x_oinfo <- x[[name]]$obj_info()
            if(identical(value_oinfo, x_oinfo)) {
                return(invisible(x))
            }
        }

        stop("Cannot assign - already exists. Please use the 'link_delete' to delete the object before assigning a new one")
    }
    if(inherits(value, "H5Group")) {
        x$link_create_hard(value, ".", name)
    }
    else if(inherits(value, "H5D")) {
        x$link(value, name)
    }
    else if(inherits(value, "H5T")) {
        x$commit(name, value)
    }
    else {
        x$create_dataset(name, value)
    }
    return(invisible(x))
}

##' @rdname H5Group_access
##' @export
'[[<-.H5File' <- get("[[<-.H5Group")

###################################################
## UI for working with arguments
###################################################

##' Interface for HDF5 attributes
##'
##' Implements high-level functions that allows interactions with HDF5-attributes in a way very similar to regular R-object attributes
##' in R are handled.
##' @title Interface for HDF5 attributes
##' @param x The object to which to attach the attribute to or retrieve it from. Can be one of \code{\link{H5Group}},  \code{\link{H5D}},
##' \code{\link{H5T}} or  \code{\link{H5File}}
##' @param which The name of the attribute to assign it to
##' @param value The value to assign to the attribute.
##' @return For \code{h5attributes}, a named list with the content of the attributes read out. For \code{h5attr_names},
##' a vector of names of the attributes attached to the object \code{x}. For \code{h5attr}, the content of the attribute and
##' for \code{h5attr<-}, the assignment, the original object to which the attributes are attached (so that chaining is possible).
##' @author Holger Hoefling
##' @export
h5attributes <- function(x) {
    ## return a list with the names and content of all attributes
    ## first get number of attributes; used deprecated attr_get_number;
    ## reason is that H5Oget_info can be slow on large datasets (but should be ok on files)
    if(inherits(x, "H5File")) {
        num_attrs <- x$obj_info()$num_attrs
    }
    else {
        num_attrs <- x$attr_get_number()
    }
    attr_data <- vector("list", length=num_attrs)
    names(attr_data) <- h5attr_names(x)

    for(i in seq_along(attr_data)) {
        attr_obj <- x$attr_open_by_idx(i - 1, ".")
        attr_data[[i]] <- attr_obj$read()
    }
    return(attr_data)
}

##' @rdname h5attributes
##' @export
h5attr_names <- function(x) {
    ## get the number of attributes
    ## first get number of attributes; used deprecated attr_get_number;
    ## reason is that H5Oget_info can be slow on large datasets (but should be ok on files)
    if(inherits(x, "H5File")) {
        num_attrs <- x$obj_info()$num_attrs
    }
    else {
        num_attrs <- x$attr_get_number()
    }
    attr_names <- character(num_attrs)
    for(i in seq_along(attr_names)) {
        attr_names[i] <- x$attr_name_by_idx(i - 1, ".")
    }
    return(attr_names)
}

##' @rdname h5attributes
##' @export
h5attr <- function(x, which) {
    if(!x$attr_exists_by_name(which, ".")) {
        stop("Attribute does not exist")
    }
    attr_obj <- x$attr_open_by_name(which, ".")
    return(attr_obj$read())
}

##' @rdname h5attributes
##' @export
'h5attr<-' <- function(x, which, value) {
    if(x$attr_exists_by_name(which, ".")) {
        ## if it already exists, delete it first
        ## to make sure that unused object get closed
        gc()
        x$attr_delete_by_name(which, ".")
    }
    attr_obj <- x$create_attr(which, robj=value)
    return(invisible(x))
}


###################################################
## UI for working with datasets
###################################################

##' Selecting and assigning subsets of HDF5-Spaces and HDF5-Datasets
##'
##' Used for subsetting HDF5-Datasets or HDF5-Spaces or for assigning data into HDF5-Datasets. There are some differences to
##' consider with R itself.
##'
##' Most importantly HDF5-COMPOUND objects only have a single dimension internally to HDF5 (a vector), but they correspond to R-data.frames,
##' which are 2 dimensional. For an HDF5 COMPOUND object, it is currently not possible to only sub-select a specific column.
##' All columns have to be extracted (using 1-dimensional access with \code{[} and can then be subset in R itself.
##' The same is true for writing a COMPOUND object (\code{\link{H5T_COMPOUND}}). A complete data-frame
##' is needed, not just a subset of the columns.
##'
##' Another important differences is for datasets of HDF5-ARRAY type \code{\link{H5T_ARRAY}}
##' where the access to the object is only for the dimension of the object itself, not including the dimensions of the underlying array type.
##' @title Selecting and assigning subsets of HDF5-Spaces and HDF5-Datasets
##' @param x The  \code{\link{H5S}} or \code{\link{H5D}} to subset or assign values to
##' @param d1 First dimension of the object
##' @param ... Used for other dimension of the object
##' @param op Operation to perform on the \code{\link{H5S}}. Look into the HDF5 online help
##' \url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} and
##' \url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html}
##' @param dataset_xfer_pl An object of class \code{\link{H5P_DATASET_XFER}}.
##' @param flags Some flags governing edge cases of conversion from HDF5 to R. This is related to how integers are being treated and
##' the issue of R not being able to natively represent 64bit integers and not at all being able to represent unsigned 64bit integers
##' (even using add-on packages). The constants governing this are part of \code{\link{h5const}}. The relevant ones start with the term
##' \code{H5TOR} and are documented there. The default set here returns a regular 32bit integer if it doesn't lead to an overflow
##' and returns a 64bit integer from the \code{bit64} package otherwise. For 64bit unsigned int that are larger than 64bit signed int,
##' it return a \code{double}. This looses precision, however. See also documentation or \code{\link{h5const}}.
##' @param value The value to assign to the dataset
##' @param drop Logical. When reading data, should dimensions of size 1 be dropped.
##' @param envir The environment in which the dimension indices \code{d1, ...} are to be evaluated. Usually the environment from
##' where the function is called
##' @return For \code{x} being a \code{\link{H5S}}, the same object is returned, but with the selection set as requested. For
##' \code{\link{H5D}} it retrieves the subset of data requested or sets the subset of data assigned, as for any n-dimensional array
##' in R.
##' @author Holger Hoefling
##' @name H5S_H5D_subset_assign
NULL

#' @rdname H5S_H5D_subset_assign
#' @export
subset_h5.H5S <- function(x,d1, ..., op=h5const$H5S_SELECT_SET, envir=parent.frame()) {
    args <- eval(substitute(alist(d1, ...)))

    return(x$subset(args=args, op=op, envir=envir))
}



#' @rdname H5S_H5D_subset_assign
#' @export
'[.H5S' <- subset_h5.H5S

#' @rdname H5S_H5D_subset_assign
#' @export
subset_h5.H5D <- function(x, d1, ..., dataset_xfer_pl=h5const$H5P_DEFAULT,
                          flags=getOption("hdf5r.h5tor_default"), drop=TRUE, envir=parent.frame()) {
    args <- eval(substitute(alist(d1, ...)))
    return(x$read(args=args, dataset_xfer_pl=dataset_xfer_pl, flags=flags, drop=drop, envir=envir))
}

#' @rdname H5S_H5D_subset_assign
#' @export
"[.H5D" <- subset_h5.H5D


#' @rdname H5S_H5D_subset_assign
#' @export
subset_assign_h5.H5D <- function(x, d1, ..., dataset_xfer_pl=h5const$H5P_DEFAULT, envir=parent.frame(), value) {
    args <- eval(substitute(alist(d1, ...)))
    return(x$write(args=args, value=value, dataset_xfer_pl=dataset_xfer_pl, envir=envir))
}

#' @rdname H5S_H5D_subset_assign
#' @export
"[<-.H5D" <- subset_assign_h5.H5D


###############################################################
# Helper functions for evaluating arguments
###############################################################

##' Apply a selection to a space
##'
##' Calls the respective stand-alone functions for point-selection or multiple hyperslab selection. The reason for not
##' calling a method of an R6 object is to make it more efficient and make it useable without creating a full R6 object.
##' @title Apply a selection to a space
##' @param space_id The space_id of the space to which to apply the selection to
##' @param selection The selection object of class \code{point_selection} or \code{hyperslab_selection}
##' @return NULL
##' @author Holger Hoefling
##' @keywords internal
apply_selection <- function(space_id, selection) {
    op <- h5const$H5S_SELECT_SET
    if(inherits(selection, "point_selection")) {
        standalone_H5S_select_elements(id=space_id, coord=selection, op=h5const$H5S_SELECT_SET, byrow=TRUE)
    }
    else if(inherits(selection, "hyperslab_selection")) {
        standalone_H5S_select_multiple_hyperslab(id=space_id, hyperslab_array=selection)
    }
    else {
        stop("Unknown selection type; needs to be of class point_selection of hyperslab_selection")
    }
    return(invisible(NULL))
}



##' Can arguments be interpreted as a scalar?
##'
##' Check if there is only one argument and if it is either empty
##' of of length 1 with value 1, i.e. can be interpreted as a scalar.
##' @title Can arguments be interpreted as a scalar?
##' @param args The arguments to check
##' @return Logical if the arguments can be interpreted as a scalar
##' @author Holger Hoefling
##' @keywords internal
are_args_scalar <- function(args) {
    if(length(args) != 1) {
        return(FALSE)
    }
    if(args[[1]]==bquote(expr=) || args[[1]] == 1) {
        return(TRUE)
    }
    else {
        return(FALSE)
    }
}


##' Check argument for known functions that encode a hyperslab
##'
##' Checks for the functions \code{:}, \code{seq} and \code{seq_len}
##' @title Check argument for known functions that encode a hyperslab
##' @param x The argument to check
##' @param envir The environment in which to evaluate the argument
##' @return A vector of length 4 describing start, count, stride and block if appropriate
##' @author Holger Hoefling
##' @keywords internal
check_arg_for_hyperslab_func <- function(x, envir) {
    res <- c(NA, NA, NA, NA)
    if(is.call(x)) {
        if(length(x) > 1) {
            for(i in 2:length(x)) {
                x[[i]] <- eval(x[[i]], envir=envir)
            }
        }
        if(x[[1]] == ":") {
            if(length(x) == 3) {
                if(x[[3]] < x[[2]]) {
                    stop("Retrieving hyperslabs in reverse order not supported")
                }
                start <- as.numeric(x[[2]])
                block <- as.numeric(x[[3]]) - start + 1
                res <- c(start, 1, 1, block)
            }
        }
        else if(x[[1]] == "seq_len") {
            res <- c(1, 1, 1, as.numeric(x[[2]]))
        }
        else if(x[[1]] == "seq") {
            if(length(x) >= 2 && (is.integer(x[[2]]) || is.numeric(x[[2]]))) {
                ## in both cases use a matching to seq.default, as the signatures are the same
                matched_call <- match.call.withDef(seq.default, x)
                if(is.null(matched_call$length.out)) {
                    length.out <- floor(((as.numeric(matched_call$to) - as.numeric(matched_call$from)) / as.numeric(matched_call$by)) + 1)
                }
                else {
                    length.out <- as.numeric(matched_call$length.out)
                }
                stride <- as.numeric(matched_call$by)
                start <- as.numeric(matched_call$from)
                if(stride==1) {
                    ## it is one block
                    res <- c(start, 1, stride, length.out)
                }
                else {
                    ## it is length.out blocks, each of length 1
                    res <- c(start, length.out, stride, 1)
                }
            }
        }
    }
    if(!is.na(res[[1]]) && res[[1]] <= 0) {
        res <- c(NA, NA, NA, NA)
    }
    return(res)
}


##' Evaluate if the arguments are regular for hyperslab use
##'
##' For each argument check if it can be used as a hyperslab, potentially after sorting and making unique.
##' @title Evaluate if the arguments are regular for hyperslab use
##' @param args The arguments input; if it was empty, then set to NULL
##' @param ds_dims The dimensions of the input dataset
##' @param envir The environment in which to evaluate the arguments
##' @param post_read Should the reshuffle be computed for post-read (then \code{TRUE}) or pre-write (then \code{FALSE})
##' @return A list with 2 parts; Evaluated arguments, regularity report and reshuffle indicators. Will be returned as a list
##' with components \code{args_in}, \code{args_point}, \code{is_hyperslab}, \code{hyperslab},
##' \code{needs_reshuffle}, \code{reshuffle}, \code{result_dims_pre_shuffle}, \code{result_dims_post_shuffle}, \code{max_dims}
##' @author Holger Hoefling
##' @keywords internal
args_regularity_evaluation <- function(args, ds_dims, envir, post_read=TRUE) {
    ## check that the number of arguments is the same as the dataset dimension
    if(length(args) != length(ds_dims)) {
        stop("Number of arguments not equal to number of dimensions: ", length(args), " vs. ", length(ds_dims))
    }

    ## create the skeleton for the regularity report
    ## has columns: start, count, stride, block
    hyperslab <- matrix(rep(NA, length(args) * 4), ncol=4)
    colnames(hyperslab) <- c("start", "count", "stride", "block")

    is_hyperslab <- rep(FALSE, length(args))
    needs_reshuffle <- is_hyperslab
    args_in <- args
    args_point <- vector("list", length(args))
    result_dims_pre_shuffle <- numeric(length(args))
    result_dims_post_shuffle <- numeric(length(args))
    max_dims <- result_dims_pre_shuffle
    reshuffle <- args_point

    for(i in seq_along(args)) {
        cur_arg <- args[[i]]
        if(length(args[[i]]) == 1 && args[[i]]==quote(expr=)) {
            ## set to maximal hyperslab for this dimension
            res_hyper <- c(1, 1, 1, ds_dims[[i]])
        }
        else if(is.call(cur_arg)) {
            res_hyper <- check_arg_for_hyperslab_func(cur_arg, envir)
        }
        else {
            res_hyper <- c(NA, NA, NA, NA)
        }
        ## res_hyper contains the information if the argument can be interpreted as a hyperslab

        if(!any(is.na(res_hyper))) { ## is a hyperslab made from a function
            is_hyperslab[i] <- TRUE
            hyperslab[i,] <- res_hyper
            needs_reshuffle[i] <- FALSE
            result_dims_pre_shuffle[i] <- res_hyper[2] * res_hyper[4] # count * block
            result_dims_post_shuffle[i] <- res_hyper[2] * res_hyper[4] # count * block
            max_dims[i] <- res_hyper[1] + (res_hyper[2] - 1) * res_hyper[3] + res_hyper[4] - 1 # start + (count - 1) * stride + block - 1
        }
        else {
            cur_arg <- eval(cur_arg, envir=envir)
            if(is.logical(cur_arg)) {
                ## expand it as necessary and convert to an integer vector
                cur_arg <- seq_len(ds_dims[[i]])[cur_arg]
            }
            if(is.null(cur_arg)) {
                ## make it into a numeric of length 0
                cur_arg <- numeric(0)
            }
            if(is.numeric(cur_arg) || is.integer(cur_arg) || is.integer64(cur_arg)) {
                cur_arg <- as.numeric(cur_arg)
                ## check if it has length 0 or 1; these are special cases
                if(length(cur_arg) == 0) {
                    is_hyperslab[i] <- FALSE
                    needs_reshuffle[i] <- FALSE
                    args_point[[i]] <- cur_arg
                    result_dims_pre_shuffle[i] <- 0
                    result_dims_post_shuffle[i] <- 0
                    max_dims[i] <- -Inf
                }
                else if(length(cur_arg) == 1) {
                    is_hyperslab[i] <- TRUE
                    needs_reshuffle[i] <- FALSE
                    result_dims_pre_shuffle[i] <- 1
                    result_dims_post_shuffle[i] <- 1
                    hyperslab[i, ] <- c(cur_arg, 1, 1, 1)
                    max_dims[i] <- cur_arg
                }
                else {
                    ## check it is all positive, negative or a mixture of both
                    if(all(cur_arg < 0)) {
                        cur_arg <- seq_len(ds_dims[[i]])[cur_arg]
                    }
                    else if(!all(cur_arg > 0)) {
                        stop("In index ", i, " not all subscripts are either positive or negative")
                    }
                    ## then check if it can be written as a hyperslab
                    cur_arg_diff_unique <- unique(diff(cur_arg))
                    if(all(cur_arg_diff_unique > 0)) { ## strictly increasing
                        needs_reshuffle[i] <- FALSE
                        max_dims[i] <- cur_arg[length(cur_arg)]
                        result_dims_pre_shuffle[i] <- length(cur_arg)
                        result_dims_post_shuffle[i] <- length(cur_arg)
                        if(length(cur_arg_diff_unique) == 1) {
                            is_hyperslab[i] <- TRUE

                            if(cur_arg_diff_unique == 1) {
                                hyperslab[i, ] <- c(cur_arg[[1]], 1, 1, length(cur_arg))
                            }
                            else {
                                hyperslab[i, ] <- c(cur_arg[[1]], length(cur_arg), cur_arg_diff_unique, 1)
                            }
                        }
                        else {
                            ## can only be done as points, not as a hyperslab
                            is_hyperslab[i] <- FALSE
                            args_point[[i]] <- cur_arg
                        }
                    }
                    else { ## not strictly increasing, so sort and make unique
                        ## see if a sorting and making unique could make it into a hyperslab
                        sort_arg <- sort(unique.default(cur_arg))
                        needs_reshuffle[i] <- TRUE
                        if(post_read) {
                            reshuffle[[i]] <- match(cur_arg, sort_arg)
                            result_dims_pre_shuffle[i] <- length(sort_arg)
                            result_dims_post_shuffle[i] <- length(cur_arg)
                        }
                        else {
                            ## need to invalidate the first instance of anything that is duplicated
                            reshuffle[[i]] <- order(cur_arg)[!duplicated(cur_arg, fromLast=TRUE)]
                            ## length of pre and post are reversed here
                            result_dims_post_shuffle[i] <- length(sort_arg)
                            result_dims_pre_shuffle[i] <- length(cur_arg)

                        }

                        sort_arg_diff <- diff(sort_arg)
                        sort_arg_diff_unique <- unique(sort_arg_diff)
                        ## now same as before for the unsorted one
                        ## but as is sorted and unique, know already that it is non-decreasing
                        max_dims[i] <- sort_arg[length(sort_arg)]
                        if(length(sort_arg_diff_unique) == 1) {
                            is_hyperslab[i] <- TRUE

                            if(sort_arg_diff_unique == 1) {
                                hyperslab[i, ] <- c(sort_arg[[1]], 1, 1, length(sort_arg))
                            }
                            else {
                                hyperslab[i, ] <- c(sort_arg[[1]], length(sort_arg), sort_arg_diff_unique, 1)
                            }
                        }
                        else {
                            ## can only be done as points, not as a hyperslab
                            is_hyperslab[i] <- FALSE
                            args_point[[i]] <- sort_arg
                        }
                    }
                }
            }
            else {
                stop("Can't evaluate argument ", i)
            }
        }

    }
    return(list(args_in=args_in, args_point=args_point, is_hyperslab=is_hyperslab, hyperslab=hyperslab,
                result_dims_pre_shuffle=result_dims_pre_shuffle, result_dims_post_shuffle=result_dims_post_shuffle,
                max_dims=max_dims, needs_reshuffle=needs_reshuffle, reshuffle=reshuffle))
}

##' Single hyperslab dimension to explicit vector
##'
##' Uses the information of a hyperslab and turns it into an explicit vector.
##' @title Single hyperslab dimension to explicit vector
##' @param hyperslab a length 4 vector describing the start, count, stride and block component of a single dimension of a hyperslab
##' @return An explicit vector describing the points in the hyperslab dimension
##' @author Holger Hoefling
##' @keywords internal
hyperslab_to_points <- function(hyperslab) {
    stopifnot(length(hyperslab)==4 && is.numeric(hyperslab))
    ## c("start", "count", "stride", "block")
    if(hyperslab[[2]] == 1) { # only one block
        res <- (seq_len(hyperslab[[4]]) - 1) + hyperslab[[1]] 
    }
    else if(hyperslab[[4]] == 1) { # only blocks of size 1
        res <- ((seq_len(hyperslab[[2]]) - 1) * hyperslab[[3]]) + hyperslab[[1]]
    }
    else { # mixed; should not occur for us but will write function to handle this anyway
        ## doesn't need to be overly efficient
        res <- rep(seq_len(hyperslab[[4]]), times=hyperslab[[2]])
        ## now add it the stride component
        res <- res + rep((seq_len(hyperslab[[2]]) - 1) * hyperslab[[3]], each=hyperslab[[4]])
        res <- res + hyperslab[[1]] - 1
    }
    return(res)
}

##' Turn regulation evaluation into a selection for a space object
##'
##' Analyzes the results of the regularity evaluation of each dimension and checks if
##' it needs to be into a hyperslab-selection or a point-selection. A hyperslab selection will be chosen
##' whenever there are significantly less of it than the number of selected points. The ratio is determined
##' by the option \code{hdf5r.point_to_hyperslab_ratio}. If this is 1, then always hyperslabs will be used.
##' @title Turn regulation evaluation into a selection for a space object
##' @param reg_eval_res The result of the \code{args_regularity_evaluation} function
##' @return Returns an object with either the point-matrix or the hyperslab-selection array. The resulting object is
##' of class \code{point_selection} or \code{hyperslab_selection}.
##' @author Holger Hoefling
##' @keywords internal
regularity_eval_to_selection <- function(reg_eval_res) {
    ## first calculate how many points need to be selected and how many hyperslabs would need to be necesary
    num_points <- prod(reg_eval_res$result_dims_pre_shuffle)
    num_hyperslabs <- prod(reg_eval_res$result_dims_pre_shuffle[!reg_eval_res$is_hyperslab])

    ## trivially any selection can always be written as a concatenation of hyperslabs; so should be ever do a pointlist?
    ## likely pointlist more efficient in selection. Use hyperslabs only if we have X-fold fewer hyperslabs than datapoints
    ## here choose X as >= 4 for now
    if(num_hyperslabs == 0) {
        point_hyperslab_ratio <- 0
    }
    else {
        point_hyperslab_ratio <- num_points / num_hyperslabs
    }
    if(point_hyperslab_ratio >= getOption("hdf5r.point_to_hyperslabs_ratio")) {
        ## use a hyperslab
        sel_type <- "hyperslab_selection"
        ## make a 3-dimensional array, each 2 dimensional sub-array (in the third dimension) is a complete hyperslab description
        if(any(!reg_eval_res$is_hyperslab)) {
            ## not just 1 hyperslab
            point_grid <- expand_point_grid(reg_eval_res$args_point[!reg_eval_res$is_hyperslab])
            hyperslab_array <- array(0, dim=c(nrow(reg_eval_res$hyperslab), nrow(point_grid), 4))
            for(i in 1:4) {
                hyperslab_array[,,i] <- reg_eval_res$hyperslab[,i]
            }
            ## c("start", "count", "stride", "block")
            ## set the dimensions that are the point grid; those currently have NA in them
            hyperslab_array[!reg_eval_res$is_hyperslab, , 1] <- t(point_grid)
            hyperslab_array[!reg_eval_res$is_hyperslab, , 2] <- 1
            hyperslab_array[!reg_eval_res$is_hyperslab, , 3] <- 1
            hyperslab_array[!reg_eval_res$is_hyperslab, , 4] <- 1
        }
        else {
            hyperslab_array <- array(reg_eval_res$hyperslab, dim=c(nrow(reg_eval_res$hyperslab), 1, 4))
        }
        sel <- hyperslab_array
    }
    else {
        sel_type <- "point_selection"
        ## if there are any hyperslab dimensions, expand them to a point list
        args_point <- reg_eval_res$args_point
        if(any(reg_eval_res$is_hyperslab)) {
            for(i in which(reg_eval_res$is_hyperslab)) {
                args_point[[i]] <- hyperslab_to_points(reg_eval_res$hyperslab[i,])
            }
        }

        sel <- expand_point_grid(args_point)
    }
    return(structure(.Data=sel, class=sel_type))
}





##' Expand list of points for each dimension into a matrix of all combinations
##'
##' The function is similar to the \code{expand.grid} function
##' @title Expand list of points for each dimension into a matrix of all combinations
##' @param point_list A list of the points in each dimension to include
##' @return A matrix with every combination of points for each dimension
##' @author Holger Hoefling
##' @keywords internal
expand_point_grid <- function(point_list) {
    point_list_size <- unlist(lapply(point_list, length))
    cum_prod_std <- c(1, cumprod(point_list_size))
    cum_prod_rev <- rev(c(1, cumprod(rev(point_list_size))))
    num_points <- prod(point_list_size)
    point_mat <- matrix(numeric(num_points * length(point_list)), ncol=length(point_list))
    for(i in seq_along(point_list)) {
        point_mat[, i] <- rep(point_list[[i]], each=cum_prod_std[i], times=cum_prod_rev[i+1])
    }
    return(point_mat)
}





##' Match arguments in a call to function and add default values
##'
##' Given the definition of a function and a call, it matches the arguments
##' so that they are named and inserts any default argument values where
##' those are missing
##' @title Match arguments in a call to function and add default values
##' @param definition Definition of the function to match against
##' @param call The call that should be matched
##' @return A call with named arguments and default values
##' @author Holger Hoefling
##' @keywords internal
match.call.withDef <- function(definition, call) {
    def.formals <- formals(definition)
    foo <- try(as.list(match.call(definition = definition, call=call)), silent=TRUE)

    if(inherits(foo, "try-error")) {
        return(foo)
    }
    ## add the default arguments if they are missing
    for(v in names(def.formals)) {
        if(!(v %in% names(foo))) {
            foo <- c(foo, def.formals[v])
        }
    }
    return(foo)
}

##' Reshuffle the input as needed - see \code{args_regularity_evaluation}
##'
##' When necessary, this function performs the reshuffle as defined by \code{args_regularity_evaluation}.
##' @title Reshuffle the input as needed - see \code{args_regularity_evaluation}
##' @param x The array to reshuffle
##' @param reg_eval_res The result of the regularity evaluation
##' @return The reshuffled input
##' @author Holger Hoefling
##' @keywords internal
do_reshuffle <- function (x, reg_eval_res) {
    ## for the post read shuffle, we just have to use the order as noted in reg_eval_res
    ## however, data.frames have an additional dimension the evaluator currently
    ## does not know about, so have to add it
    if(inherits(x, "data.frame")) {
        if(length(reg_eval_res$needs_reshuffle) != 1) {
            stop("For data.frame, the selection can only have 1 dimension")
        }
        reorder_params <- rep(list(quote(expr=)), 2)
        if(reg_eval_res$needs_reshuffle) {
            reorder_params[1] <- reg_eval_res$reshuffle[1]
        }
    }
    else {
        reorder_params <- rep(list(quote(expr=)), length(reg_eval_res$reshuffle))

        reorder_params[reg_eval_res$needs_reshuffle] <- reg_eval_res$reshuffle[reg_eval_res$needs_reshuffle]
    }
    res <- do.call("[", c(list(x), reorder_params))
    return(res)
}




---
File: /R/Misc.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



##' Return the version of the HDF5-API
##'
##' Return the version of the HDF5-API and print it to the screen if requested
##' @title Return the version of the HDF5-API
##' @param verbose Should the information be printed to the screen as well
##' @return Version of the underlying HDF5 API as a string
##' @author Holger Hoefling
##' @importFrom utils packageVersion
##' @include Helper_functions.R
##' @export
h5version <- function(verbose=TRUE) {
    h5api_libversion <- .Call("R_H5get_libversion", request_empty(1), request_empty(1), request_empty(1), PACKAGE='hdf5r')
    h5api_version <- paste(c(h5api_libversion$majnum, h5api_libversion$minnum, h5api_libversion$relnum), collapse=".")
    if(verbose) {
        cat("hdf5r version", as.character(packageVersion("hdf5r")),
            "with C-library HDF5 Version ", h5api_version, "\n", sep=" ")
    }
    return(h5api_version)
}

##' Trigger the HDF5 garbage collection
##'
##' This function triggers the HDF5 internal garbage collection. It is independent of the
##' R garbage collection and currently has to be triggered by hand.
##' @title Trigger the HDF5 garbage collection
##' @return Invisible  \code{NULL} 
##' @author  Holger Hoefling
##' @export
h5garbage_collect <- function() {
    res <- .Call("R_H5garbage_collect", PACKAGE="hdf5r")$return_val
    if(res < 0) {
        stop("Error during HDF5 garbage collection")
    }
    return(invisible(NULL))
}



##' Convert a double or integer to hex
##'
##' Converts a double or integer to hex. Contrary to the built-in \code{\link{format}},
##' this is done without any conversion of integers in double-format to integers in integer format.
##' @title Convert a double or integer to hex
##' @param x The integer or double vector to convert
##' @return Character string with the hex value
##' @author Holger Hoefling
##' @export
as_hex <- function(x) {
    return(paste0("0x", .Call("R_as_hex", x, PACKAGE="hdf5r")))
}




---
File: /R/open_objs.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################






## count how many references are open in R to an object
obj_tracker <- new.env()


make_id_char <- function(id) {
    if(is.na(id)) {
        return(NA)
    }
    else {
        id_char <- format(as.integer64(id), width=25, scientific = FALSE)
        return(id_char)
    }
}

new_id_obj <- function(id) {
    return(environment())
}

is_open <- function(id) {
    id_char <- make_id_char(id)
    return(exists(id_char, envir=obj_tracker))
}

get_obj <- function(id) {
    id_char <- make_id_char(id)
    if(exists(id_char, envir=obj_tracker)) {
        return(get(id_char, envir=obj_tracker)$obj)
    }
    else {
        return(NULL)
    }

}

incr_count <- function(id) {
    id_char <- make_id_char(id)
    if(exists(id_char, envir=obj_tracker)) {
        item <- get(id_char, envir=obj_tracker)
        item$count <- item$count + 1
        assign(x=id_char, value=item, envir=obj_tracker)
        return(item)
    }
    else {
        item <- list(count=1, obj=new_id_obj(id))
        assign(x=id_char, value=item, envir=obj_tracker)
        return(item)
    }
}

rm_obj <- function(id) {
    id_char <- make_id_char(id)
    item <- try(get(id_char, envir=obj_tracker), silent=TRUE)
    if(!inherits(item, "try-error")) {
#        H5_close_any(item$obj$id)
        item$obj$id <- NA
        rm(list=id_char, envir=obj_tracker)
    }
    else {
        print(paste("Couldn't delete", id_char))
    }
    return(invisible(NULL))
}

decr_count <- function(id) {
    id_char <- make_id_char(id)
    if(exists(id_char, envir=obj_tracker)) {
        item <- get(id_char, envir=obj_tracker)
        if(item$count == 1) {
            rm_obj(id)
            return(invisible(NULL))
        }
        else {
            item$count <- item$count - 1
            assign(x=id_char, value=item, envir=obj_tracker)
            return(item)
        }
    }
    else {
        stop(paste("Can't decrease count of obj", id_char," - already 0"))
    }

}

obj_info <- function(id) {
    if(!is.character(id)) {
        id_char <- make_id_char(id)
    }
    else {
        id_char <- id
    }
    item <- get(id_char, envir=obj_tracker)
    id_internal <- item$obj$id
    return(data.frame(id=id, count=item$count, id_internal=id_internal))
}

list_tracked_obj <- function() {
    ## first trigger garbage collection; otherwise might happen that an object
    ## is deleted between listing it and trying to access it
    gc()
    all_obj <- as.list(ls(envir=obj_tracker))
    res <- do.call("rbind", lapply(all_obj, obj_info))
    rownames(res) <- NULL
    return(res)
}



---
File: /R/R6Classes_H5A.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################





##' Class for representing HDF5 attributes
##' 
##' This class represents an HDF5 attribute. Usually it is easier to read and write attributes for
##' groups, datasets and committed datatypes using the functions documented in \code{\link{h5attributes}}.
##'
##' Otherwise, the functionality for attributes is very similar to that of datasets (\code{\link{H5D}}),
##' however with the notable exception that attributes always have to be read and written as a whole.
##'
##' @docType class
##' @importFrom R6 R6Class
##' @return Object of class \code{\link{H5A}}. 
##' @author Holger Hoefling
##' @examples 
##' fname <- tempfile(fileext = ".h5")
##' file <- H5File$new(fname, mode = "a")
##' h5attr(file, "attr_numeric") <- rnorm(10)
##' a <- file$attr_open("attr_numeric")
##' a$get_info()
##' a$attr_name()
##' a$get_space()
##' a$get_type()
##' a$get_storage_size()
##' a$read()
##' a$write(10:1)
##' a$print()
##' a$close()
##' file$close_all()
##' @export
H5A <- R6Class("H5A",
               inherit=H5RefClass,
               public=list(
                   get_info=function() {
                       "This function implements the HDF5-API function H5Aget_info."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       res <- .Call("R_H5Aget_info", self$id, request_empty(1), PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error retrieving attribute info")
                       }
                       return(res$ainfo)
                   },
                   attr_name=function() {
                       "This function implements the HDF5-API function H5Aget_name."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       ## get size of the name
                       name_size <- .Call("R_H5Aget_name", self$id, 0, character(0), PACKAGE="hdf5r")$return_val
                       if(name_size < 0) {
                           stop("Error returning name of object")
                       }
                       if(name_size == 0) {
                           return(NA)
                       }
                       ## create a character vector of sufficient size (it will be copied in the internal C function as is available for writign
                       char_buf=paste(rep(" ", name_size+1), collapse="")
                       res <- .Call("R_H5Aget_name", self$id, name_size + 1, char_buf, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error returning name of object")
                       }
                       return(res$buf)
                   },
                   get_space=function() {
                       "This function implements the HDF5-API function H5Aget_space."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       id <- .Call("R_H5Aget_space", self$id, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving attribute type")
                       }
                       return(H5S$new(id=id))
                   },
                   get_type=function(native=TRUE) {
                       "This function implements the HDF5-API function H5Aget_type."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       id <- .Call("R_H5Aget_type", self$id, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving attribute type")
                       }
                       if(native) {
                           on.exit(.Call("R_H5Tclose", id, PACKAGE="hdf5r"))
                           ## return the native type
                           id_native <- .Call("R_H5Tget_native_type", id, h5const$H5T_DIR_ASCEND, PACKAGE="hdf5r")$return_val
                           if(id_native < 0) {
                               stop("Error retrieving native-c-type")
                           }
                           return(H5T_factory(id_native))
                       }
                       else {
                           return(H5T_factory(id))
                       }
                   },
                   get_storage_size=function() {
                       "This function implements the HDF5-API function H5Aget_storage_size."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       size <- .Call("R_H5Aget_storage_size", self$id, PACKAGE="hdf5r")$return_val
                       return(size)
                   },
                   read_low_level=function(buffer, mem_type, duplicate_buffer=FALSE) {
                       "Only for advanced users. See documentation for \\code{read} instead."
                       "This function implements the HDF5-API function H5Aread."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       check_class(mem_type, "H5T")
                       res <- .Call("R_H5Aread", self$id, mem_type$id, buffer, duplicate_buffer, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error reading dataset")
                       }
                       return(res$buffer)
                   },
                   read=function(flags=getOption("hdf5r.h5tor_default"), drop=TRUE) {
                       "Reads the data of the attribute and returns it as an R-object"
                       "@param flags Conversion rules for integer values. See also \\code{\\link{h5const}}"
                       "@param drop Logical. Should dimensions of length 1 be dropped (R-default for arrays)"
                       mem_type <- self$get_type()

                       check_class(mem_type, "H5T")
                       ## get the actual file-space and ascertain its size
                       attr_space <- self$get_space()
                       attr_space_type <- as.character(attr_space$get_simple_extent_type())
                           if(attr_space_type == "H5S_NULL"  ) {
                               nelem <- 0
                           }
                           else if(attr_space_type=="H5S_SCALAR") {
                               nelem <- 1
                           }
                           else {
                               nelem <- attr_space$get_select_npoints()
                           }
                       ## need to create the buffer to write this into
                       buffer <- H5ToR_Pre(mem_type, nelem)
                       
                       res <- .Call("R_H5Aread", self$id, mem_type$id, buffer, FALSE, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error reading dataset")
                       }
                       buffer_post <- H5ToR_Post(res$buf, mem_type, nelem, flags, self$id)
                       ## reclaim vlen data; always do this, to make sure
                       ## there is no native reclaim function for attributes; use the H5D function for now
                       if(mem_type$is_vlen()) {
                           herr <- .Call("R_H5Dvlen_reclaim", mem_type$id, attr_space$id, h5const$H5P_DEFAULT$id, res$buf, FALSE,
                                         PACKAGE="hdf5r")$return_val
                           if(herr < 0 ) {
                               stop("Error trying to reclaim buffer vlen data")
                           }
                       }

                       ## apply the right dimension, if it is available
                       dim_to_set <- extract_dim(space=attr_space, dtype=mem_type)
                       if(drop) {
                           dim_to_set <- dim_to_set[dim_to_set != 1]
                       }
                           

                       if(length(dim_to_set) > 1) {
                           .Call("set_dim_attribute", buffer_post, as.numeric(dim_to_set), PACKAGE = "hdf5r")
                       }
                       return(buffer_post)
                   },
                   write_low_level=function(buffer, mem_type) {
                       "Only for advanced users. See documentation for \\code{write} instead."
                       "This function implements the HDF5-API function H5Awrite."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_a.html} for details."

                       check_class(mem_type, "H5T")
                       res <- .Call("R_H5Awrite", self$id, mem_type$id, buffer, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error reading dataset")
                       }
                       return(invisible(self))
                   },
                   write=function(robj, mem_type=NULL, flush=getOption("hdf5r.flush_on_write")) {
                       "Writes the data of \\code{robj} to the attribute"
                       "@param robj The object to write into the attribute"
                       "@param mem_type The memory data type to use when transferring from HDF5 to intermediate storage. This is an "
                       "advanced development feature and may be removed in the future."
                       if(is.null(mem_type)) {
                           mem_type <- self$get_type()
                       }

                       ## get the actual file-space and ascertain its size
                       attr_space <- self$get_space()
                       attr_space_type <- as.character(attr_space$get_simple_extent_type())
                       if(attr_space_type == "H5S_NULL"  ) {
                           nelem_file <- 0
                       }
                       else if(attr_space_type=="H5S_SCALAR") {
                           nelem_file <- 1
                       }
                       else {
                           nelem_file <- attr_space$get_select_npoints()
                       }
                       
                       nelem_robj <- guess_nelem(robj, mem_type)

                       if(nelem_robj != nelem_file) {
                           stop("Number of objects in robj does not match number of elements selected in file")
                       }
                       
                       buffer <- RToH5(robj, mem_type, nelem_robj)
                       res <- .Call("R_H5Awrite", self$id, mem_type$id, buffer, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error writing dataset")
                       }
                       if(flush) {
                           self$flush()
                       }
                       return(invisible(self))
                   },
                   print=function(...){
                       "Prints information for the dataset"
                       "@param ... ignored"

                       is_valid <- self$is_valid
                       
                       print_class_id(self, is_valid)
                       
                       if(is_valid) {
                           ## get information about the file
                           ## get the dataset name
                           cat("Attribute: ", self$attr_name(), "\n", sep="")
                           this_dtype <- self$get_type()
                           type_text <- this_dtype$to_text()
                           cat("Datatype: ", type_text, "\n", sep="")
                           this_dtype$close()
                           ## get the dataspace
                           this_space <- self$get_space()
                           if(!this_space$is_simple()) {
                               ## has to be a NULL space
                               cat("Space: Type=NULL\n")
                           }
                           else {
                               extent_res <- this_space$get_simple_extent_dims()
                               if(extent_res$rank == 0) {
                                   cat("Space: Type=Scalar\n")
                               }
                               else {
                                   cat("Space: Type=Simple     ")
                                   cat("Dims=", paste(extent_res$dims, collapse=" x "), "     ", sep="")
                                   cat("Maxdims=", paste(extent_res$maxdims, collapse=" x "), "\n", sep="")
                               }
                           }
                           this_space$close()
                       }
                   }
                   ),
               private=list(
                   closeFun=function(id) if(!is.na(id) && is.loaded("R_H5Aclose", PACKAGE="hdf5r")) {
                       invisible(.Call("R_H5Aclose", id, PACKAGE = "hdf5r"))}
                   ),
               cloneable=FALSE
               )

R6_set_list_of_items(H5A, "public", commonFGDTA, overwrite=TRUE)



---
File: /R/R6Classes_H5D.R
---



#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



setOldClass("H5D")


##' Class for representing HDF5 datasets
##'
##' In HDF5, datasets can be located in a group (see \code{\link{H5Group}}) or at the
##' root of a file (see \code{\link{H5File}}). They can be created either with a pre-existing R-object
##' (arrays as well as data.frames are supported, but not lists or other complex objects), or by specifying
##' an explicit datatype (for available datatypes see \code{h5types$overview} as well as the dimension.
##' In addition, other features are supported such as transparent compression (for which a chunk-size can be selected).
##'
##' In order to create a dataset, the \code{create_dataset} methods of either \code{\link{H5Group}} or
##' \code{\link{H5File}} should be used. Please see the documentation there for how to create them.
##'
##' The most important parts of a dataset are the 
##' \describe{
##'   \item{Space}{The space of the dataset. It describes the dimension of the dataset as well as the maximum dimensions.
##'                Can be obtained using the \code{get_space} of the \code{\link{H5S}} object.}
##'   \item{Datatype}{The datatypes that is being used in the dataset. Can be obtained using the \code{get_type} method.
##'                   See \code{\link{H5T}} to get more information about using datatypes.}
##' }
##'
##' In order to read and write datasets, the \code{read} and \code{write} methods are available. In addition, the standard way of using
##' \code{[} to access arrays is supported as well (see \code{\link{H5S_H5D_subset_assign}} for more help).
##'
##' Other information/action of possible interest are
##' \describe{
##'   \item{Storage size}{The size of the dataset can be extracted using \code{get_storage_size}}
##'   \item{Size change}{The size of the dataset can be changed using the \code{set_extent} method}
##' }
##'
##' Please also note the active methods
##' \describe{
##'   \item{dims}{Dimension of the dataset}
##'   \item{maxdims}{Maximum dimensions of the dataset}
##'   \item{chunk_dims}{Dimension of the chunks}
##'   \item{key_info}{Returns the space, type, property-list and dimensions}
##' }
##' 
##' @docType class
##' @importFrom R6 R6Class
##' @return Object of class \code{\link{H5D}}.
##' @author Holger Hoefling
##' @examples
##' # First create a file to create datasets in it
##' fname <- tempfile(fileext = ".h5")
##' file <- H5File$new(fname, mode = "a")
##'
##' # Show the 3 different ways how to create a dataset
##' file[["directly"]] <- matrix(1:10, ncol=2)
##' file$create_dataset("from_robj", matrix(1:10, ncol=2))
##' dset <- file$create_dataset("basic", dtype=h5types$H5T_NATIVE_INT,
##'              space=H5S$new("simple", dims=c(5, 2), maxdims=c(10,2)), chunk_dims=c(5,2))
##'
##' # Different ways of reading the dataset
##' dset$read(args=list(1:5, 1))
##' dset$read(args=list(1:5, quote(expr=)))
##' dset$read(args=list(1:5, NULL))
##' dset[1:5, 1]
##' dset[1:5, ]
##' dset[1:5, NULL]
##'
##' # Writing to the dataset
##' dset$write(args=list(1:3, 1:2), value=11:16)
##' dset[4:5, 1:2] <- -(1:4)
##' dset[,]
##' 
##' # Extract key information
##' dset$dims
##' dset$maxdims
##' dset$chunk_dims
##' dset$key_info
##' dset
##'
##' file$close_all()
##' file.remove(fname)
##' @export
H5D <- R6Class("H5D",
               inherit=H5RefClass,
               public=list(
                   initialize=function(id=NULL) {
                       "Initializes a new dataset-object. Only for internal use. Use the \\code{create_dataset} function for \\code{\\link{H5Group}}"
                       "and \\code{\\link{H5File}} objects"
                       "@param id For internal use only"
                       if(is.null(id)) {
                           stop("An id has to be provided for a dataset of class H5D. For creating a dataset, use 'create_dataset' for an H5File or H5Group")
                       }
                       super$initialize(id=id)
                   },
                   get_space=function() {
                       "This function implements the HDF5-API function H5Dget_space."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       id <- .Call("R_H5Dget_space", self$id, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving dataspace")
                       }
                       return(H5S$new(id=id))
                   },
                   get_space_status=function() {
                       "This function implements the HDF5-API function H5Dget_space_status."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       res <- .Call("R_H5Dget_space_status", self$id, request_empty(1), PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error retrieving space status")
                       }
                       return(res$allocation)
                   },
                   get_type=function(native=TRUE) {
                       "This function implements the HDF5-API function H5Dget_type."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       id <- standalone_H5D_get_type(h5d_id=self$id, native=native) 
                       return(H5T_factory(id))
                   },
                   get_create_plist=function() {
                       "This function implements the HDF5-API function H5Dget_create_plist."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       id <- .Call("R_H5Dget_create_plist", self$id, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving dataset creation property list")
                       }
                       return(H5P_DATASET_CREATE$new(id=id))
                   },
                   get_access_plist=function() {
                       "This function implements the HDF5-API function H5Dget_access_plist."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       id <- .Call("R_H5Dget_access_plist", self$id, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving dataset access property list")
                       }
                       return(H5P_DATASET_ACCESS$new(id=id))
                   },
                   get_offset=function() {
                       "This function implements the HDF5-API function H5Dget_offset."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       haddr <- .Call("R_H5Dget_offset", self$id, PACKAGE="hdf5r")$return_val
                       if(haddr < 0) {
                           stop("Error retrieving address; is undefined")
                       }
                       return(haddr)
                   },
                   get_storage_size=function() {
                       "This function implements the HDF5-API function H5Dget_storage_size."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       size <- .Call("R_H5Dget_storage_size", self$id, PACKAGE="hdf5r")$return_val
                       return(size)
                   },
                   vlen_get_buf_size=function(type, space) {
                       "This function implements the HDF5-API function H5Dvlen_get_buf_size."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       check_class(type, "H5T")
                       check_class(space, "H5S")

                       res <- .Call("R_H5Dvlen_get_buf_size", self$id, type$id, space$id, request_empty(1), PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error trying to calculate vlen buffer size")
                       }
                       return(res$size)
                   },
                   vlen_reclaim=function(buffer, type, space, dataset_xfer_pl=h5const$H5P_DEFAULT) {
                       "This function implements the HDF5-API function H5Dvlen_reclaim."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       check_class(type, "H5T")
                       check_class(space, "H5S")

                       check_pl(dataset_xfer_pl, "H5P_DATASET_XFER")
                       herr <- .Call("R_H5Dvlen_reclaim", type$id, space$id, dataset_xfer_pl$id, buffer, FALSE, PACKAGE="hdf5r")$return_val
                       if(herr < 0 ) {
                           stop("Error trying to reclaim buffer vlen data")
                       }
                       return(invisible(self))
                   },
                   read_low_level=function(file_space=h5const$H5S_ALL, mem_space=NULL, mem_type=NULL,
                       dataset_xfer_pl=h5const$H5P_DEFAULT, flags=getOption("hdf5r.h5tor_default"), set_dim=FALSE, dim_to_set=NULL, drop=TRUE) {
                       "This function is for advanced users. It is recommended to use \\code{read} instead or the \\code{[} interface."
                       "This function implements the HDF5-API function H5Dread, with minor changes to the API to accommodate R."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."
                       "It reads the data in the dataset as specified by \\code{mem_space} and return it as an R-obj"
                       "@param file_space An HDF5-space, represented as class \\code{\\link{H5S}} that determines which part"
                       "of the dataset is being read. Can also be given as an id"
                       "@param mem_space The space as it is represented in memory; advanced feature; may be removed in the future."
                       "Can also be given as an id."
                       "@param mem_type Memory type; extracted from the dataset if null (can be passed in for efficiency reasons"
                       "Can also be given as an id."
                       "@param dataset_xfer_pl Dataset transfer property list. See \\code{\\link{H5P_DATASET_XFER}}"
                       "@param flags Conversion rules for integer values. See also \\code{\\link{h5const}}"
                       "@param set_dim If \\code{TRUE}, the dimension attribute is set in the return value. How it is set "
                       "is determined by \\code{dim_to_set}."
                       "@param dim_to_set The dimension to set; Has to be numeric and needs to be specified if \\code{set_dim} is \\code{TRUE}."
                       "If the result is a data.frame, i.e. the data-type is a compound, then the dimension is ignored as the"
                       "correct dimension is already set."
                       "@param drop Logical. Should dimensions of length 1 be dropped (R-default for arrays)"

                       ## first ensure that file_space of the correct types and extract the id
                       if(!inherits(file_space, "H5S") && !(is.integer64(file_space) && length(file_space) == 1)) {
                           stop("file_space has to be an id or of type H5T")
                       }
                       file_space_id <- get_id(file_space)
                       
                       if(file_space_id==h5const$H5S_ALL$id) {
                           ## get the actual file-space and ascertain its size
                           file_space_id <- .Call("R_H5Dget_space", self$id, PACKAGE="hdf5r")$return_val
                           on.exit(.Call("R_H5Sclose", file_space_id, PACKAGE = "hdf5r"), add=TRUE)
                           .Call("R_H5Sselect_all", file_space_id, PACKAGE = "hdf5r")

                           nelem <- .Call("R_H5Sget_select_npoints", file_space_id, PACKAGE = "hdf5r")$return_val
                           ## in this case, we ignore what mem_space is set to
                           mem_space_id <- h5const$H5S_ALL$id
                       }
                       else {
                            ## else, just get a linear space
                           nelem <- .Call("R_H5Sget_select_npoints", file_space_id, PACKAGE = "hdf5r")$return_val

                           if(is.null(mem_space)) {
                               ## use this simple space; this may come with some speed penalties
                               ## arguements are rank, dims, maxdims
                               mem_space_id <- as.integer64(.Call("R_H5Screate_simple", 1, nelem, nelem, PACKAGE="hdf5r")$return_val)
                               if(mem_space_id < 0) {
                                   stop("Error creating simple dataspace")
                               }
                               on.exit(.Call("R_H5Sclose", mem_space_id, PACKAGE = "hdf5r"), add=TRUE)

                           }
                           else {
                               if(!inherits(mem_space, "H5S") && !(is.integer64(mem_space) && length(mem_space) == 1)) {
                                   stop("mem_space has to be an id or of type H5T")
                               }
                               ## extract the id that was given
                               mem_space_id <- get_id(mem_space)
                           }
                       }
                       ## ok, now the file_space_id and the mem_space_id are set

                       if(is.null(mem_type)) {
                           mem_type_id <- standalone_H5D_get_type(h5d_id=self$id, native=TRUE)
                           on.exit(.Call("R_H5Tclose", mem_type_id, PACKAGE = "hdf5r"), add=TRUE)
                       }
                       else {
                           if(!inherits(mem_type, "H5T") && !(is.integer64(mem_type) && length(mem_type) == 1)) {
                               stop("mem_type has to be an id or of type H5T")
                           }
                           ## now extract the ids
                           mem_type_id <- get_id(mem_type)
                       }
                       
                       check_pl(dataset_xfer_pl, "H5P_DATASET_XFER")
                       
                       ## need to create the buffer to write this into 
                       buffer <- .Call("R_H5ToR_Pre", mem_type_id, nelem, PACKAGE="hdf5r")
                       res <- .Call("R_H5Dread", self$id, mem_type_id, mem_space_id, file_space_id, dataset_xfer_pl$id,
                                    buffer, FALSE, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error reading dataset")
                       }
                       buffer_post <- .Call("R_H5ToR_Post", res$buf, mem_type_id, nelem, flags, self$id, PACKAGE="hdf5r")
                       
                       if(set_dim && !inherits(buffer_post, "data.frame")) {
                           if(is.null(dim_to_set)) {
                               stop("dim_to_set needs to be specified if set_dim is true")
                           }
                           if(length(buffer_post) != prod(dim_to_set)) {
                               stop("Length of read object unequal to product of dim_to_set")
                           }
                           if(drop) {
                               dim_to_set <- dim_to_set[dim_to_set != 1]
                           }
                           
                           if(length(dim_to_set) > 1) {
                               .Call("set_dim_attribute", buffer_post, as.numeric(dim_to_set), PACKAGE = "hdf5r")
                           }
                       }
                       ## reclaim vlen data if the mem_type is vlen
                       ## first need to know if it is vlen; may in future integrate with R_H5ToR_Post
                       mem_type_is_vlen <- as.logical(.Call("R_H5Tdetect_vlen", mem_type_id, PACKAGE = "hdf5r")$return_val)
                       if(mem_type_is_vlen) {
                           mem_space_explicit_id <- as.integer64(.Call("R_H5Screate_simple", 1, nelem, nelem, PACKAGE="hdf5r")$return_val)
                           if(mem_space_explicit_id < 0) {
                               stop("Error creating simple dataspace")
                           }
                           on.exit(.Call("R_H5Sclose", mem_space_explicit_id, PACKAGE = "hdf5r"), add=TRUE)
                           herr <- .Call("R_H5Dvlen_reclaim", mem_type_id, mem_space_explicit_id,
                                         dataset_xfer_pl$id, buffer, FALSE, PACKAGE="hdf5r")$return_val
                           if(herr < 0 ) {
                               stop("Error trying to reclaim buffer vlen data")
                           }
                       }

                       return(buffer_post)
                   },
                   read=function(args=NULL, dataset_xfer_pl=h5const$H5P_DEFAULT, flags=getOption("hdf5r.h5tor_default"), drop=TRUE, envir=parent.frame()) {
                       "Main interface for reading data from the dataset. It is the function that is used by \\code{[}, where"
                       "all indices are being passed in the parameter \\code{args}."
                       "@param args The indices for each dimension to subset given as a list. This makes this easier to use as a programmatic API."
                       "For interactive use we recommend the use of the \\code{[} operator. If set to \\code{NULL}, the entire dataset will be read."
                       "@param envir The environment in which to evaluate \\code{args}"
                       "@param dataset_xfer_pl An object of class \\code{\\link{H5P_DATASET_XFER}}." 
                       "@param flags Some flags governing edge cases of conversion from HDF5 to R. This is related to how integers are being treated and"
                       "the issue of R not being able to natively represent 64bit integers and not at all being able to represent unsigned 64bit integers"
                       "(even using add-on packages). The constants governing this are part of \\code{\\link{h5const}}. The relevant ones start with the term"
                       "\\code{H5TOR} and are documented there. The default set here returns a regular 32bit integer if it doesn't lead to an overflow"
                       "and returns a 64bit integer from the \\code{bit64} package otherwise. For 64bit unsigned int that are larger than 64bit signed int,"
                       "it return a \\code{double}. This looses precision, however."
                       "@param drop Logical. When reading data, should dimensions of size 1 be dropped."
                       "@return The data that was read as an R object"

                       self_space_id <- as.integer64(.Call("R_H5Dget_space", self$id, PACKAGE="hdf5r")$return_val)
                       on.exit(.Call("R_H5Sclose", self_space_id, PACKAGE = "hdf5r"), add=TRUE)
                       
                       self_space_is_simple <- as.logical(.Call("R_H5Sis_simple", self_space_id, PACKAGE = "hdf5r")$return_val)
                       if(!self_space_is_simple) {
                           stop("Dataspace has to be simple for a selection to occur")
                       }
                       simple_extent <- standalone_H5S_get_simple_extent_dims(self_space_id)
                       ## distinguish between scalar and non-scalar
                       if(simple_extent$rank == 0) {
                           if(is.null(args)) {
                               args <- list(quote(expr=))
                           }
                           ## is a scalar
                           if(are_args_scalar(args)) {
                               res <- self$read_low_level(file_space=self_space_id, mem_space=self_space_id, dataset_xfer_pl=dataset_xfer_pl)
                           }
                           else {
                               stop("Scalar dataspace; arguments have to be of length 1 and empty or equal to 1")
                           }
                       }
                       else {
                           dset_rank <- simple_extent$rank
                           if(is.null(args)) {
                               ## create arguments that are missing in every dimension, i.e. represent all
                               args <- rep(list(quote(expr=)), dset_rank)
                           }
                           reg_eval_res <- args_regularity_evaluation(args=args, ds_dims=simple_extent$dims, envir=envir)
                           ## need to check if maximum dimension in indices are larger than dataset dimensions
                           ## if yes need to throw an error
                           if(any(reg_eval_res$max_dims > simple_extent$dims)) {
                               stop("The following coordinates are outside the dataset dimensions: ",
                                    paste(which(reg_eval_res$max_dims > simple_extent$dims), sep=", "))
                           }
                           robj_dim <- private$get_robj_dim(reg_eval_res) 
                           selection <- regularity_eval_to_selection(reg_eval_res=reg_eval_res) 
                           apply_selection(space_id=self_space_id, selection=selection) 

                           ## create the memory space
                           mem_space_dims <- reg_eval_res$result_dims_pre_shuffle
                           mem_space_rank <- length(mem_space_dims)
                           mem_space_id <- as.integer64(.Call("R_H5Screate_simple", mem_space_rank, rev(mem_space_dims), rev(mem_space_dims),
                                                 PACKAGE="hdf5r")$return_val)
                           if(mem_space_id < 0) {
                               stop("Error creating simple dataspace")
                           }
                           on.exit(.Call("R_H5Sclose", mem_space_id, PACKAGE = "hdf5r"), add=TRUE)
                           
                           ## check if we have a compound, where we don't have to set 
                           dim_to_set <- robj_dim$robj_dim_pre_shuffle
                           
                           res <- self$read_low_level(file_space=self_space_id, mem_space=mem_space_id,
                                         dataset_xfer_pl=dataset_xfer_pl, set_dim=TRUE, dim_to_set=dim_to_set, drop=drop)
                           
                           if(any(reg_eval_res$needs_reshuffle)) {
                               res <- do_reshuffle(res, reg_eval_res)
                           }
                       }
                       return(res)
                   },
                   write_low_level=function(robj, file_space=h5const$H5S_ALL, mem_space=NULL, mem_type=NULL, dataset_xfer_pl=h5const$H5P_DEFAULT,
                       flush=getOption("hdf5r.flush_on_write")) {
                       "This function is for advanced users. It is recommended to use \\code{read} instead or the \\code{[<-} interface"
                       "as used for arrays."
                       "This function implements the HDF5-API function H5Dwrite, with some changes to accommodate R."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."
                       "It writes that data from the \\code{robj} into the dataset."
                       "@param robj The object to write into the dataset"
                       "@param mem_space The space as it is represented in memory; advanced feature; may be removed in the future"
                       "@param mem_type Memory type; extracted from the dataset if null (can be passed in for efficiency reasons"
                       "@param file_space An HDF5-space, represented as class \\code{\\link{H5S}} that determines which part"
                       "of the dataset is being written."
                       "@param dataset_xfer_pl Dataset transfer property list. See \\code{\\link{H5P_DATASET_XFER}}"
                       "@param flush Should a flush be done after the write"

                       ## first ensure that file_space of the correct types and extract the id
                       if(!inherits(file_space, "H5S") && !(is.integer64(file_space) && length(file_space) == 1)) {
                           stop("file_space has to be an id or of type H5T")
                       }
                       file_space_id <- get_id(file_space)

                       if(file_space_id==h5const$H5S_ALL$id) {
                           ## get the actual file-space and ascertain its size
                           file_space_id <- .Call("R_H5Dget_space", self$id, PACKAGE="hdf5r")$return_val
                           on.exit(.Call("R_H5Sclose", file_space_id, PACKAGE = "hdf5r"), add=TRUE)
                           .Call("R_H5Sselect_all", file_space_id, PACKAGE = "hdf5r")

                           nelem_file <- .Call("R_H5Sget_select_npoints", file_space_id, PACKAGE = "hdf5r")$return_val
                           ## in this case, we ignore what mem_space is set to
                           mem_space_id <- h5const$H5S_ALL$id
                       }
                       else {
                            ## else, just get a linear space
                           nelem_file <- .Call("R_H5Sget_select_npoints", file_space_id, PACKAGE = "hdf5r")$return_val

                           if(is.null(mem_space)) {
                               ## use this simple space; this may come with some speed penalties
                               ## arguements are rank, dims, maxdims
                               mem_space_id <- as.integer64(.Call("R_H5Screate_simple", 1, nelem_file, nelem_file, PACKAGE="hdf5r")$return_val)
                               if(mem_space_id < 0) {
                                   stop("Error creating simple dataspace")
                               }
                               on.exit(.Call("R_H5Sclose", mem_space_id, PACKAGE = "hdf5r"), add=TRUE)

                           }
                           else {
                               if(!inherits(mem_space, "H5S") && !(is.integer64(mem_space) && length(mem_space) == 1)) {
                                   stop("mem_space has to be an id or of type H5T")
                               }
                               ## extract the id that was given
                               mem_space_id <- get_id(mem_space)
                           }
                       }

                       if(is.null(mem_type)) {
                           mem_type_id <- standalone_H5D_get_type(h5d_id=self$id, native=TRUE)
                           on.exit(.Call("R_H5Tclose", mem_type_id, PACKAGE = "hdf5r"), add=TRUE)
                       }
                       else {
                           if(!inherits(mem_type, "H5T") && !(is.integer64(mem_type) && length(mem_type) == 1)) {
                               stop("mem_type has to be an id or of type H5T")
                           }
                           ## now extract the ids
                           mem_type_id <- get_id(mem_type)
                       }
                       
                       nelem_robj <- .Call("R_guess_nelem", robj, mem_type_id, PACKAGE="hdf5r")

                       if(nelem_robj != nelem_file && (nelem_file %% nelem_robj != 0 || nelem_file < nelem_robj)) {
                           stop("Number of objects in robj is not the same and not a multiple of number of elements selected in file: expected are ",
                                nelem_file, " but provided are ", nelem_robj)
                       }
                       buffer <- .Call("R_RToH5", robj, mem_type_id, nelem_robj, PACKAGE="hdf5r")
                       if(nelem_robj != nelem_file) {
                           ## need to multiply input buffer
                           buffer <- rep(buffer, times=nelem_file / nelem_robj)
                       }
                       
                       res <- .Call("R_H5Dwrite", self$id, mem_type_id, mem_space_id, file_space_id, dataset_xfer_pl$id,
                                    buffer, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error writing dataset")
                       }
                       if(flush) {
                           self$flush
                       }
                       return(invisible(self))
                   },
                   write=function(args, value, dataset_xfer_pl=h5const$H5P_DEFAULT, envir=parent.frame()) {
                       "Main interface for writing data to the dataset. It is the function that is used by \\code{[<-}, where"
                       "all indices are being passed in the parameter \\code{args}."
                       "@param args The indices for each dimension to subset given as a list. This makes this easier to use as a programmatic API."
                       "For interactive use we recommend the use of the \\code{[} operator. If set to \\code{NULL}, the entire dataset will be read."
                       "@param value The data to write to the dataset"
                       "@param envir The environment in which to evaluate \\code{args}"
                       "@param dataset_xfer_pl An object of class \\code{\\link{H5P_DATASET_XFER}}." 
                       "@return The HDF5 dataset object, returned invisibly"

                       
                       self_space_id <- as.integer64(.Call("R_H5Dget_space", self$id, PACKAGE="hdf5r")$return_val)
                       on.exit(.Call("R_H5Sclose", self_space_id, PACKAGE = "hdf5r"), add=TRUE)
                       
                       self_space_is_simple <- as.logical(.Call("R_H5Sis_simple", self_space_id, PACKAGE = "hdf5r")$return_val)
                       if(!self_space_is_simple) {
                           stop("Dataspace has to be simple for a selection to occur")
                       }
                       simple_extent <- standalone_H5S_get_simple_extent_dims(self_space_id)
                       ## distinguish between scalar and non-scalar
                       if(simple_extent$rank == 0) {
                           if(is.null(args)) {
                               args <- list(quote(expr=))
                           }
                           ## is a scalar
                           if(are_args_scalar(args)) {
                               return(self$write_low_level(value, file_space=self_space_id, mem_space=self_space_id, dataset_xfer_pl=dataset_xfer_pl))
                           }
                           else {
                               stop("Scalar dataspace; arguments have to be of length 1 and empty or equal to 1")
                           }
                       }
                       else {
                           if(is.null(args)) {
                               ## create arguments that are missing in every dimension, i.e. represent all
                               args <- rep(list(quote(expr=)), simple_extent$rank)
                           }
                           reg_eval_res <- args_regularity_evaluation(args=args, ds_dims=simple_extent$dims, envir=envir, post_read=FALSE)

                           robj_dim <- private$get_robj_dim(reg_eval_res) 
                           if(any(reg_eval_res$needs_reshuffle)) {
                               ## need to ensure that the input has the right dimensions attached in case it is just a vector)
                               ## and dimensions doesn't need to be reset for data.frames; there they are automatically correct
                               if(!inherits(value, "data.frame")) {
                                   dim(value) <- robj_dim$robj_dim_pre_shuffle
                               }
                               value <- do_reshuffle(value, reg_eval_res)
                           }
                           ## need to check if maximum dimension in indices are larger than dataset dimensions
                           ## if yes need to throw an error
                           if(any(reg_eval_res$max_dims > simple_extent$dims)) {
                               ## need to reset the extent of the arguments
                               if(any(reg_eval_res$max_dims > simple_extent$maxdims)) {
                                   stop("The following coordinates are larger than the largest possible dataset dimensions (maxdims): ",
                                        paste(which(reg_eval_res$max_dims > simple_extent$maxdims), sep=", "))
                               }
                               ## need to check that value conforms to the right dimension for the arguments
                               ## this is needed before a possible expansion of arguments
                               mem_type_id <- standalone_H5D_get_type(h5d_id=self$id, native=TRUE)
                               nelem_value <- .Call("R_guess_nelem", value, mem_type_id, PACKAGE="hdf5r")                               
                               .Call("R_H5Tclose", mem_type_id, PACKAGE = "hdf5r")

                               num_args_elem <- prod(reg_eval_res$result_dims_post_shuffle)
                               if(nelem_value != num_args_elem && (num_args_elem %% nelem_value != 0 || num_args_elem < nelem_value)) {
                                   stop("Number of objects in robj is not the same and not a multiple of number of elements selected in file")
                               }

                               self$set_extent(pmax(reg_eval_res$max_dims, simple_extent$dims))
                               .Call("R_H5Sclose", self_space_id, PACKAGE = "hdf5r")
                               self_space_id <- as.integer64(.Call("R_H5Dget_space", self$id, PACKAGE="hdf5r")$return_val)
                               on.exit(.Call("R_H5Sclose", self_space_id, PACKAGE = "hdf5r"), add=FALSE)
                           }

                           ## create the memory space
                           ## go through all the robj-dimension
                           selection <- regularity_eval_to_selection(reg_eval_res=reg_eval_res) 
                           apply_selection(space_id=self_space_id, selection=selection) 
                           
                           mem_space_dims <- reg_eval_res$result_dims_post_shuffle
                           mem_space_rank <- length(mem_space_dims)
                           
                           mem_space_id <- as.integer64(.Call("R_H5Screate_simple", mem_space_rank, rev(mem_space_dims), rev(mem_space_dims),
                                                 PACKAGE="hdf5r")$return_val)
                           if(mem_space_id < 0) {
                               stop("Error creating simple dataspace")
                           }
                           on.exit(.Call("R_H5Sclose", mem_space_id, PACKAGE = "hdf5r"), add=TRUE)

                           return(self$write_low_level(value, file_space=self_space_id, mem_space=mem_space_id, dataset_xfer_pl=dataset_xfer_pl))
                       }
                   },
                   set_extent=function(dims) {
                       "This function implements the HDF5-API function H5Dset_extent."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_d.html} for details."

                       rank <- self$get_space()$get_simple_extent_ndims()
                       if(length(dims) != rank) {
                           stop(paste("Length of dims is", length(dims), "but has to be equal to the rank of the dataspace:", rank))
                       }
                       res <- .Call("R_H5Dset_extent", self$id, rev(dims), PACKAGE="hdf5r")$return_val
                       if(res < 0) {
                           stop("Error setting new extent")
                       }
                       return(invisible(self))
                   },
                   get_fill_value=function() {
                       "This function implements the HDF5-API function H5Pget_fill_value, automatically"
                       "supplying the datatype of the dataset for convenience."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                       dtype <- self$get_type()
                       create_plist <- self$get_create_plist()
                       value_h5 <- H5ToR_Pre(dtype, 1)
                       res <- .Call("R_H5Pget_fill_value", create_plist$id, dtype$id, value_h5, FALSE, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error retrieving fill value")
                       }
                       return(H5ToR_Post(value_h5, dtype, 1, -1))
                   },
                   create_reference=function(...) {
                       "This function implements the HDF5-API function H5Rcreate. The parameters are interpreted as in '['."
                       "The function always create \\code{H5R_DATASET_REGION} references"
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_r.html} for details."

                       space <- self$get_space()
                       do.call("[", c(list(space), list(...)))
                       
                       ref_type <- h5const$H5R_DATASET_REGION
                       ref_obj <- H5R_DATASET_REGION$new(1, self)
                       
                       res <- .Call("R_H5Rcreate", ref_obj$ref, self$id, ".", h5const$H5R_DATASET_REGION, space$id, FALSE, PACKAGE="hdf5r")
                       if(res$return_val < 0) {
                           stop("Error creating object reference")
                       }
                       ref_obj$ref <- res$ref
                       return(ref_obj)
                   },
                   print=function(..., max.attributes = 10){
                          "Prints information for the dataset"
                          "@param ... ignored"
                          "@param max.attributes Maximum number of attribute names to print"


                          is_valid <- self$is_valid
                          
                          print_class_id(self, is_valid)
                          
                          if(is_valid) {
                              ## get information about the file
                              ## get the dataset name
                              cat("Dataset: ", self$get_obj_name(), "\n", sep="")
                              ## get information about the file
                              this_file <- self$get_file_id()
                              cat("Filename: ", normalizePath(this_file$filename, mustWork=FALSE), "\n", sep="")
                              cat("Access type: ", as.character(this_file$get_intent()), "\n", sep="")
                              this_file$close()
                              ## get attributes
                              print_attributes(self, max_to_print=max.attributes)
                              ## get the datatype
                              this_dtype <- self$get_type()
                              type_text <- this_dtype$to_text()
                              cat("Datatype: ", type_text, "\n", sep="")
                              this_dtype$close()
                              ## get the dataspace
                              this_space <- self$get_space()
                              if(!this_space$is_simple()) {
                                  ## has to be a NULL space
                                  cat("Space: Type=NULL\n")
                              }
                              else {
                                  extent_res <- this_space$get_simple_extent_dims()
                                  if(extent_res$rank == 0) {
                                      cat("Space: Type=Scalar\n")
                                  }
                                  else {
                                      cat("Space: Type=Simple     ")
                                      cat("Dims=", paste(extent_res$dims, collapse=" x "), "     ", sep="")
                                      cat("Maxdims=", paste(extent_res$maxdims, collapse=" x "), "\n", sep="")
                                  }
                              }
                              this_space$close()
                              this_chunk_dims <- self$chunk_dims
                              if(length(this_chunk_dims) == 1 && is.na(this_chunk_dims)) {
                                  cat("Not chunked\n")
                              }
                              else {
                                  cat("Chunk: ", paste(this_chunk_dims, collapse=" x "), "\n", sep="")
                              }
                         }
                          
                          return(invisible(self))
                      }


                   ),
               active=list(
                   dims=function() {
                       "Get the dimension of the dataset"
                       ds_space <- self$get_space()
                       res <- ds_space$dims
                       ds_space$close()
                       return(res)
                   },
                   maxdims=function() {
                       "Get the maximal dimension of the dataset"
                       ds_space <- self$get_space()
                       res <- ds_space$maxdims
                       ds_space$close()
                       return(res)
                   },
                   chunk_dims=function() {
                       "Return the dimension of the chunks. NA if the dataset is not chunked"
                       dataset_create_pl <- self$get_create_plist()
                       ds_space <- self$get_space()
                       ndims <- ds_space$get_simple_extent_ndims()
                       ds_space$close()
                       res <- dataset_create_pl$get_chunk(ndims)
                       dataset_create_pl$close()
                       return(res)
                   },
                   key_info=function() {
                       "Returns the key types as a list, consisting of type, space, dataset_create_pl,"
                       "type_size_raw, type_size_variable, dims and chunk_dims."
                       "type_size_raw versus variable differs for variable length types, which return \\code{Inf}"
                       "for type_size_variable and the underlying size for type_size_raw"
                       ds_space <- self$get_space()
                       ds_type <- self$get_type(native=TRUE)
                       ds_create_pl <- self$get_create_plist()
                       ds_dims <- ds_space$dims
                       return(list(space=ds_space, type=ds_type, create_pl=ds_create_pl,
                                   type_size_raw=ds_type$get_size(variable_as_inf=FALSE), type_size_variable=ds_type$get_size(variable_as_inf=TRUE),
                                   dims=ds_dims, chunk_dims=ds_create_pl$get_chunk(length(ds_dims))))
                   }
                   ),
               private=list(
                   closeFun=function(id) {
                       nrt <- NA
                       if(!is.na(id) && is.loaded("R_H5Dclose", PACKAGE="hdf5r")) {
                           invisible(.Call("R_H5Dclose", id, PACKAGE = "hdf5r"))
                       }
                   },
                   get_robj_dim=function(reg_eval_res) {
                       "Get the size of the resulting R object"
                       ""
                       "For normal objects, just uses the size of the indices in the request, and evaluates"
                       "them bost pre- and post-shuffle. If the internal object is an array, additional dimensions"
                       "are appended at the end."
                       "@title Get the size of the resulting R object"
                       "@param reg_eval_res The result of the regularity evaluation"
                       "@param dtype The datatype under consideration"
                       "@return A list with the dimensions of the resulting object, pre- and post shuffle"
                       "@author Holger Hoefling"
                       "@keywords internal"
                       add_array_dims <- NULL
                       dtype_id <- standalone_H5D_get_type(h5d_id=self$id, native=TRUE)
                       on.exit(.Call("R_H5Tclose", dtype_id, PACKAGE = "hdf5r"), add=TRUE)

                       dtype_cls_id <- .Call("R_H5Tget_class", dtype_id, PACKAGE="hdf5r")$return_val
                       if(dtype_cls_id == h5const$H5T_ARRAY) {
                           ## here we call the function separately for efficiency reasons
                           rank <- .Call("R_H5Tget_array_ndims", dtype_id, PACKAGE="hdf5r")$return_val
                           dims <- integer(rank)
                           add_array_dims <- .Call("R_H5Tget_array_dims2", dtype_id, dims, PACKAGE="hdf5r")$dims
                       }
                       robj_dim_pre_shuffle <- c(reg_eval_res$result_dims_pre_shuffle, add_array_dims)
                       robj_dim_post_shuffle <- c(reg_eval_res$result_dims_post_shuffle, add_array_dims)
                       return(list(robj_dim_pre_shuffle=robj_dim_pre_shuffle,
                                   robj_dim_post_shuffle=robj_dim_post_shuffle, add_array_dims=add_array_dims))
                   }
                   
                   ),
               cloneable=FALSE
               )

R6_set_list_of_items(H5D, "public", commonFGDT, overwrite=TRUE)
R6_set_list_of_items(H5D, "public", commonFGDTA, overwrite=TRUE)



##' Get the id of an H5RefClass
##'
##' If it is a H5RefClass, returns the id, otherwise returns the
##' object itself as it assumes it is already an id.
##' @title Get the id of an H5RefClass
##' @param obj Object to get the id from
##' @return The id itself
##' @author Holger Hoefling
##' @keywords internal
get_id <- function(obj) {
    if(inherits(obj, "H5RefClass")) {
        return(obj$id)
    }
    else {
        return(obj)
    }
}


##' Get the id of a type of the dataset
##'
##' A function that just returns an id; it is written standalone so that
##' one can use it to avoid the creation of R6 classes that be a considerable overhead in
##' certain circumstances
##' @title Get the id of a type of the dataset
##' @param native Should it be ensured that it is a native type
##' @param h5d_id The id of the dataset to get the type from
##' @return An id; the user has to ensure that the id is eventually closed
##' @author Holger Hoefling
##' @keywords internal
standalone_H5D_get_type <- function(h5d_id, native=TRUE) {
    id <- .Call("R_H5Dget_type", h5d_id, PACKAGE="hdf5r")$return_val
    if(id < 0) {
        stop("Error retrieving datatype of dataset")
    }
    if(native) {
        ## return the native type
        id_native <- .Call("R_H5Tget_native_type", id, h5const$H5T_DIR_ASCEND, PACKAGE="hdf5r")$return_val
        ## have the new id, can close the old one
        .Call("R_H5Tclose", id, PACKAGE="hdf5r")
        if(id_native < 0) {
            stop("Error retrieving native-c-type")
        }
        return(id_native)
    }
    else {
        return(id)
    }
}





---
File: /R/R6Classes_H5File.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




##' Open an HDF5 file
##'
##' Open an HDF5 file. \code{a} creates a new file or opens an existing one for read/write. \code{r} opens an
##' existing file for reading, \code{r+} opens an existing file for read/write. \code{w} creates a file, truncating any
##' existing ones and \code{w-}/\code{x} are synonyms, creating a file and failing if it already exists.
##' @title Open an HDF5 file
##' @param name The name of the file to open
##' @param mode The mode how to open the file
##' @param file_create_pl File creation property list
##' @param file_access_pl File access property list
##' @return The file id (64bit-integer)
##' @author Holger Hoefling
##' @keywords internal
H5File.open <-  function(name, mode=c("a", "r", "r+", "w", "w-", "x"), file_create_pl=h5const$H5P_DEFAULT, file_access_pl=h5const$H5P_DEFAULT) {
    check_pl(file_create_pl, "H5P_FILE_CREATE")
    check_pl(file_access_pl, "H5P_FILE_ACCESS")

    stopifnot(is.character(name))
    stopifnot(length(name) == 1)

    mode <- match.arg(mode)
    mode.save <- mode

    filename <- normalizePath(name, mustWork=FALSE)

    ## now do the appropriate thing depending on the mode
    if(mode=="a") { # read/write if exists, create otherwise
        if(file.exists(filename)) {
            if(is_hdf5(name=filename)) {
                mode <- "r+"
            }
            else { # a different type of file; delete it
                mode <- "w"
            }
        }
        else {
            mode <- "w"
        }
    }
    if(mode=="w") { # create file, truncate if exists
        fid <- .Call("R_H5Fcreate", filename, h5const$H5F_ACC_TRUNC, file_create_pl$id, file_access_pl$id, PACKAGE = "hdf5r")$return_val
    }
    else if(mode=="r") { # readonly, file must exist
        fid <- .Call("R_H5Fopen", filename, h5const$H5F_ACC_RDONLY, file_access_pl$id, PACKAGE = "hdf5r")$return_val
    }
    else if(mode=="r+") { # readwrite, file must exist
        fid <- .Call("R_H5Fopen", filename, h5const$H5F_ACC_RDWR, file_access_pl$id, PACKAGE = "hdf5r")$return_val
    }
    else if(mode=="w-" || mode=="x") { # create file, fail if exists
        fid <- .Call("R_H5Fcreate", filename, h5const$H5F_ACC_EXCL, file_create_pl$id, file_access_pl$id, PACKAGE = "hdf5r")$return_val
    }
    else {
        stop("unknown mode")
    }
    if(fid < 0) {
        stop(paste("Error opening file", filename, "in mode", mode.save))
    }
    return(fid)
}

##' Check if a file is an HDF5 file
##'
##' Uses the HDF5 function \code{H5Fis_hdf5} to check if a file is of type HDF5.
##' @title Check if a file is an HDF5 file
##' @param name The name of the file to check
##' @return Logical, TRUE if file is of type HDF5
##' @author Holger Hoefling
##' @export
is_hdf5 <- function(name) {
    res <- .Call("R_H5Fis_hdf5", name, PACKAGE = "hdf5r")
    if(res < 0) {
        stop("Error testing if file is of type hdf5")
    }
    return(as.logical(res))
}


#' Class for interacting with HDF5 files.
#' 
#' \code{H5File} objects are are the main entry point to access HDF5 data from binary 
#' files. This class represents an open HDF5 File-id. It inherits all functions 
#' of the \code{\link{H5RefClass}}.
#' 
#' HDF5 files can be opened or generated using the \code{H5File$new()} function and
#' a specified file access mode. \code{H5File$new()} returns a \code{H5File} object
#' which can be used to access \code{\link{H5Group}}s and Datasets (see \code{\link{H5D}})
#' using subsetting parameters or according class methods.
#' 
#' HDF5 files which have been created or opened through \code{H5File$new()} need 
#' to be closed afterwards using \code{$close_all()}. \code{$close_all()} not only closes the file itself,
#' but also all objects that are still open inside it (such as groups or datasets). \code{$flush()} can be used 
#' to flush unwritten data to an HDF5 file. 
#' 
#' HDF5 Files typically contain the following objects:
#' \describe{
#'   \item{Groups}{Similar to a file system folder, used to organize HDF5 objects in a hierarchical way, see also \code{\link{H5Group}}}
#'   \item{Datasets}{Objects to store actual data, see also \code{\link{H5D}}}
#'   \item{Attributes}{Meta data objects to store extra information about Files, Groups and Datasets, see also \code{\link{H5A}}}
#' }
#' 
#' @section Extract/List File Contents:
#' The following functions are defined to extract HDF5 file contents:
#' \describe{
#'   \item{\code{\link{list.groups}}}{List HDF5 groups in file.}
#'   \item{\code{\link{list.datasets}}}{List HDF5 datasets in file.}
#'   \item{\code{\link{names}}}{List all items in a file or group (applicable for \code{\link{H5File}} and \code{\link{H5Group}})}
#'   \item{\code{\link{list.attributes}}}{List Attributes of HDF5 object (file, group or dataset).}
#'   \item{\code{\link{h5attr_names}}}{Attribute names of an HDF5 object; similar to list.attributes}
#' }
#'
#' 
#' @examples
#' # The following examples generates a HDF5 file with the different HDF5 
#' # Objects and shows its contents:
#' fname <- tempfile(fileext = ".h5")
#' file <- H5File$new(fname, mode = "a")
#' file[["testdataset"]] <- 1:10
#' h5attr(file, "testattrib") <- LETTERS[1:10]
#' file$create_group("testgroup")
#' file[["testgroup/testdataset2"]] <- 1:10
#' # Show contents of file
#' file
#' # Close file and delete
#' file$close_all()
#' 
#' # The following example shows hdf5 file contents and how to use them to iterate over HDF5 elements:
#' file <- h5file(fname, mode = "a")
#' sapply(c("testgroup1", "testgroup2", "testgroup3"), file$create_group)
#' file[["testgroup1/testset1"]] <- 1:10
#' file[["testgroup2/testset2"]] <- 11:20
#' file[["testgroup3/testset3"]] <- 21:30
#' 
#' # Extract first 3 elements from each dataset and combine result to matrix
#' sapply(list.datasets(file, recursive = TRUE), function(x) file[[x]][1:3])
#' # Close file
#' file$close_all()
#' file.remove(fname)
#' 
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link{H5File}}.
#' @seealso \code{\link{h5file}}
#' @author Holger Hoefling, Mario Annau
#' @export
H5File <- R6Class("H5File",
                  inherit=H5RefClass,
                  public=list(
                      mode = NULL,
                      filename = NULL,
                      initialize=function(filename=NULL, mode=c("a", "r", "r+", "w", "w-", "x"), file_create_pl=h5const$H5P_DEFAULT,
                          file_access_pl=h5const$H5P_DEFAULT, id=NULL) {
                          "Opens or creates a new HDF5 File"
                          "@param filename Name of the file"
                          "@param mode How to open it. \\code{a} creates a new file or opens an existing one for read/write. \\code{r} opens an"
                          "existing file for reading, \\code{r+} opens an existing file for read/write. \\code{w} creates a file, truncating any"
                          "existing ones and \\code{w-}/\\code{x} are synonyms, creating a file and failing if it already exists."


                          if (is.null(id)) {
                             if (!is.null(filename)) {
                               id <- H5File.open(filename, mode, file_create_pl, file_access_pl)
                             } else {
                               stop("Either filename or id must be given to initialize H5File.")
                             }
                          }

                          super$initialize(id)
                          self$mode <- mode
                          self$filename <- self$get_filename()
                      },
                      get_obj_count=function(types=h5const$H5F_OBJ_ALL) {
                          "This function implements the HDF5-API function H5Fget_obj_count."
                          "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."
                          count <- .Call("R_H5Fget_obj_count", self$id, types, PACKAGE = "hdf5r")$return_val
                          if(count < 0) {
                              stop("Couldn't get object count in file")
                          }
                          return(count)
                      },
                      get_obj_ids=function(types=h5const$H5F_OBJ_ALL) {
                          "This function implements the HDF5-API function H5Fget_obj_ids."
                          "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."

                          count <- self$get_obj_count(types=types)
                          res <- .Call("R_H5Fget_obj_ids", self$id, types, count, request_empty(count), PACKAGE = "hdf5r")
                          if(res$return_val != count) {
                              stop("Did not receive expected number of objects")
                          }
                          obj_ids <- res$obj_id_list
                          return(obj_ids)
                      },
                      get_filesize=function() {
                          "This function implements the HDF5-API function H5Fget_filesize."
                          "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."

                          res <- .Call("R_H5Fget_filesize", self$id, request_empty(1), PACKAGE = "hdf5r")
                          if(res$return_val < 0) {
                              stop("Error retrieving the file size")
                          }
                          return(res$size)
                      },
                      file_info=function() {
                          "This function implements the HDF5-API function H5Fget_info2."
                          "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."
                          "Please note that the returned information differs if HDF5 Version 1.8.16 or HDF5 Version >= 1.10.0 is being used"

                          if(is.loaded("R_H5Fget_info2", PACKAGE = "hdf5r")) {
                              res <- .Call("R_H5Fget_info2", self$id, request_empty(1), PACKAGE = "hdf5r")
                              if(res$return_val < 0) {
                                  stop("Error getting object info")
                              }
                              return(res$finfo)
                          }
                          else {
                              res <- .Call("R_H5Fget_info", self$id, request_empty(1), PACKAGE = "hdf5r")
                              if(res$return_val < 0) {
                                  stop("Error getting object info")
                              }
                              return(res$bh_info)
                          }
                      },
                      get_intent=function() {
                          "This function implements the HDF5-API function H5Fget_intent."
                          "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_f.html} for details."

                          res <- .Call("R_H5Fget_intent", self$id, request_empty(1), PACKAGE="hdf5r")
                          if(res$return_val < 0) {
                              stop("Error retrieving the file size")
                          }
                          h5f_acc <- h5const$H5F_ACC
                          intent <- factor_ext(res$intent, values=values(h5f_acc), levels=levels(h5f_acc))
                          return(intent)
                      },
                      close_all=function(close_self=TRUE) {
                          "Closes the file, flushes it and also closes all open objects that are still open in it. This is the recommended way of"
                          "closing any file. If not all objects in a file are closed, the file remains open and cannot be re-opened the regular way."

                          ## first trigger the garbage collection, so that lost, but not yet collected objects are closed
                          gc()
                          obj_ids <- self$get_obj_ids()
                          ## need to flush before closing objects; the file itself is returned as an object,
                          ## so would close the file before we can flush
                          self$flush()
                          obj_ids <- obj_ids[obj_ids != self$id]
                          for(i in seq_along(obj_ids)) {
                              H5_close_any(obj_ids[i])
                              rm_obj(obj_ids[i])
                          }
                          if(close_self) {
                              H5_close_any(self$id)
                              rm_obj(self$id)
                          }
                          return(invisible(self))
                      },
                      ## close=function(all=TRUE) {
                      ##     "Closes an object and calls the appropriate HDF5 function for the type of object"
                      ##     "@param all Closes all open objects of the file"
                      ##     if(self$is_valid) {
                      ##         if(all) {
                      ##             self$close_all(close_self=TRUE)
                      ##         }
                      ##         else {
                      ##             id <- private$pid$id
                      ##             private$closeFun(id)
                      ##             decr_count(id)
                      ##         }
                      ##         private$pid <- NA
                      ##     }
                      ##     return(invisible(self))
                      ## }
                      print=function(..., max.attributes=10, max.listing=10){
                          "Prints information for the file"
                          "@param max.attributes Maximum number of attribute names to print"
                          "@param max.listing Maximum number of ls-items to print"
                          "@param ... ignored"

                          is_valid <- self$is_valid
                          
                          print_class_id(self, is_valid)

                          if(is_valid) {
                              cat("Filename: ", normalizePath(self$filename, mustWork=FALSE), "\n", sep="")
                              cat("Access type: ", as.character(self$get_intent()), "\n", sep="")
                              print_attributes(self, max_to_print=max.attributes)
                              print_listing(self, max_to_print=max.listing)
                          }
                          
                          return(invisible(self))
                      }
                      ),
                  private=list(
                      closeFun=function(id) {
                          if(!is.na(id) && is.loaded("R_H5Fclose", PACKAGE="hdf5r")) {
                              ## potential call to ensure that all objects inside a file are closed
                              ## self$close_all(close_self=FALSE)
                              invisible(.Call("R_H5Fclose", id, PACKAGE = "hdf5r"))
                          }
                      }
                      ),
                  cloneable = FALSE
                  )


R6_set_list_of_items(H5File, "public", commonFG, overwrite=TRUE)
R6_set_list_of_items(H5File, "active", commonFG_active, overwrite=TRUE)
R6_set_list_of_items(H5File, "public", commonFGT, overwrite=TRUE)
R6_set_list_of_items(H5File, "public", commonFGDT, overwrite=TRUE)
R6_set_list_of_items(H5File, "public", commonFGDTA, overwrite=TRUE)




##' Closes any HDF5 id using the appropriate library function
##'
##' Internal function to help with management of open ids. It is used to close
##' an id that is no longer needed using the appropriate HDF5 library function.
##' @title Closes any HDF5 id using the appropriate library function
##' @param id The id to closes
##' @return NULL, invisibly
##' @author Holger Hoefling
##' @keywords internal
H5_close_any <- function(id) {
    if(!is.na(id)) {
        type <-  as.character(.Call("R_H5Iget_type", id, PACKAGE="hdf5r")$return_val)

        ## get the reference count, and close it as often as it is open
        ref_count <- try(.Call("R_H5Iget_ref", id, PACKAGE="hdf5r")$return_val, silent=TRUE)

        if(inherits(ref_count, "try-error")) {
            return(invisible(NULL))
        }
        for(i in seq_len(ref_count)) {
            herr <- switch(type,
                           H5I_FILE=.Call("R_H5Fclose", id, PACKAGE="hdf5r"),
                           H5I_GROUP=.Call("R_H5Gclose", id, PACKAGE="hdf5r"),
                           H5I_DATATYPE=.Call("R_H5Tclose", id, PACKAGE="hdf5r"),
                           H5I_DATASET=.Call("R_H5Dclose", id, PACKAGE="hdf5r"),
                           H5I_DATASPACE=.Call("R_H5Sclose", id, PACKAGE="hdf5r"),
                           H5I_ATTR=.Call("R_H5Aclose", id, PACKAGE="hdf5r"),
                           H5I_REFERENCE=.Call("R_H5Rclose", id, PACKAGE="hdf5r"),
                           H5I_VFL=stop("Type H5I_VFL; can't close"),
                           H5I_GENPROP_CLS=.Call("R_H5Pclose_class", id, PACKAGE="hdf5r"),
                           H5I_GENPROP_LST=.Call("R_H5Pclose", id, PACKAGE="hdf5r"),
                           stop("Unknown type; can't close"))

            if(herr < 0) {
                stop(paste("Error closing id", id, "of type", type))
            }
        }
    }
    return(invisible(NULL))
}






---
File: /R/R6Classes_H5Group.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################








##' Class for representing HDF5 groups
##' 
##' HDF5-Groups are essentially equivalent to directories in a file system. Inside the groups, other groups or datasets can
##' be created. For the most parts, groups behave like files, so please also look at the documentation of \code{H5File}.
##' 
##' @docType class
##' @importFrom R6 R6Class
##' @return Object of class \code{\link{H5Group}}. 
##' @export
##' @author Holger Hoefling
##' @examples
##' fname <- tempfile(fileext = ".h5")
##' file <- H5File$new(fname, mode = "a")
##' group <- file$create_group("testgroup")
##' group$print()
##' group$close()
##' file$close_all()
H5Group <- R6Class("H5Group",
                   inherit=H5RefClass,
                   public=list(
                       print=function(..., max.attributes=10, max.listing=10){
                           "Prints information for the group"
                           "@param max.attributes Maximum number of attribute names to print"
                           "@param max.listing Maximum number of ls-items to print"
                           "@param ... ignored"

                           is_valid <- self$is_valid

                           print_class_id(self, is_valid)
                           if(is_valid) {
                               cat("Filename: ", normalizePath(self$get_filename(), mustWork=FALSE), "\n", sep="")
                               cat("Group: ", self$get_obj_name(), "\n", sep="")
                               print_attributes(self, max_to_print=max.attributes)
                               print_listing(self, max_to_print=max.listing)
                           }
                           return(invisible(self))
                       }
            
                       ),
                   private=list(
                       closeFun=function(id) if(!is.na(id) && is.loaded("R_H5Gclose", PACKAGE="hdf5r")) {
                          invisible(.Call("R_H5Gclose", id, PACKAGE = "hdf5r"))}
                       ),
                   cloneable = FALSE
               )

R6_set_list_of_items(H5Group, "public", commonFG, overwrite=TRUE)
R6_set_list_of_items(H5Group, "active", commonFG_active, overwrite=TRUE)
R6_set_list_of_items(H5Group, "public", commonFGT, overwrite=TRUE)
R6_set_list_of_items(H5Group, "public", commonFGDT, overwrite=TRUE)
R6_set_list_of_items(H5Group, "public", commonFGDTA, overwrite=TRUE)


##' Wrap an HDF5-id in the appropriate class
##'
##' This particular factory dispatches ids that can be of type Group, Datatype of dataset (these are
##' id types that can be the result of opening an object. For datatypes, the \code{\link{H5T_factory}} exists that can be used
##' @title Wrap an HDF5-id in the appropriate class
##' @param id The id to wrap in an R6 object
##' @return An R6 object corresponding to the HDF5 internal class of the ID
##' @author Holger Hoefling
##' @keywords internal
H5GTD_factory <- function(id) {
    ## find out the type, then stick it into the correct R6 (or send to the next factory)
    res <- .Call("R_H5Iget_type", id, PACKAGE = "hdf5r")$return_val
    res <- as.character(res)
    if(res == "H5I_BADID") {
        stop("Can identify object")
    }
    obj <- switch(res, H5I_FILE=H5File$new(id), H5I_GROUP=H5Group$new(id), H5I_DATATYPE=H5T_factory(id), H5I_DATASET=H5D$new(id),
           stop(paste("Can't open an R6 class object for the given type", res)))
    return(obj)
}



---
File: /R/R6Classes_H5P.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################


##' Create an \code{\link{H5P}} out of an id
##'
##' Function that determines the property list type of an id and creates
##' the appropriate class for it.
##' @title Create an \code{\link{H5P}} out of an id
##' @param id The id to wrap inside an object
##' @return An object of class \code{\link{H5P}}
##' @author Holger Hoefling
##' @keywords internal
H5P_factory <- function(id) {
    if(inherits(id, "H5P_CLASS")) {
        cls_id <- id$id
        id <- .Call("R_H5Pcreate", cls_id, PACKAGE="hdf5r")$return_val
        if(id < 0) {
            stop("Error creating new property list")
        }
    }
    else if(id %in% h5const$H5P) {
        cls_id <- id
        id <- .Call("R_H5Pcreate", cls_id, PACKAGE="hdf5r")$return_val
        if(id < 0) {
            stop("Error creating new property list")
        }
    }
    else {
        ## we don't create a full object, so need to take care of closing it ourselves
        ## it is also temporary and not to be returned
        cls_id <- .Call("R_H5Pget_class", id, PACKAGE="hdf5r")$return_val
        on.exit(.Call("R_H5Pclose_class", cls_id, PACKAGE="hdf5r"))
    }

    h5p_equal <- function(id1, id2) {
        htri <- .Call("R_H5Pequal", id1, id2, PACKAGE="hdf5r")
        if(htri < 0) {
            stop("Error comparing the ids")
        }
        return(as.logical(htri))
    }

    if(h5p_equal(cls_id, h5const$H5P_DATASET_CREATE)) {
        obj <- H5P_DATASET_CREATE$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_DATASET_ACCESS)) {
        obj <- H5P_DATASET_ACCESS$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_DATASET_XFER)) {
        obj <- H5P_DATASET_XFER$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_LINK_CREATE)) {
        obj <- H5P_LINK_CREATE$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_LINK_ACCESS)) {
        obj <- H5P_LINK_ACCESS$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_OBJECT_CREATE)) {
        obj <- H5P_OBJECT_CREATE$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_OBJECT_COPY)) {
        obj <- H5P_OBJECT_COPY$new(id=id)
    }
    else if(h5p_equal(cls_id, h5const$H5P_ATTRIBUTE_CREATE)) {
        obj <- H5P_ATTRIBUTE_CREATE$new(id=id)
    }
    else {
        obj <- H5P$new(id=id)

    }
    return(obj)
}

#' Class for HDF5 property lists.
#'
#' This is the base class for all property lists, but most have a specialized class.
#' It inherits all functions of the
#' \code{\link{H5RefClass}}. It is also the base class for many other classes, specifically
#' \describe{
#' \item{Dataset Creation}{\code{\link{H5P_DATASET_CREATE}}}
#' \item{Dataset Access}{\code{\link{H5P_DATASET_ACCESS}}}
#' \item{Dataset Transfer}{\code{\link{H5P_DATASET_XFER}}}
#' \item{Link Creation}{\code{\link{H5P_LINK_CREATE}}}
#' \item{Link Access}{\code{\link{H5P_LINK_ACCESS}}}
#' \item{Object Creation}{\code{\link{H5P_OBJECT_CREATE}}}
#' \item{Object Copy}{\code{\link{H5P_OBJECT_COPY}}}
#' \item{Attribute Creation}{\code{\link{H5P_ATTRIBUTE_CREATE}}}
#' }
#' The base class is unlikely to be needed by users - they should use the appropriate subclass required.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link{H5P}}.
#' @author Holger Hoefling
#' @examples 
#' fname <- tempfile(fileext = ".h5")
#' file <- H5File$new(fname, mode = "a")
#' file[["testdataset"]] <- 1:10
#' p <- file[["testdataset"]]$get_create_plist()
#' p$get_class()
#' p$get_class_name()
#' p$copy()
#' p$equal(p)
#' file$close_all()
#' @export
H5P <- R6Class("H5P",
               inherit=H5RefClass,
               public=list(
                   initialize=function(id=NULL) {
                       "Create a new property list; this function itself is unlikely to be needed by users. Users should"
                       "use the classes of the type they actually require"
                       "@param id Internal use only"
                       if(is.null(id)) {
                           stop("Can't create H5P object without id")
                       }
                       super$initialize(id)
                   },
                   get_class=function() {
                       "This function implements the HDF5-API function H5Pget_class."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                       id <- .Call("R_H5Pget_class", self$id, PACKAGE="hdf5r")$return_val
                       return(H5P_CLASS$new(id=id))
                   },
                   get_class_name=function() {
                       "This function implements the HDF5-API function H5Pget_class_name."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                       cls <- self$get_class()
                       cls_name <- .Call("R_H5Pget_class_name", cls$id, PACKAGE="hdf5r")$return_val
                       return(cls_name)
                   },
                   copy=function() {
                       "This function implements the HDF5-API function H5Pcopy."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                       propid <- .Call("R_H5Pcopy", self$id, PACKAGE="hdf5r")$return_val
                       return(H5P_factory(id=propid))
                   },
                   equal=function(cmp) {
                       "This function implements the HDF5-API function H5Pequal."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                       if(!inherits(cmp, "H5P")) {
                           stop("cmp has to be of class H5P")
                       }
                       htri <- .Call("R_H5Pequal", self$id, cmp$id, PACKAGE="hdf5r")
                       if(htri < 0) {
                           stop("Error comparing the ids")
                       }
                       return(as.logical(htri))
                   }
                   ),
               private=list(
                   closeFun=function(id) if(!is.na(id) && is.loaded("R_H5Pclose", PACKAGE="hdf5r")) {
                          invisible(.Call("R_H5Pclose", id, PACKAGE = "hdf5r"))}
                   ),
               cloneable=FALSE
               )


#' Class for default values for HDF5 property lists.
#'
#' This class represents default values for H5P property lists. As with \code{\link{H5S_ALL}}, the current choice is not optimal
#' for the same reasons and likely to be changed
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link{H5P}}.
#' @author Holger Hoefling
#' @keywords internal
H5P_DEFAULT <- R6Class("H5P_DEFAULT",
                       inherit=H5P,
                       public=list(
                           initialize=function(id=NULL) {
                               private$pid <- new_id_obj(id)
                               return(self)
                           },
                           print=function(...) {
                               "Just prints that it is the default class"
                               "@param ... ignored"
                               cat("H5P_DEFAULT class\n")
                               return(invisible(self))
                           }
                           ),
                       private=list(
                           closeFun=identity
                           ),
                       cloneable=FALSE
                       )


#' Class for HDF5 property list classes (not HDF5 property lists)
#'
#' It inherits all functions of the \code{\link{H5RefClass}}. The intent of this class is to
#' provide a mechanism to compare the class of HDF5 property classes. This is mainly intended for internal use
#' to get the class type of an HDF5 identifier that is known to be a property list, but not of which type.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_CLASS]{H5P_CLASS}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_CLASS <- R6Class("H5P_CLASS",
                     inherit=H5RefClass,
                     public=list(
                         equal=function(cmp) {
                             "This function implements the HDF5-API function H5Pequal."
                             "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                             if(inherits(cmp, "H5P_CLASS")) {
                                 cls_id <- cmp$id
                             }
                             else if(cmp %in% h5const$H5P) {
                                 cls_id <- cmp
                             }
                             else {
                                 stop("cmp has to be of class H5P_CLASS or a class id from h5const$H5P")
                             }
                             htri <- .Call("R_H5Pequal", self$id, cls_id, PACKAGE="hdf5r")
                             if(htri < 0) {
                                 stop("Error comparing the ids")
                             }
                             return(as.logical(htri))
                         }
                         ),
                     private=list(
                         closeFun=function(id) if(!is.na(id) && is.loaded("R_H5Pclose", PACKAGE="hdf5r")) {
                             invisible(.Call("R_H5Pclose_class", id, PACKAGE = "hdf5r"))}
                         ),
                     cloneable=FALSE)




#' Class for HDF5 property list for file creation
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_FILE_CREATE]{H5P_FILE_CREATE}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_FILE_CREATE <-  R6Class("H5P_FILE_CREATE",
                              inherit=H5P,
                              public=list(
                                  initialize=function(id=NULL) {
                                      "Create a new class of type \\code{\\link{H5P_FILE_CREATE}}"
                                      "@param id Internal use only"

                                      if(is.null(id)) {
                                          id <- .Call("R_H5Pcreate", h5const$H5P_FILE_CREATE, PACKAGE="hdf5r")$return_val
                                          if(id < 0) {
                                              stop("Error creating new property list")
                                          }
                                      }
                                      super$initialize(id)
                                  },
                                  set_userblock=function(size) {
                                      "This function implements the HDF5-API function H5Pset_userblock."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      ## ensure that it is a power of 2 with exponen >= 9
                                      log2_size <- log2(size)
                                      if(2^round(log2_size) != size) {
                                          stop("size has to be a power of 2")
                                      }
                                      if(size != 0 && size < 512) {
                                          stop("size has to bei either 0 or a power of 2 >= 512")
                                      }
                                      herr <- .Call("R_H5Pset_userblock", self$id, size, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting userblock")
                                      }
                                      return(invisible(self))
                                  },
                                  get_userblock=function() {
                                      "This function implements the HDF5-API function H5Pget_userblock."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_userblock", self$id, request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving user-block size")
                                      }
                                      return(res$size)
                                  },
                                  set_sizes=function(sizeof_addr, sizeof_size) {
                                      "This function implements the HDF5-API function H5Pset_sizes."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      if(!sizeof_addr %in% c(0, 2, 4, 8, 16)) {
                                          stop(paste("sizeof_addr has to be one of 0, 2, 4, 8, or 16"))
                                      }
                                      if(!sizeof_size %in% c(0, 2, 4, 8, 16)) {
                                          stop(paste("sizeof_size has to be one of 0, 2, 4, 8, or 16"))
                                      }
                                      herr <- .Call("R_H5Pset_sizes", self$id, sizeof_addr, sizeof_size, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting size")
                                      }
                                      return(invisible(self))
                                  },
                                  get_sizes=function() {
                                      "This function implements the HDF5-API function H5Pget_sizes."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_sizes", self$id, request_empty(1), request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving user-block size")
                                      }
                                      return(list(sizeof_addr=res$sizeof_addr, sizeof_size=res$sizeof_size))
                                  },
                                  set_sym_k=function(ik, lk) {
                                      "This function implements the HDF5-API function H5Pset_sym_k."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_sym_k", self$id, ik, lk, PACKAGE="hdf5r")$return_val
                                      return(invisible(self))
                                  },
                                  get_sym_k=function() {
                                      "This function implements the HDF5-API function H5Pget_sym_k."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_sym_k", self$id, request_empty(1), request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving user-block size")
                                      }
                                      return(list(ik=res$ik, lk=res$lk))
                                  },
                                  set_istore_k=function(ik) {
                                      "This function implements the HDF5-API function H5Pset_istore_k."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_istore_k", self$id, ik, PACKAGE="hdf5r")$return_val
                                      return(invisible(self))
                                  },
                                  get_istore_k=function() {
                                      "This function implements the HDF5-API function H5Pget_istore_k."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_istore_k", self$id, request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving user-block size")
                                      }
                                      return(res$ik)
                                  },
                                  set_file_space=function(strategy, threshold) {
                                      "This function implements the HDF5-API function H5Pset_file_space."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      if(compareVersion(h5version(verbose=FALSE), "1.10.0") < 0) {
                                          stop("Function only available for 1.10.0 or higher")
                                      }
                                      else {
                                          herr <- .Call("R_H5Pset_file_space", self$id, strategy, threshold, PACKAGE="hdf5r")$return_val
                                          return(invisible(self))
                                      }
                                  },
                                  get_file_space=function() {
                                      "This function implements the HDF5-API function H5Pget_file_space."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      if(compareVersion(h5version(verbose=FALSE), "1.10.0") < 0) {
                                          stop("Function only available for 1.10.0 or higher")
                                      }
                                      else {
                                          res <- .Call("R_H5Pget_file_space", self$id, request_empty(1), request_empty(1), PACKAGE="hdf5r")
                                          if(res$return_val < 0) {
                                              stop("Error retrieving user-block size")
                                          }
                                          return(res)
                                          return(list(strategy=res$strategy, threshold=res$threshold))
                                      }
                                  }
                                  ),
                              cloneable=FALSE
                              )




#' Class for HDF5 property list for file creation
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_FILE_ACCESS]{H5P_FILE_ACCESS}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_FILE_ACCESS <-  R6Class("H5P_FILE_ACCESS",
                              inherit=H5P,
                              public=list(
                                  initialize=function(id=NULL) {
                                      "Create a new class of type \\code{\\link{H5P_FILE_ACCESS}}"
                                      "@param id Internal use only"

                                      if(is.null(id)) {
                                          id <- .Call("R_H5Pcreate", h5const$H5P_FILE_ACCESS, PACKAGE="hdf5r")$return_val
                                          if(id < 0) {
                                              stop("Error creating new property list")
                                          }
                                      }
                                      super$initialize(id)
                                  },
                                  set_cache=function(rdcc_nslots=521, rdcc_nbytes=2^20, rdcc_w0=0.75) {
                                      "This function implements the HDF5-API function H5Pset_cache."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_cache", self$id, 0, rdcc_nslots, rdcc_nbytes, rdcc_w0, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting chunk cache")
                                      }
                                      return(self)
                                  },
                                  get_cache=function() {
                                      "This function implements the HDF5-API function H5Pget_cache."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_cache", self$id, 0, request_empty(1), request_empty(1), request_empty(1),
                                                    PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving chunk cache parameters")
                                      }
                                      return(res[c("rdcc_nslots", "rdcc_nbytes", "rdcc_w0")])
                                  }
                                  ),
                              cloneable=FALSE
                              )



#' Class for HDF5 property list for dataset creation
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_DATASET_CREATE]{H5P_DATASET_CREATE}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_DATASET_CREATE <- R6Class("H5P_DATASET_CREATE",
                              inherit=H5P,
                              public=list(
                                  initialize=function(id=NULL) {
                                      "Create a new class of type \\code{\\link{H5P_DATASET_CREATE}}"
                                      "@param id Internal use only"

                                      if(is.null(id)) {
                                          id <- .Call("R_H5Pcreate", h5const$H5P_DATASET_CREATE, PACKAGE="hdf5r")$return_val
                                          if(id < 0) {
                                              stop("Error creating new property list")
                                          }
                                      }
                                      super$initialize(id)
                                  },
                                  set_layout=function(layout=h5const$H5D_CHUNKED) {
                                      "This function implements the HDF5-API function H5Pset_layout."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_layout", self$id, layout, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting layout")
                                      }
                                      return(invisible(self))
                                  },
                                  get_layout=function() {
                                      "This function implements the HDF5-API function H5Pget_layout."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      layout <- .Call("R_H5Pget_layout", self$id, PACKAGE="hdf5r")$return_val
                                      if(layout < 0) {
                                          stop("Error getting layout")
                                      }
                                      return(layout)
                                  },
                                  set_chunk=function(chunk) {
                                      "This function implements the HDF5-API function H5Pset_chunk."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_chunk", self$id, length(chunk), rev(chunk), PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting chunk")
                                      }
                                      return(invisible(self))
                                  },
                                  get_chunk=function(max_ndims) {
                                      "This function implements the HDF5-API function H5Pget_chunk."
                                      "If the layout is not chunked, returns NA."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      layout <- self$get_layout()
                                      if(as.character(layout)!="H5D_CHUNKED") {
                                          return(NA)
                                      }
                                      res <- .Call("R_H5Pget_chunk", self$id, max_ndims, request_empty(max_ndims), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error getting chunk")
                                      }
                                      return(rev(res$dim))
                                  },
                                  set_deflate=function(level) {
                                      "This function implements the HDF5-API function H5Pset_deflate."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      if(level < 0 || level > 9) {
                                          stop("Compression level has to be between 0 and 9")
                                      }
                                      herr <- .Call("R_H5Pset_deflate", self$id, level, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting deflate")
                                      }
                                      return(self)
                                  },
                                  set_fill_value=function(dtype, value) {
                                      "This function implements the HDF5-API function H5Pset_fill_value."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      check_class(dtype, "H5T")
                                      ## value needs to be converted to an h5 object
                                      value_h5 <- RToH5(value, dtype, 1)
                                      herr <- .Call("R_H5Pset_fill_value", self$id, dtype$id, value_h5, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting fill value")
                                      }
                                      return(self)
                                  },
                                  get_fill_value=function(dtype) {
                                      "This function implements the HDF5-API function H5Pget_fill_value."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      check_class(dtype, "H5T")
                                      value_h5 <- H5ToR_Pre(dtype, 1)
                                      res <- .Call("R_H5Pget_fill_value", self$id, dtype$id, value_h5, FALSE, PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving fill value")
                                      }
                                      return(H5ToR_Post(value_h5, dtype, 1))
                                  },
                                  set_fill_time=function(fill_time=h5const$H5D_FILL_TIME_IFSET) {
                                      "This function implements the HDF5-API function H5Pset_fill_time."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_fill_time", self$id, fill_time, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting fill_time")
                                      }
                                      return(invisible(self))
                                  },
                                  get_fill_time=function() {
                                      "This function implements the HDF5-API function H5Pget_fill_time."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_fill_time", self$id, request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error getting fill_time")
                                      }
                                      return(res$fill_time)
                                  },
                                  set_alloc_time=function(alloc_time=h5const$H5D_ALLOC_TIME_DEFAULT) {
                                      "This function implements the HDF5-API function H5Pset_alloc_time."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_alloc_time", self$id, alloc_time, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error on setting alloc_time")
                                      }
                                      return(invisible(self))
                                  },
                                  get_alloc_time=function() {
                                      "This function implements the HDF5-API function H5Pget_alloc_time."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      res <- .Call("R_H5Pget_alloc_time", self$id, request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error getting alloc_time")
                                      }
                                      return(res$alloc_time)
                                  },
                                  set_filter=function(filter=h5const$H5Z_FILTER_DEFLATE, flags=h5const$H5Z_FLAG_OPTIONAL, cd_values=integer(0)) {
                                      "This function implements the HDF5-API function H5Pset_filter."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_filter", self$id, filter, flags, length(cd_values), cd_values,
                                                    PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter")
                                      }
                                      return(invisible(self))
                                  },
                                  all_filters_avail=function() {
                                      "This function implements the HDF5-API function H5Pall_filters_avail."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      htri <- .Call("R_H5Pall_filters_avail", self$id, PACKAGE="hdf5r")$return_val
                                      if(htri < 0) {
                                          stop("Error checking if all filters are available")
                                      }
                                      return(as.logical(htri))
                                  },
                                  get_nfilters=function() {
                                      "This function implements the HDF5-API function H5Pget_nfilters."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      nfilters <- .Call("R_H5Pget_nfilters", self$id, PACKAGE="hdf5r")$return_val
                                      if(nfilters < 0) {
                                          stop("Error retrieving number of filters")
                                      }
                                      return(nfilters)
                                  },
                                  get_filter=function(idx) {
                                      "This function implements the HDF5-API function H5Pget_filter2."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      num_filters <- self$get_nfilters()
                                      if(idx < 0 || idx >= num_filters) {
                                          stop(paste("idx has to be >= 0 and <", num_filters))
                                      }
                                      namelen <- 60
                                      char_buf <- paste(rep(" ", namelen), collapse="")
                                      res <- .Call("R_H5Pget_filter2", self$id, idx, request_empty(1),
                                                   0, request_empty(0), namelen, char_buf, request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error retrieving filter")
                                      }
                                      cd_nelmts <- res$cd_nelmts
                                      res <- .Call("R_H5Pget_filter2", self$id, idx, request_empty(1),
                                                   cd_nelmts, request_empty(cd_nelmts), namelen, char_buf, request_empty(1), PACKAGE="hdf5r")
                                      ## here the return value is not a factor, need to build it ourselves
                                      if(res$return_val < 0) {
                                          stop("Error retrieving filter")
                                      }
                                      filter_id <- res$return_val
                                      res$return_val <- NULL
                                      h5z_filter <- h5const$H5Z_FILTER
                                      filter_id <- factor_ext(filter_id, values=values(h5z_filter), levels=levels(h5z_filter))
                                      res$filter <- filter_id
                                      return(res)
                                  },
                                  modify_filter=function(filter=h5const$H5Z_FILTER_DEFLATE, flags=h5const$H5Z_FLAG_OPTIONAL, cd_values=integer(0)) {
                                      "This function implements the HDF5-API function H5Pmodify_filter."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pmodify_filter", self$id, filter, flags, length(cd_values), cd_values,
                                                    PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter")
                                      }
                                      return(invisible(self))
                                  },
                                  remove_filter=function(filter=h5const$H5Z_FILTER_ALL) {
                                      "This function implements the HDF5-API function H5Premove_filter."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Premove_filter", self$id, filter, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error removing filter")
                                      }
                                      return(invisible(self))
                                  },
                                  set_fletcher32=function() {
                                      "This function implements the HDF5-API function H5Pset_fletcher32."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_fletcher32", self$id, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter fletcher32")
                                      }
                                      return(invisible(self))
                                  },
                                  set_nbit=function() {
                                      "This function implements the HDF5-API function H5Pset_nbit."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_nbit", self$id, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter nbit")
                                      }
                                      return(invisible(self))
                                  },
                                  set_scaleoffset=function(scale_type=h5const$H5Z_SO_FLOAT_DSCALE, scale_factor=0) {
                                      "This function implements the HDF5-API function H5Pset_scaleoffset."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_scaleoffset", self$id, scale_type, scale_factor, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter scaleoffset")
                                      }
                                      return(invisible(self))
                                  },
                                  set_shuffle=function() {
                                      "This function implements the HDF5-API function H5Pset_shuffle."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_shuffle", self$id, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter shuffle")
                                      }
                                      return(invisible(self))
                                  },
                                  set_szip=function() {
                                      "This function implements the HDF5-API function H5Pset_szip."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_szip", self$id, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting filter szip")
                                      }
                                      return(invisible(self))
                                  },
                                  set_external=function(filename, offset, size) {
                                      "This function implements the HDF5-API function H5Pset_external."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      herr <- .Call("R_H5Pset_external", self$id, filename, offset, size, PACKAGE="hdf5r")$return_val
                                      if(herr < 0) {
                                          stop("Error setting external file")
                                      }
                                      return(invisible(self))
                                  },
                                  get_external_count=function() {
                                      "This function implements the HDF5-API function H5Pget_external_count."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      count <- .Call("R_H5Pget_external_count", self$id, PACKAGE="hdf5r")$return_val
                                      if(count < 0) {
                                          stop("Error setting external file")
                                      }
                                      return(count)
                                  },
                                  get_external=function(idx) {
                                      "This function implements the HDF5-API function H5Pget_external."
                                      "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                      num_external <- self$get_external_count()
                                      if(idx < 0 || idx >= num_external) {
                                          stop(paste("idx has to be >= 0 and <", num_external))
                                      }
                                      max_filename_len <- 65536
                                      filename_buf <- paste(rep(" ", max_filename_len), collapse="")
                                      res <- .Call("R_H5Pget_external", self$id, idx, max_filename_len, filename_buf, request_empty(1),
                                                   request_empty(1), PACKAGE="hdf5r")
                                      if(res$return_val < 0) {
                                          stop("Error getting external file information")
                                      }
                                      return(res[c("name", "offset", "size")])
                                  }
                                  ),
                              cloneable=FALSE
                              )



#' Class for HDF5 property list for dataset access
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_DATASET_ACCESS]{H5P_DATASET_ACCESS}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_DATASET_ACCESS <- R6Class("H5P_DATASET_ACCESS",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_DATASET_ACCESS, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                       }
                                   }
                                   super$initialize(id)
                               },
                               set_chunk_cache=function(rdcc_nslots=-1, rdcc_nbytes=-1, rdcc_w0=-1) {
                                   "This function implements the HDF5-API function H5Pset_chunk_cache."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_chunk_cache", self$id, rdcc_nslots, rdcc_nbytes, rdcc_w0, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting chunk cache")
                                   }
                                   return(invisible(self))
                               },
                               get_chunk_cache=function() {
                                   "This function implements the HDF5-API function H5Pget_chunk_cache."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_chunk_cache", self$id, request_empty(1), request_empty(1),
                                                request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error retrieving chunk cache information")
                                   }
                                   res$return_val <- NULL
                                   return(res)
                               }
                               ),
                           cloneable=FALSE
                           )

#' Class for HDF5 property list for dataset transfer
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_DATASET_XFER]{H5P_DATASET_XFER}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_DATASET_XFER <- R6Class("H5P_DATASET_XFER",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   "Create a new class of type \\code{\\link{H5P_DATASET_XFER}}"
                                   "@param id Internal use only"

                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_DATASET_XFER, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                          }
                                   }
                                   super$initialize(id)
                               },
                               set_buffer=function(size=2^20) {
                                   "This function implements the HDF5-API function H5Pset_buffer."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   tconv <- raw(0)
                                   bkg <- raw(0)
                                   herr <- .Call("R_H5Pset_buffer", self$id, size, tconv, bkg, FALSE, FALSE, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting buffer for type conversion and background")
                                   }
                                   return(invisible(self))
                               },
                               set_edc_check=function(check=h5const$H5Z_ENABLE_EDC) {
                                   "This function implements the HDF5-API function H5Pset_edc_check."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_edc_check", self$id, check, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting edc check")
                                   }
                                   return(invisible(self))
                               },
                               get_edc_check=function() {
                                   "This function implements the HDF5-API function H5Pget_edc_check."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   check <- .Call("R_H5Pget_edc_check", self$id, PACKAGE="hdf5r")$return_val
                                   if(check < 0) {
                                       stop("Error getting edc check")
                                   }
                                   return(check)
                               },
                               set_hyper_vector_size=function(size=2^10) {
                                   "This function implements the HDF5-API function H5Pset_hyper_vector_size."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_hyper_vector_size", self$id, size, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting edc check")
                                   }
                                   return(invisible(self))
                               },
                               get_hyper_vector_size=function() {
                                   "This function implements the HDF5-API function H5Pget_hyper_vector_size."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_hyper_vector_size", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting hyper vector size")
                                   }
                                   return(res$size)
                               },
                               set_btree_ratios=function(left, middle, right) {
                                   "This function implements the HDF5-API function H5Pset_btree_ratios."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_btree_ratios", self$id, left, middle, right, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting btree ratios")
                                   }
                                   return(invisible(self))
                               },
                               get_btree_ratios=function() {
                                   "This function implements the HDF5-API function H5Pget_btree_ratios."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_btree_ratios", self$id, request_empty(1), request_empty(1),
                                                request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting hyper vector size")
                                   }
                                   return(list(left=res$left, middle=res$middle, right=res$right))
                               }
                               ),
                           cloneable=FALSE
                           )




#' Class for HDF5 property list for link creation
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_LINK_CREATE]{H5P_LINK_CREATE}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_LINK_CREATE <- R6Class("H5P_LINK_CREATE",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   "Create a new class of type \\code{\\link{H5P_LINK_CREATE}}"
                                   "@param id Internal use only"

                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_LINK_CREATE, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                          }
                                   }
                                   super$initialize(id)
                               },
                               set_char_encoding=function(encoding=h5const$H5T_CSET_UTF8) {
                                   "This function implements the HDF5-API function H5Pset_char_encoding."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_char_encoding", self$id, encoding, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting char encoding")
                                   }
                                   return(invisible(self))
                               },
                               get_char_encoding=function() {
                                   "This function implements the HDF5-API function H5Pget_char_encoding."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_char_encoding", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting encoding")
                                   }
                                   return(res$encoding)
                               },
                               set_create_intermediate_group=function(create=TRUE) {
                                   "This function implements the HDF5-API function H5Pset_create_intermediate_group."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_create_intermediate_group", self$id, create, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting flag for creating intermediate groups")
                                   }
                                   return(invisible(self))
                               },
                               get_create_intermediate_group=function() {
                                   "This function implements the HDF5-API function H5Pget_create_intermediate_group."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_create_intermediate_group", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting intermediate group creation flag")
                                   }
                                   return(as.logical(res$crt_intmd))
                               }
                               ),
                           cloneable=FALSE
                           )


#' Class for HDF5 property list for link access
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_LINK_ACCESS]{H5P_LINK_ACCESS}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_LINK_ACCESS <- R6Class("H5P_LINK_ACCESS",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   "Create a new class of type \\code{\\link{H5P_LINK_ACCESS}}"
                                   "@param id Internal use only"

                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_LINK_ACCESS, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                          }
                                   }
                                   super$initialize(id)
                               },
                               set_nlinks=function(nlinks) {
                                   "This function implements the HDF5-API function H5Pset_nlinks."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_nlinks", self$id, nlinks, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting nlinks")
                                   }
                                   return(invisible(self))
                               },
                               get_nlinks=function() {
                                   "This function implements the HDF5-API function H5Pget_nlinks."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_nlinks", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting nlinks")
                                   }
                                   return(res$nlinks)
                               },
                               set_elink_prefix=function(elink_prefix) {
                                   "This function implements the HDF5-API function H5Pset_elink_prefix."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_elink_prefix", self$id, elink_prefix, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting elink_prefix")
                                   }
                                   return(invisible(self))
                               },
                               get_elink_prefix=function() {
                                   "This function implements the HDF5-API function H5Pget_elink_prefix."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   prefix_size <- .Call("R_H5Pget_elink_prefix", self$id, character(0), 0, PACKAGE="hdf5r")$return_val
                                   if(prefix_size < 0) {
                                       stop("Error getting prefix size")
                                   }
                                   char_buf <- paste(rep(" ", prefix_size+1), collapse="")
                                   res <- .Call("R_H5Pget_elink_prefix", self$id, char_buf, prefix_size+1, PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting elink_prefix")
                                   }
                                   return(res$prefix)
                               },
                               set_elink_acc_flags=function(elink_acc_flags=h5const$H5F_ACC_RDWR) {
                                   "This function implements the HDF5-API function H5Pset_elink_acc_flags."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_elink_acc_flags", self$id, elink_acc_flags, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting elink_acc_flags")
                                   }
                                   return(invisible(self))
                               },
                               get_elink_acc_flags=function() {
                                   "This function implements the HDF5-API function H5Pget_elink_acc_flags."
                                   "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_elink_acc_flags", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting elink_acc_flags")
                                   }
                                   out <- res$flags
                                   out <- factor_ext(out, values=values(h5const$H5F_ACC), levels=levels(h5const$H5F_ACC))
                                   return(out)
                               }

                               ),
                           cloneable=FALSE
                           )


#' Class for HDF5 property list for object creation
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_OBJECT_CREATE]{H5P_OBJECT_CREATE}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_OBJECT_CREATE <- R6Class("H5P_OBJECT_CREATE",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   "Create a new class of type \\code{\\link{H5P_OBJECT_CREATE}}"
                                   "@param id Internal use only"

                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_OBJECT_CREATE, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                          }
                                   }
                                   super$initialize(id)
                               },
                               set_obj_track_times=function(track_times=TRUE) {
                                   "This function implements the HDF5-API function H5Pset_obj_track_times. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_obj_track_times", self$id, track_times, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting track_times")
                                   }
                                   return(invisible(self))
                               },
                               get_obj_track_times=function() {
                                   "This function implements the HDF5-API function H5Pget_obj_track_times. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_obj_track_times", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting track_times")
                                   }
                                   return(as.logical(res$track_times))
                               },
                               set_attr_phase_change=function(max_compact, min_dense) {
                                   "This function implements the HDF5-API function H5Pset_attr_phase_change. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_attr_phase_change", self$id, max_compact, min_dense, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting attribute phase change")
                                   }
                                   return(invisible(self))
                               },
                               get_attr_phase_change=function() {
                                   "This function implements the HDF5-API function H5Pget_attr_phase_change. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_attr_phase_change", self$id, request_empty(1), request_empty(1),PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting attribute phase change")
                                   }
                                   return(list(max_compact=res$max_compact, min_dense=res$min_dense))
                               },
                               set_attr_creation_order=function(crt_order_flags=0) {
                                   "This function implements the HDF5-API function H5Pset_attr_creation_order. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_attr_creation_order", self$id, crt_order_flags, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting attribute creation order")
                                   }
                                   return(invisible(self))
                               },
                               get_attr_creation_order=function() {
                                   "This function implements the HDF5-API function H5Pget_attr_creation_order. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_attr_creation_order", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting attribute creation order")
                                   }
                                   out <- res$crt_order_flag
                                   return(out)
                               }
                               ),
                           cloneable=FALSE
                           )


#' Class for HDF5 property list for object copying
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_OBJECT_COPY]{H5P_OBJECT_COPY}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_OBJECT_COPY <- R6Class("H5P_OBJECT_COPY",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   "Create a new class of type \\code{\\link{H5P_OBJECT_COPY}}"
                                      "@param id Internal use only"

                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_OBJECT_COPY, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                          }
                                   }
                                   super$initialize(id)
                               },
                               set_copy_obj=function(copy_options=0) {
                                   "This function implements the HDF5-API function H5Pset_copy_object. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_copy_object", self$id, copy_options, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting attribute creation order")
                                   }
                                   return(invisible(self))
                               },
                               get_copy_obj=function() {
                                   "This function implements the HDF5-API function H5Pget_copy_object. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_copy_object", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting attribute creation order")
                                   }
                                   out <- res$crt_intmd
                                   return(out)
                               }
                               ),
                           cloneable=FALSE)



#' Class for HDF5 property list for attribute creation
#'
#' It inherits all functions of the \code{\link{H5P}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5P_ATTRIBUTE_CREATE]{H5P_ATTRIBUTE_CREATE}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5P]{H5P}}
H5P_ATTRIBUTE_CREATE <- R6Class("H5P_ATTRIBUTE_CREATE",
                           inherit=H5P,
                           public=list(
                               initialize=function(id=NULL) {
                                   "Create a new class of type \\code{\\link{H5P_ATTRIBUTE_CREATE}}"
                                   "@param id Internal use only"

                                   if(is.null(id)) {
                                       id <- .Call("R_H5Pcreate", h5const$H5P_ATTRIBUTE_CREATE, PACKAGE="hdf5r")$return_val
                                       if(id < 0) {
                                           stop("Error creating new property list")
                                          }
                                   }
                                   super$initialize(id)
                               },
                               set_char_encoding=function(encoding=h5const$H5T_CSET_UTF8) {
                                   "This function implements the HDF5-API function H5Pset_char_encoding. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   herr <- .Call("R_H5Pset_char_encoding", self$id, encoding, PACKAGE="hdf5r")$return_val
                                   if(herr < 0) {
                                       stop("Error setting char encoding")
                                   }
                                   return(invisible(self))
                               },
                               get_char_encoding=function() {
                                   "This function implements the HDF5-API function H5Pget_char_encoding. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_p.html} for details."

                                   res <- .Call("R_H5Pget_char_encoding", self$id, request_empty(1), PACKAGE="hdf5r")
                                   if(res$return_val < 0) {
                                       stop("Error getting encoding")
                                   }
                                   return(res$encoding)
                               }
                               ),
                           cloneable=FALSE
                           )



---
File: /R/R6Classes_H5R.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################






setOldClass("H5R")
setOldClass("H5R_OBJECT")
setOldClass("H5R_DATASET_REGION")


ref_obj_size <- new.env()


#' Class for HDF5 Reference datatypes. 
#'
#' \code{H5R} is only the common base class and is never used. User should not create objects of this
#' class by themselves and instead use the \code{create_reference} methods of \code{H5D}, \code{H5Group} or \code{H5File} classes.
#' Sub-classes are \code{\link{H5R_OBJECT}} and \code{\link{H5R_DATASET_REGION}}
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5R]{H5R}}.
#' @author Holger Hoefling
#' @examples
#' fname <- tempfile(fileext = ".h5")
#' file <- H5File$new(fname, mode = "a")
#' file[["testset"]] <- matrix(rnorm(9), nrow = 3)
#' dset <- file[["testset"]]
#' r <- file$create_reference("testset")
#' file$close_all()
#' @export
H5R <- R6Class("H5R",
               inherit=H5RefClass,
               public=list(
                   subset_read=function(dim_index, drop=TRUE) {
                       "Method that returns a subset of the data in the H5R-object"
                       "@param dim_index A list of dimension indices as usually pasted into \\code{[}"
                       "@param drop Logical. Should dimensions of size 1 be dropped."
                       if(!is.list(dim_index)) {
                           dim_index <- list(dim_index)
                       }
                       
                       if(length(dim_index) != self$rank && length(dim_index) != 1) {
                           stop("dim_index has to have the same length as the dimension of the object (or 1 as vector access)")
                       }
                       ## will do a very simple implementation for now; more sophisticated to come later
                       dummy_array <- 0:(self$length-1)
                       if(self$rank > 1) {
                           dim(dummy_array) <- private$pdim
                           dimnames(dummy_array) <- private$pdimnames
                       }
                       else {
                           names(dummy_array) <- private$pnames
                       }

                       ## TODO check if this is needed; 
                       ## replace NULL with missing so that the internal subsetting will work as expected
                       for(i in seq_along(args)) {
                           if(is.null(dim_index[[i]])) {
                               dim_index[i] <- list(bquote(expr=))
                           }
                       }

                       subset_ind <- do.call("[", c(list(dummy_array), dim_index, list(drop=drop)))
                       if(any(is.na(subset_ind))) {
                           stop("NA in subset not allowed")
                       }

                       ref_subset <- .Call("R_read_raw_subset_generic", private$pref, subset_ind, private$size, PACKAGE="hdf5r")

                       h5r_sub <- self$clone()
                       h5r_sub$ref <- ref_subset
                       h5r_sub$dim <- dim(subset_ind)
                       h5r_sub$dimnames <- dimnames(subset_ind)
                       h5r_sub$names <- names(subset_ind)

                       return(h5r_sub)
                   },
                   subset2_read=function(i, exact=TRUE) {
                       "Method to read a single item"
                       "@param i The single item to read"
                       "@param exact Is the item name exact or should partial matching be allowed?"

                       if(length(i) != 1) {
                           stop("can only read single element")
                       }

                       if(is.character(i)) {
                           if(exact) {
                               i <- match(i, private$pnames) - 1
                           }
                           else {
                               i <- pmatch(i, private$pnames) - 1
                           }
                           if(is.na(i)) {
                               stop("Element could not be found")
                           }
                           
                       }
                       else {
                           i <- as.numeric(i) - 1
                           if(is.na(i)) {
                               stop("NA not allowed")
                           }
                       }

                       ref_subset <- .Call("R_read_raw_subset_generic", private$pref, i, private$size, PACKAGE="hdf5r")

                       h5r_sub <- self$clone()
                       h5r_sub$ref <- ref_subset
                       h5r_sub$dim <- NULL
                       h5r_sub$dimnames <- NULL
                       h5r_sub$names <- NULL

                       return(h5r_sub)
                   },
                   subset_assign=function(dim_index, value) {
                       "Assign values into a subset of the H5R-vector"
                       "@param dim_index A list of dimension indices as usually passed into \\code{[}"
                       "@param value The value to assign"
                       if(inherits(value, "H5R")) {
                           value <- value$ref
                       }
                       else if(!is.raw(value)) {
                           stop("Value has to inherit form 'H5R' or be a raw vector")
                       }
                                              
                       if(!is.list(dim_index)) {
                           dim_index <- list(dim_index)
                       }

                       ## TODO check if this is needed; 
                       ## check that is has the correct dimension
                       if(length(dim_index) != self$rank && length(dim_index) != 1) {
                           stop("dim_index has to have the same length as the dimension of the object (or 1 as vector access)")
                       }
                       ## will do a very simple implementation for now; more sophisticated to come later
                       dummy_array <- 0:(self$length-1)
                       if(self$rank > 1) {
                           dim(dummy_array) <- private$pdim
                           dimnames(dummy_array) <- private$pdimnames
                       }
                       else {
                           names(dummy_array) <- private$pnames
                       }

                       ## replace NULL with missing so that the internal subsetting will work as expected
                       for(i in seq_along(args)) {
                           if(is.null(dim_index[[i]])) {
                               dim_index[i] <- list(bquote(expr=))
                           }
                       }

                       subset_ind <- do.call("[", c(list(dummy_array), dim_index, list(drop=drop)))
                       ## check that value has the correct size
                       if(length(value) != length(subset_ind) * private$size) {
                           stop("value does not have the correct size")
                       }
                       
                       private$pref <- .Call("R_write_raw_subset_generic", private$pref, value, subset_ind, private$size, PACKAGE="hdf5r")

                       return(self)
                   },
                   subset2_assign=function(i, exact=TRUE, value) {
                       "Assign a value to a single value in the array"
                       "@param i the index where to assign the value"
                       "@param value The value to assign"
                       if(inherits(value, "H5R")) {
                           value <- value$ref
                       }
                       else if(!is.raw(value)) {
                           stop("Value has to inherit form 'H5R' or be a raw vector")
                       }
                       
                       if(length(i) != 1) {
                           stop("can only read single element")
                       }
                       
                       if(is.character(i)) {
                           if(exact) {
                               i <- match(i, private$pnames) - 1
                           }
                           else {
                               i <- pmatch(i, private$pnames) - 1
                           }
                           if(is.na(i)) {
                               stop("Element could not be found")
                           }
                       }
                       else {
                           i <- as.numeric(i) - 1
                           if(is.na(i)) {
                               stop("NA not allowed")
                           }
                       }

                       private$pref <- .Call("R_write_raw_subset_generic", private$pref, value, i, private$size, PACKAGE="hdf5r")

                       return(self)
                   },
                   t=function() {
                       "Transpose the object if it is a matrix (i.e. has rank 2"
                       ## we want to transpose it; check that it is a matrix
                       if(length(private$pdim) != 2) {
                           stop("Not a matrix; can't transpose")
                       }

                                             
                       private$pref <- .Call("R_transpose_general", private$pref, private$pdim, private$size, PACKAGE="hdf5r")
                       private$pdim <- rev(private$pdim)
                       private$pdimnames <- rev(private$pdimnames)
                       return(self)
                   }
                   ),
               active=list(
                   length=function() {
                       "Get the length of the object"
                       return(length(private$pref) / private$size)
                   },
                   ref=function(ref) {
                       "Get or assign the internal raw-vector representation of the data. Usually, user's shouldn't have to use this."
                       if(missing(ref)) {
                           return(private$pref)
                       }
                       else {
                           if(length(ref) != length(private$pref)) {
                               private$pdim <- NULL
                               private$pdimnames <- NULL
                               private$pnames <- NULL
                           }
                           if(!is.raw(ref)) {
                               stop("The references has to be a vector of type raw")
                           }
                           if(length(ref) %% private$size != 0) {
                               stop("ref has to be a length that is a multiple of the base size")
                           }
                           private$pref <- ref
                           return(self)
                       }
                   },
                   dim=function(x) {
                       "Get or assign the dimensionality of the object"
                       if(missing(x)) {
                           return(private$pdim)
                       }
                       else {
                           if(length(x) <= 1) {
                               private$pdim <- NULL
                               private$pdimnames <- NULL
                           }
                           else {
                               if(self$length != prod(x)) {
                                   stop("product of dimensions has to be equal to the length of the dataset")
                               }
                               else {
                                   private$pdim <- as.numeric(x)
                               }
                               private$pdimnames <- vector("list", length(x))
                               private$pnames <- NULL
                           }
                           return(self)
                       }
                   },
                   dimnames=function(x) {
                       "Get or assign the dimnames of the object"
                       if(missing(x)) {
                           return(private$pdimnames)
                       }
                       else {
                           if(!(is.null(x) || (is.list(x) && length(x) == self$rank))) {
                               stop("dimnames has to be a list with the same length as the rank of the dataset")
                           }
                           for(i in seq_along(x) ) {
                               x[[i]] <- as.character(x[[i]])
                           }
                           private$pdimnames <- x
                           return(self)
                       }
                   },
                   names=function(x) {
                       "Get or assign the names of the object"
                       if(missing(x)) {
                           return(private$pnames)
                       }
                       else {
                           if(!(is.null(x) || length(x) == self$length)) {
                               stop("names has to have the same length as x")
                           }
                           if(is.null(x)) {
                               private$pnames <- NULL
                           }
                           else {
                               private$pnames <- as.character(x)
                           }
                       }
                   },
                   rank=function() {
                       "Get the rank of the object"
                       return(max(1, length(private$pdim)))
                   }
                   ),
               private=list(
                   pref=raw(0),
                   size=0,
                   pdim=NULL,
                   pdimnames=NULL,
                   pnames=NULL,
                   closeFun=function(id) {
                          if(!is.na(id) && is.loaded("R_H5Fclose", PACKAGE="hdf5r")) {
                              ## potential call to ensure that all objects inside a file are closed
                              ## self$close_all(close_self=FALSE)
                              invisible(.Call("R_H5Fclose", id, PACKAGE = "hdf5r"))
                          }
                      }
                   ),
               cloneable = FALSE
               )

ref_func_clone_public <- list(
    clone=function() {
        self$inc_ref()
        ## during initialization, the internal counter in R is increased; as this is
        ## not the case here, so has to be increased manually
        incr_count(as.integer64(self$id))
        cloned_obj <- private$pclone()
        reg.finalizer(cloned_obj, function(e) { e$close()}, onexit=TRUE)
        return(cloned_obj)
    }
    )
R6_set_list_of_items(H5R, "private", list(pclone=H5R$clone_method), overwrite=TRUE)
R6_set_list_of_items(H5R, "public", ref_func_clone_public, overwrite=TRUE)



#' Class for HDF5 Object-references. 
#'
#' \code{H5R_OBJECT} is the reference class for objects. Users should not create this class by themselves, but use the appropriate 
#' and instead use the \code{create_reference} methods of \code{H5D}, \code{H5Group} or \code{H5File} classes.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5R_OBJECT]{H5R_OBJECT}}.
#' @export
#' @author Holger Hoefling
H5R_OBJECT <- R6Class("H5R_OBJECT",
                      inherit=H5R,
                      public=list(
                          initialize=function(num=0, id=NULL) {
                              "Create a new reference for object; Usually, users shouldn't have to call this, but use the \\code{create_reference}"
                              "method of a dataset, group of committed datatype"
                              if(inherits(id, "H5File")) {
                                  id$inc_ref()
                                  id <- id$id
                              }
                              else if(inherits(id, "H5RefClass")) {
                                  id <- id$get_file_id()
                                  id$inc_ref()
                                  id <- id$id
                              }
                              super$initialize(id=id)
                              private$size <- ref_obj_size$H5R_OBJECT
                              self$ref <- raw(private$size * num) 
                              return(self)
                          },
                          dereference=function(object_access_pl=h5const$H5P_DEFAULT, obj=NULL) {
                              "Dereference an H5R reference. The file the reference is pointing to is assigned automatically"
                              "This function implements the HDF5-API function H5Rdereference."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_r.html} for details."
                              "@param obj Overriding the default file the reference is referring to"
                              "@param object_access_pl The object-access property list. Currently always the default"

                              res <- vector("list", length=self$length)
                              index_vec_end <- private$size * seq_along(res)
                              index_vec_start <- index_vec_end  - private$size + 1
                              if(is.null(obj)) {
                                  deref_id <- self$id
                              }
                              else {
                                  deref_id <- obj$id
                              }
                              if(grepl("^1\\.8\\.", h5version(verbose=FALSE))) {
                                  ## use the old api
                                  for(i in seq_along(res)) {
                                      myref <- private$pref[index_vec_start[i]:index_vec_end[i]]
                                      id <- .Call("R_H5Rdereference",deref_id, h5const$H5R_OBJECT, myref, PACKAGE = "hdf5r")$return_val
                                      res[[i]] <- H5GTD_factory(id)
                                  }
                              }
                              else {
                                  ## use the new api
                                  for(i in seq_along(res)) {
                                      myref <- private$pref[index_vec_start[i]:index_vec_end[i]]
                                      id <- .Call("R_H5Rdereference2",deref_id, object_access_pl$id, h5const$H5R_OBJECT, myref, PACKAGE = "hdf5r")$return_val
                                      res[[i]] <- H5GTD_factory(id)
                                  }
                              }
                              return(res)
                          }
                          ),
                      cloneable=FALSE
                      )


#' Class for HDF5 dataset-region references. 
#'
#' \code{H5R_DATASET_REGION} is the reference class for dataset regions. Users should not create this class by themselves, but use the appropriate 
#' and instead use the \code{create_reference} methods of \code{H5D}, \code{H5Group} or \code{H5File} classes.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5R_DATASET_REGION]{H5R_DATASET_REGION}}.
#' @export
#' @author Holger Hoefling
H5R_DATASET_REGION <- R6Class("H5R_DATASET_REGION",
                      inherit=H5R,
                      public=list(
                          initialize=function(num=0, id=NULL) {
                              "Create a new reference for dataset regions; Usually, users shouldn't have to call this, but use the "
                              "\\code{create_reference} method of a dataset."
                              if(inherits(id, "H5File")) {
                                  id$inc_ref()
                                  id <- id$id
                              }
                              else if(inherits(id, "H5RefClass")) {
                                  id <- id$get_file_id()
                                  id$inc_ref()
                                  id <- id$id
                              }
                              super$initialize(id=id)
                              private$size <- ref_obj_size$H5R_DATASET_REGION
                              self$ref <- raw(private$size * num) 
                              return(self)
                          },
                          dereference=function(object_access_pl=h5const$H5P_DEFAULT, obj=NULL, get_value=FALSE) {
                              "Dereference an H5R reference for a dataset region. The file the reference is pointing to is assigned automatically."
                              "It returns a list where each item is a list with components \\code{dataset}, being an \\code{H5D} object and"
                              "\\code{space} being a \\code{H5S} object. When setting \\code{get_value=TRUE}, then instead of these objects"
                              "The data itself is returned"
                              "This function implements the HDF5-API function H5Rdereference."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_r.html} for details."
                              "@param obj Overriding the default file the reference is referring to"
                              "@param object_access_pl The object-access property list. Currently always the default"

                              res <- vector("list", length=self$length)
                              index_vec_end <- private$size * seq_along(res)
                              index_vec_start <- index_vec_end  - private$size + 1

                              if(is.null(obj)) {
                                  deref_id <- self$id
                              }
                              else {
                                  deref_id <- obj$id
                              }

                              if(grepl("^1\\.8\\.", h5version(verbose=FALSE))) {
                                  ## use the old api
                                  for(i in seq_along(res)) {
                                      myref <- private$pref[index_vec_start[i]:index_vec_end[i]]
                                      id_ds <- .Call("R_H5Rdereference", deref_id, h5const$H5R_DATASET_REGION, myref, PACKAGE = "hdf5r")$return_val
                                      id_space <- .Call("R_H5Rget_region", deref_id, h5const$H5R_DATASET_REGION, myref, PACKAGE = "hdf5r")$return_val
                                      obj_ds <- H5D$new(id=id_ds)
                                      obj_space <- H5S$new(id=id_space)
                                      if(get_value) {
                                          ## need to determine which dimensionality the output should have
                                          obj_ds_dtype <- obj_ds$get_type()
                                          dim_to_set <- extract_dim(obj_space, obj_ds_dtype)
                                          res[[i]] <- obj_ds$read_low_level(file_space=obj_space, mem_type=obj_ds_dtype, set_dim=TRUE,
                                                                            dim_to_set=dim_to_set)
                                      }
                                      else {
                                          res[[i]] <- list(dataset=obj_ds, space=obj_space)
                                      }
                                  }
                              }
                              else {
                                  ## use the new api
                                  for(i in seq_along(res)) {
                                      myref <- private$pref[index_vec_start[i]:index_vec_end[i]]
                                      id_ds <- .Call("R_H5Rdereference2", deref_id, object_access_pl$id, h5const$H5R_DATASET_REGION,
                                                     myref, PACKAGE = "hdf5r")$return_val
                                      id_space <- .Call("R_H5Rget_region", deref_id, h5const$H5R_DATASET_REGION, myref, PACKAGE = "hdf5r")$return_val
                                      obj_ds <- H5D$new(id=id_ds)
                                      obj_space <- H5S$new(id=id_space)
                                      if(get_value) {
                                          ## need to determine which dimensionality the output should have
                                          obj_ds_dtype <- obj_ds$get_type()
                                          dim_to_set <- extract_dim(obj_space, obj_ds_dtype)
                                          res[[i]] <- obj_ds$read_low_level(file_space=obj_space, mem_type=obj_ds_dtype, set_dim=TRUE,
                                                                            dim_to_set=dim_to_set)
                                      }
                                      else {
                                          res[[i]] <- list(dataset=obj_ds, space=obj_space)
                                      }
                                  }
                              }
                              return(res)
                          }
                          ),
                      cloneable=FALSE
                      )




##' Compare the ids of objects
##'
##' When several \code{H5RefClass} objects are passed in
##' @title Compare the ids of objects
##' @param ... Any \code{H5RefClass} objects
##' @return Logical - are all ids the same of the objects passed in
##' @author Holger Hoefling
##' @keywords internal
##' @importFrom bit64 integer64
equal_id_check <- function(...) {
    objs <- list(...) 

    ids <- integer64(length(objs))
    
    for(i in seq_along(objs)) {
        if(!inherits(objs[[i]], "H5RefClass")) {
            stop("Need to inherit from H5RefClass")
        }
        ids[i] <- objs[[i]]$id
    }

    ## check that they are all equal
    ids <- unique(ids)
    if(length(ids) == 1 && !is.na(ids)) {
        return(TRUE)
    }
    else {
        return(FALSE)
    }
}

## the purpose of the base class is to provide the functionality so that it can behave like a vector, matrix or array

##' Various functions for \code{H5R} objects
##'
##' \describe{
##'   \item{is.H5R}{Check if object inherits from \code{H5R}}
##'   \item{is.H5R_OBJECT}{Check if object inherits from \code{H5R_OBJECT}}
##'   \item{is.H5R_DATASET_REGION}{Check if object inherits from \code{H5R_DATASET_REGION}}
##'   \item{names.H5R}{Returns the names of the elements of the vector}
##'   \item{length.H5R}{Returns the length of the vector}
##'   \item{[.H5R}{Array subsetting function}
##'   \item{[<-.H5R}{Array subset assignment}
##'   \item{c.H5R}{Concatenation of \code{H5R} vectors}
##'   \item{dim.H5R}{Dimensionality of the object}
##'   \item{dim<-.H5R}{Assign dimension of the object}
##'   \item{t.H5R}{Transpose a matrix of \code{H5R} objects}
##'   \item{dimnames.H5R}{Get the dimnames of the object}
##'   \item{dimnames<-.H5R}{Set the dimnames of the object}
##'   \item{cbind.H5R}{cbind functionality for \code{H5R} objects}
##'   \item{rbind.H5R}{rbind functionality for \code{H5R} objects}
##'   \item{print.H5R}{Printing of an object of class \code{h5R}}
##'   \item{format.H5R}{Formatting of an H5R object}
##'   \item{as.data.frame.H5R}{Coerce an \code{H5R} object to a data.frame}
##'   \item{as.vector.H5R}{Coerce to a vector}
##'   \item{as.data.frame.H5R}{Coerces the object to a data.frame}
##'   \item{as.vector.H5R}{Coerces to a vector}
##' }
##' @title Various functions for \code{H5R} objects
##' @param x Object of type \code{H5R}
##' @param i First dimension
##' @param j Second dimension
##' @param ... Any other dimensions (for subsetting), or objects to concatenate (for \code{c})
##' or combine by row/col (for \code{cbind} or \code{rbind}) or ignored (for \code{print} and \code{format})
##' @param drop Should dimensions of size 1 be dropped; LOGICAL
##' @param value The value in an assignment
##' @param recursive Ignored here
##' @param row.names \code{NULL} or a character vector giving the row names for the
##' data frame.  Missing values are not allowed.
##' @param optional logical. If \code{TRUE}, setting row names and converting column
##' names (to syntactic names: see \code{make.names}) is optional.
##' @param nm The column names to use
##' @param width.cutoff ignored
##' @param collapse ignored
##' @param mode Only 'any' supported
##' @param deparse.level integer controlling the construction of labels in the case of non-matrix-like arguments (for the default method):
##' 'deparse.level = 0' constructs no labels; the default, 'deparse.level = 1' constructs labels from the argument
##' names
##' @return Depending on the function
##' @author Holger Hoefling
##' @name H5R_functions
NULL



##' @export
##' @rdname H5R_functions
is.H5R <- function(x) inherits(x, "H5R")

##' @export
##' @rdname H5R_functions
is.H5R_OBJECT <- function(x) inherits(x, "H5R_OBJECT")

##' @export
##' @rdname H5R_functions
is.H5R_DATASET_REGION <- function(x) inherits(x, "H5R_DATASET_REGION")


##' @export
##' @rdname H5R_functions
names.H5R <- function(x) {
    return(x$names)
}


##' @export
##' @rdname H5R_functions
length.H5R <- function(x) {
    return(x$length)
}


##' @export
##' @rdname H5R_functions
'[.H5R' <- function(x, i, j, ..., drop=TRUE) {
    ## take the number of arguments and substract 2 (the functions and x)
    mdrop <- missing(drop)
    Narg <- nargs() - (!mdrop)
    if(Narg == 2) {
        dim_index <- eval(substitute(alist(i, ...)))
    }
    else {
        dim_index <- eval(substitute(alist(i, j, ...)))
    }
    ## check; if j is missing and it is of length 2, then also don't give j
    return(x$subset_read(dim_index, drop=drop))
}


##' @export
##' @rdname H5R_functions
'[<-.H5R' <- function(x, i, ..., value) {
    ## take the number of arguments and substract 3 (the functions, x, and value)
    dim_index <- eval(substitute(alist(i, ...)))

    return(x$subset_assign(dim_index, value=value))
}



## Not possible to include; interferes with the clone method sind R6 2.1.3
## as objects in the clone method are now accessed through [[
## ##' @export
## ##' @rdname subset
## '[[.H5R' <- function(x, i, ..., exact=TRUE) {
##     return(x$subset2_read(i, exact=exact))
## }


## ##' @export
## ##' @rdname subset
## '[[<-.H5R' <- function(x, i, ..., exact=TRUE, value) {
##     return(x$subset2_assign(i, exact=exact, value=value))
## }

##' @export
##' @rdname H5R_functions
c.H5R <- function(..., recursive=FALSE) {
    if(recursive) {
        stop("recursive=TRUE currently not supported") 
    }

    if(!equal_id_check(...)) {
        stop("All objects have to have the same file_id")
    }
    ## check that all objects have the same class
    args <- list(...)

    args_classes <- unlist(lapply(args, function(x) {return(paste(class(x), collapse=","))}))
    if(length(unique(args_classes)) > 1) {
        stop("All objects have to have the same class")
    }

    res <- args[[1]]$clone()

    res_ref <- lapply(args, function(x) x$ref)
    res_ref <- do.call(c, res_ref)

    res_names <- unlist(lapply(args, function(x) {
        x_names <- x$names
        if(is.null(x_names)) {
            x_names <- rep("", x$length)
        }
        return(x_names)
    }))
    
    if(all(res_names=="")) {
        res_names <- NULL
    }

    res$ref <- res_ref
    res$dimnames <- NULL
    res$dim <- NULL
    res$names <- res_names

    return(res)
}

##' @export
##' @rdname H5R_functions
dim.H5R <- function(x) {
    return(x$dim)
}

##' @export
##' @rdname H5R_functions
'dim<-.H5R' <- function(x, value) {
    x$dim <- value
    return(x)
}


## for internal use only; written as I don't know how to access an active function from c-code
set_ref.H5R <- function(x, value) {
    x$ref <- value
    return(x)
}


##' @export
##' @rdname H5R_functions
t.H5R <- function(x) {
    return(x$clone()$t())
}


##' @export
##' @rdname H5R_functions
dimnames.H5R <- function(x) {
    return(x$dimnames)
}

##' @export
##' @rdname H5R_functions
'dimnames<-.H5R' <- function(x, value) {
    x$dimnames <- value
    return(x)
}


##' @export
##' @rdname H5R_functions
cbind.H5R <- function(..., deparse.level=1) {
    if(deparse.level > 1) {
        stop("deparse.level > 1 currently not supported")
    }
    if(!equal_id_check(...)) {
        stop("All objects have to refer to the same underlying file")
    }
    args <- list(...)
    
    ## check that the classes are compatible
    args_classes <- unlist(lapply(args, function(x) {return(paste(class(x), collapse=","))}))
    if(length(unique(args_classes)) > 1) {
        stop("All objects have to have the same class")
    }

    ## check that the dimensions are compatible; all have same number of rows
    args_rank <- unlist(lapply(args, function(x) x$rank))

    if(any(args_rank > 2)) {
        stop("Not all objects have rank 1 or 2")
    }
    ## for any that have rank 1, coerce to a matrix with 1 column
    for(i in which(args_rank==1)) {
        args[[i]]$dim <- c(args[[i]]$length, 1)
    }
    
    args_nrow <- unlist(lapply(args, nrow))

    if(length(unique(args_nrow)) != 1) {
        stop("Not all objects have the same number of rows")
    }
    args_ncol <- unlist(lapply(args, ncol))
    
    ## in this case we just need to concatenate the results
    row_dimnames <- args[[1]]$dimnames[[1]]
    col_dimnames <- unlist(lapply(args, function(x) {
        x_colnames <- x$dimnames[[2]]
        if(is.null(x_colnames)) {
            x_colnames <- rep("", x$length)
        }
        x_colnames
    }))

    res_dimnames <- list(row_dimnames, col_dimnames)
    res_ref <- do.call(c, lapply(args, function(x) x$ref))
    res_dim <- c(args_nrow[1], sum(args_ncol))

    res <- args[[1]]$clone()
    res$ref <- res_ref
    res$dim <- res_dim
    res$dimnames <- res$dimnames

    return(res)
}

##' @export
##' @rdname H5R_functions
rbind.H5R <- function(..., deparse.level=1) {
    if(deparse.level > 1) {
        stop("deparse.level > 1 currently not supported")
    }
    if(!equal_id_check(...)) {
        stop("All objects have to refer to the same underlying file")
    }

    ## currently not very efficient; but will leave as it is for now
    ## high efficiency not necessary for this datatype
    ## not clear how often this function will ever be needed
    args <- list(...)
    args <- lapply(args, function(x) x$clone())
    args <- lapply(args, function(x) x$t())
    res <- do.call(cbind, args)
    return(res$t())
}


##' @export
##' @rdname H5R_functions
print.H5R <- function(x, ...) {
    cat(class(x)[1], " of length ", x$length, "\n")
}


##' @export
##' @rdname H5R_functions
format.H5R <- function(x, ...) {
    rep(paste0("<", class(x)[1], ">"), x$length)
}

##' @export
##' @rdname H5R_functions
as.data.frame.H5R <-  function (x, row.names = NULL, optional = FALSE, ..., nm = paste(deparse(substitute(x), 
    width.cutoff = 500L), collapse = " ")) {
    if(x$rank == 1) {
        return(as.data.frame.vector(x=x, row.names=row.names, optional=optional, ..., nm=nm))
    }
    else {
        return(as.data.frame.matrix(x=x, row.names=row.names, optional=optional, ...))
    }
}


##' @export
##' @rdname H5R_functions
as.vector.H5R <- function(x, mode="any") {
    if(mode != "any") {
        stop("Only mode 'any' supported")
    }
    x <- x$clone()
    x$dim <- NULL
    return(x)
}






---
File: /R/R6Classes_H5S.R
---




#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################








##' Class for representing HDF5 spaces
##' 
##' This class represents \code{Spaces} in HDF5. These are mostly useful to define the
##' dimensions of a dataset as well as the maximum dimensions to which it can grow. By default, the
##' maximum dimension is equal to the initial dimension. If you want the array to be able to grow arbitrarily
##' large in one dimension, set the maximum dimension for this index to \code{Inf}. See the examples below
##' for code how to do this.
##'
##' @docType class
##' @importFrom R6 R6Class
##' @return Object of class \code{\link{H5S}}. 
##' @author Holger Hoefling
##'
##' @examples
##' h5s_fixed <- H5S$new("simple", dims=c(5, 2))
##' h5s_fixed
##' 
##' h5s_variable <- H5S$new("simple", dims=c(5,2), maxdims=c(Inf,2))
##' h5s_variable
##' h5s_variable$set_extent_simple(c(10,2), c(Inf, 2))
##' h5s_variable
##' 
##' # now select a subset of points
##' # argument evaluation has a heuristic; here it chooses point selection
##' h5s_variable[c(1, 3, 8), 1]
##' h5s_variable$get_select_type()
##' h5s_variable$get_select_elem_pointlist()
##' 
##' # and a hyperslab (chosen by the argument heuristic)
##' h5s_variable[2:7, 1:2]
##' h5s_variable$get_select_type()
##' h5s_variable$get_select_hyper_blocklist()
##' @export
H5S <- R6Class("H5S",
               inherit=H5RefClass,
               public=list(
                   initialize=function(type=c("simple", "scalar", "null"), dims=NULL, maxdims=dims, decode_buf=NULL, id=NULL) {
                       "Create a new HDF5-space. This can be done by either specifying a space with appropriate dimensions or by"
                       "decoding a character string that represents an encoded space"
                       "@param type Either a \\code{simple} space, for which \\code{dims} and \\code{maxdims} have to be given"
                       "or a \\code{scalar} or \\code{null} space. See the HDF5 user guide on spaces to explain the differences."
                       "@param dims The dimension of the space in case it is of type \\code{simple}"
                       "@param maxdims The maximal dimensions of the space"
                       "@param decode_buf The character string that holds the encoded representation of a space"
                       "@param id An existing HDF5 id; internal use only"
                       if(is.null(id)) {
                           if(!is.null(decode_buf)) {
                               id <- .Call("R_H5Sdecode", decode_buf, PACKAGE = "hdf5r")$return_val
                           }
                           else {
                               type <- match.arg(type)
                               type <- switch(type, scalar=h5const$H5S_SCALAR, simple=h5const$H5S_SIMPLE, null=h5const$H5S_NULL)
                               
                               if(type!=h5const$H5S_SIMPLE ||(type==h5const$H5S_SIMPLE && (is.null(dims) || is.null(maxdims)))) {
                                   id <- .Call("R_H5Screate", type, PACKAGE = "hdf5r")$return_val
                                   if(id < 0) {
                                       stop("Error creating dataspace")
                                   }
                               }
                               else {
                                   if(is.null(dims)) {
                                       stop("dims cannot be null")
                                   }
                                   rank <- length(dims)
                                   if(length(maxdims) > 0 && length(maxdims) != rank) {
                                       stop("maxdims, if it is not NULL, has to be of the same length as dims")
                                   }
                                   id <- .Call("R_H5Screate_simple", rank, rev(dims), rev(maxdims), PACKAGE="hdf5r")$return_val
                                   if(id < 0) {
                                       stop("Error creating simple dataspace")
                                   }
                               }
                           }
                       }
                       super$initialize(id)
                   },
                   copy=function() {
                       "This function implements the HDF5-API function H5Scopy. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       id <- .Call("R_H5Scopy", self$id, PACKAGE = "hdf5r")$return_val
                       return(H5S$new(id=id))
                   },
                   encode=function() {
                       "This function implements the HDF5-API function H5Sencode. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       ## first retrieve the size of the buffer necessary
                       nalloc <- .Call("R_H5Sencode", self$id, raw(0), numeric(1), FALSE, PACKAGE = "hdf5r")$nalloc
                       ## now get the actual buffer size
                       buf <- raw(nalloc)
                       res <- .Call("R_H5Sencode", self$id, buf, nalloc, FALSE, PACKAGE="hdf5r")
                       herr <- res$return_val
                       if(herr < 0) {
                           stop("Error when encoding the object")
                       }
                       return(res$buf)
                   },
                   is_simple=function() {
                       "This function implements the HDF5-API function H5Sis_simple. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sis_simple", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error when trying to see if dataspace is simple")
                       }
                       return(as.logical(res))
                   },
                   get_simple_extent_ndims=function() {
                       "This function implements the HDF5-API function H5Sget_simple_extent_ndims. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       ndims <- .Call("R_H5Sget_simple_extent_ndims", self$id, PACKAGE = "hdf5r")$return_val
                       if(ndims < 0) {
                           stop("Error when retrieving rank of dataspace")
                       }
                       return(ndims)
                   },
                   offset_simple=function(offset) {
                       "This function implements the HDF5-API function H5Soffset_simple. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       rank <- self$get_simple_extent_ndims()
                       if(length(offset)==0) {
                           offset <- rep(0, rank)
                       }
                       if(length(offset) != rank) {
                           stop(paste("Offset has to be of rank", rank))
                       }
                       res <- .Call("R_H5Soffset_simple", self$id, rev(offset), PACKAGE = "hdf5r")
                       if(res$return_val < 0) {
                           stop("Error when setting offset")
                       }
                       return(invisible(self))
                   },
                   get_simple_extent_dims=function() {
                       "This function implements the HDF5-API function H5Sget_simple_extent_dims. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       return(standalone_H5S_get_simple_extent_dims(self$id))
                   },
                   get_simple_extent_npoints=function() {
                       "This function implements the HDF5-API function H5Sget_simple_extent_npoints. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sget_simple_extent_npoints", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error trying to get number of points in dataspace")
                       }
                       return(res)
                   },
                   get_simple_extent_type=function() {
                       "This function implements the HDF5-API function H5Sget_simple_extent_type. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       return(.Call("R_H5Sget_simple_extent_type", self$id, PACKAGE = "hdf5r")$return_val)
                   },
                   extent_copy=function(h5s_source) {
                       "This function implements the HDF5-API function H5Sextent_copy. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       if(!inherits(h5s_source, "H5S")) {
                           stop("h5s_source has to be of class H5S")
                       }
                       res <- .Call("R_H5Sextent_copy", self$id, h5s_source$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error copying extent of dataspace")
                       }
                       return(invisible(self))
                   },
                   extent_equal=function(h5s_cmp) {
                       "This function implements the HDF5-API function H5Sextent_equal. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       if(!inherits(h5s_cmp, "H5S")) {
                           stop("h5s_source has to be of class H5S")
                       }
                       res <- .Call("R_H5Sextent_equal", self$id, h5s_cmp$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error copying extent of dataspace")
                       }
                       return(as.logical(res))
                   },
                   set_extent_simple=function(dims, maxdims) {
                       "This function implements the HDF5-API function H5Sset_extent_simple. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       rank <- length(dims)
                       if(rank ==0) {
                           stop("current_size has to be of length > 0")
                       }
                       if(length(maxdims) != rank) {
                           stop(paste("maximum_size has to be of same length as current_size, i.e. ", rank))
                       }
                       if(!all(maxdims >= dims)) {
                           stop("Maximum_size has to be greater or equal to current_size")
                       }
                       res <- .Call("R_H5Sset_extent_simple", self$id, rank, rev(dims), rev(maxdims), PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error setting simple extent")
                       }
                       return(invisible(self))
                   },
                   set_extent_none=function() {
                       "This function implements the HDF5-API function H5Sset_extent_none. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sset_extent_none", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error setting simple extent")
                       }
                       return(invisible(self))
                   },
                   get_select_type=function() {
                       "This function implements the HDF5-API function H5Sget_select_type. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sget_select_type", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error getting selection type")
                       }
                       return(res)
                   },
                   get_select_npoints=function() {
                       "This function implements the HDF5-API function H5Sget_select_npoints. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sget_select_npoints", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error getting number of points in selection")
                       }
                       return(res)
                   },
                   get_select_hyper_nblocks=function() {
                       "This function implements the HDF5-API function H5Sget_select_hyper_nblocks. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sget_select_hyper_nblocks", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error getting number of points in selection")
                       }
                       return(res)
                   },
                   get_select_hyper_blocklist=function(startblock=0, numblocks=(self$get_select_hyper_nblocks() - startblock)) {
                       "This function implements the HDF5-API function H5Sget_select_hyper_blocklist. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       rank <- self$get_simple_extent_ndims()
                       ## create a buffer; a buffer of double values provides enough space; function will handle
                       ## appropriate conversion
                       res <- .Call("R_H5Sget_select_hyper_blocklist", self$id, startblock, numblocks, request_empty(rank * 2 * numblocks),
                                    PACKAGE = "hdf5r")
                       if(res$return_val < 0) {
                           stop("Error trying to retrieve blocklist")
                       }
                       ## get the buffer, format as array, reverse the dimensions and return
                       buffer <- res$buf
                       dim(buffer) <- c(rank, 2 * numblocks)
                       for(i in seq_len(ncol(buffer))) {
                           buffer[, i] <- rev(buffer[, i])
                       }
                       ## correct for first element 0
                       buffer <- t(buffer) + 1
                       rownames(buffer) <- paste("block", rep(seq_len(numblocks), each=2), rep(c("start", "end"), times=numblocks), sep="_")
                       return(buffer)
                   },
                   get_select_elem_npoints=function() {
                       "This function implements the HDF5-API function H5Sget_select_elem_npoints. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sget_select_elem_npoints", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error trying to get number of elements in current selection")
                       }
                       return(res)
                   },
                   get_select_elem_pointlist=function(startpoint=0, numpoints=(self$get_select_elem_npoints() - startpoint)) {
                       "This function implements the HDF5-API function H5Sget_select_elem_pointlist. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       rank <- self$get_simple_extent_ndims()
                       ## create a buffer; a buffer of double values provides enough space; function will handle
                       ## appropriate conversion
                       res <- .Call("R_H5Sget_select_elem_pointlist", self$id, startpoint, numpoints, request_empty(rank * numpoints),
                                    PACKAGE = "hdf5r")
                       if(res$return_val < 0) {
                           stop("Error trying to retrieve blocklist")
                       }
                       ## get the buffer, format as array, reverse the dimensions and return
                       buffer <- res$buf
                       dim(buffer) <- c(rank, numpoints)
                       buffer_rev <- buffer
                       for(i in seq_len(rank)) {
                           buffer_rev[i,] <- buffer[rank + 1 - i,]
                       }
                       buffer <- buffer_rev

                       ## correct for first element 0
                       buffer <- t(buffer) + 1
                       return(buffer)
                   },
                   get_select_bounds=function() {
                       "This function implements the HDF5-API function H5Sget_select_bounds. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       rank <- self$get_simple_extent_ndims()
                       start <- integer(rank)
                       end <- integer(rank)
                       res <- .Call("R_H5Sget_select_bounds", self$id, start, end, PACKAGE = "hdf5r")
                       if(res$return_val < 0) {
                           stop("Error trying to get bounding box of selection")
                       }
                       ## correct for first element 0
                       start <- rev(res$start) + 1
                       end <- rev(res$end) + 1
                       return(list(start=start, end=end))
                   },                   
                   select_all=function() {
                       "This function implements the HDF5-API function H5Sselect_all. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sselect_all", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error when selecting all points in dataspace")
                       }
                       return(invisible(self))
                   },
                   select_none=function() {
                       "This function implements the HDF5-API function H5Sselect_none. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sselect_none", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error when reseting selection region")
                       }
                       return(invisible(self))
                   },
                   select_valid=function() {
                       "This function implements the HDF5-API function H5Sselect_valid. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       res <- .Call("R_H5Sselect_valid", self$id, PACKAGE = "hdf5r")$return_val
                       if(res < 0) {
                           stop("Error validating selection")
                       }
                       return(as.logical(res))
                   },
                   select_elements=function(coord, op=h5const$H5S_SELECT_SET, byrow=TRUE) {
                       "This function implements the HDF5-API function H5Sselect_elements. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       standalone_H5S_select_elements(self$id, coord=coord, op=op, byrow=byrow)
                       return(invisible(self))

                   },
                   select_hyperslab=function(start, count, stride=NULL, block=NULL, op=h5const$H5S_SELECT_SET) {
                       "This function implements the HDF5-API function H5Sselect_hyperslab. Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_s.html} for details."

                       standalone_H5S_select_hyperslab(id=self$id, start=start, count=count, stride=stride, block=block, op=op)
                       return(invisible(self))
                   },
                   subset=function(args, op=h5const$H5S_SELECT_SET, envir=parent.frame()) {
                       "Subsetting the space. This is mainly intended as a helper function for the '[' function, but"
                       "can also be used on its own."
                       "@param args The indices for each dimension to subset given as a list. This makes this easier to use as a programmatic API."
                       "For interactive use we recommend the use of the \\code{[} operator."
                       "@param op The operator to use. Same as for the other HDF5 space selection functions. One of the elements shown in"
                       "\\code{h5const$H5S_seloper_t}"
                       "@param envir The environment in which to evaluate \\code{args}"
                       if(!self$is_simple()) {
                           stop("Dataspace has to be simple for a selection to occur")
                       }
                       simple_extent <- self$get_simple_extent_dims()    
                       ## distinguish between scalar and non-scalar
                       if(simple_extent$rank == 0 && self$get_select_npoint() == 1) {
                           ## is a scalar
                           if(!are_args_scalar(args)) {
                               stop("Scalar dataspace; arguments have to be of length 1 and empty or equal to 1")
                           }
                           ## nothing needs to be done; just fall through to the end
                       }
                       else {
                           reg_eval_res <- args_regularity_evaluation(args=args, ds_dims=simple_extent$dims, envir=envir)
                           ## need to check if maximum dimension in indices are larger than dataset dimensions
                           ## if yes need to throw an error
                           if(any(reg_eval_res$max_dims > simple_extent$dims)) {
                               stop("The following coordinates are outside the dataset dimensions: ",
                                    paste(which(reg_eval_res$max_dims > simple_extent$dims), sep=", "))
                           }
                           selection <- regularity_eval_to_selection(reg_eval_res=reg_eval_res) 
                           apply_selection(space_id=self$id, selection=selection)
                       }
                       return(invisible(self))
                   },
                   print=function(...){
                       "Prints information for the group"
                       "@param ... ignored"
                       
                       is_valid <- self$is_valid
                       
                       print_class_id(self, is_valid)

                       if(is_valid) {
                           if(!self$is_simple()) {
                               ## has to be a NULL space
                               cat("Type: NULL\n")
                           }
                           else {
                               extent_res <- self$get_simple_extent_dims()
                               if(extent_res$rank == 0) {
                                   cat("Type: Scalar\n")
                               }
                               else {
                                   cat("Type: Simple\n")
                                   cat("Dims: ", paste(extent_res$dims, collapse=" x "), "\n", sep="")
                                   cat("Maxdims: ", paste(extent_res$maxdims, collapse=" x "), "\n", sep="")
                               }
                           }
                       }
                       return(invisible(self))
                   }
               ),
               active=list(
                   dims=function() {
                       "Get the dimensions of the space. Return NULL if the space is not simple (i.e. NULL-space) or a length-0 integer if it is a scalar"
                       if(!self$is_simple()) {
                           return(NULL)
                       }
                       return(self$get_simple_extent_dims()$dims)
                   },
                   maxdims=function() {
                       "Get the maximal dimensions of the space.Return NULL if the space is not simple (i.e. NULL-space) or a length-0 integer if it is a scalar"
                       if(!self$is_simple()) {
                           return(NULL)
                       }
                       return(self$get_simple_extent_dims()$maxdims)
                   }
                   ),
               private=list(
                   closeFun=function(id) if(!is.na(id) && is.loaded("R_H5Sclose", PACKAGE="hdf5r")) {
                          invisible(.Call("R_H5Sclose", id, PACKAGE = "hdf5r"))}
                   ),
               cloneable = FALSE
               )

## make 'rank' a copy of get_simple_extent_ndims
H5S$set("active", "rank", H5S$public_methods$get_simple_extent_ndims, overwrite=TRUE)



#' Class for HDF5 default space
#'
#' It inherits all functions of the \code{\link{H5S}}. As this is implemented, closing the id is overridden as this is a special id.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5S_ALL]{H5S_ALL}}. 
#' @author Holger Hoefling
#' @keywords internal
#' @seealso \code{\link[=H5S]{H5S}}
H5S_ALL <- R6Class("H5S_ALL",
                       inherit=H5S,
                       public=list(
                           initialize=function(id) {
                               private$pid <- new_id_obj(id)
                               return(self)
                           },
                           print=function(...) {
                               "Just prints that it is the default class"
                               "@param ... ignored"
                               cat("H5S_ALL class\n")
                               return(invisible(self))
                           }
                           ),
                       private=list(
                           closeFun=identity
                           ),
                       cloneable=FALSE
                       )


## some additional functions that either duplicate functionality of the R6 object, but without requiring the
## R6 object. This is intended as a speed improvement

standalone_H5S_get_simple_extent_ndims <- function(id) {
    ndims <- .Call("R_H5Sget_simple_extent_ndims", id, PACKAGE = "hdf5r")$return_val
    if(ndims < 0) {
        stop("Error when retrieving rank of dataspace")
    }
    return(ndims)
}


standalone_H5S_select_elements <- function(id, coord, op=h5const$H5S_SELECT_SET, byrow=TRUE) {
    rank <- standalone_H5S_get_simple_extent_ndims(id)
    
    ## check that coord is an array; is rank=1, also allowed to be a vector
    if(rank==0) {
        stop("Dataspace has no extent; rank 0")
    }
    if(rank==1) {
        num_elem <- length(coord)
    }
    else if(rank==length(coord)) {
        coord <- matrix(coord, ncol=1)
        num_elem <- 1
    }
    else {
        if(byrow) {
            if(!is.matrix(coord)) {
                stop("coord has to be a matrix")
            }
            if(ncol(coord) != rank) {
                stop(paste("Number of columns of coord has to be equal to rank (for byrow=TRUE)", rank))
            }
            num_elem <- nrow(coord)
            coord <- t(coord)
        }
        else {
            if(!is.matrix(coord)) {
                stop("coord has to be a matrix")
            }
            if(nrow(coord) != rank) {
                stop(paste("Number of rows of coord has to be equal to rank (for byrow=FALSE)", rank))
            }
            num_elem <- nrow(coord)
        }
    }
    ## now capture the case when 0 elements are to be set
    if(num_elem == 0) {
        if(op==h5const$H5S_SELECT_SET) {
            ## need to change the selection to None
            herr <- .Call("R_H5Sselect_none", id, PACKAGE = "hdf5r")
            if(herr < 0) {
                stop("Error when setting selection to none")
            }
        }
        else {
            ## nothing to do; as either append of nothing or prepend of nothing (only set; append or prepend possible as operators)
            return(NULL)
        }
    }
    else {
        ## correct for first element 0
        coord <- coord - 1
        ## reverse all the coordinates
        coord_rev <- coord
        for(i in seq_len(rank)) {
            coord_rev[i,] <- coord[rank + 1 - i,]
        }
        coord <- coord_rev
        herr <- .Call("R_H5Sselect_elements", id, op, num_elem, coord, PACKAGE = "hdf5r")
        if(herr < 0) {
            stop("Error when selecting elements")
        }
    }
    return(NULL)
}

standalone_H5S_select_hyperslab <- function(id, start, count, stride=NULL, block=NULL, op=h5const$H5S_SELECT_SET) {

    rank <- standalone_H5S_get_simple_extent_ndims(id=id)
    if(is.null(stride)) {
        stride <- rep(1, rank)
    }
    if(is.null(block)) {
        block <- rep(1, rank)
    }
    if(length(start) != rank) {
        stop(paste("start has to be of the same length as the rank of the dataspace,", rank))
    }
    if(length(stride) != rank) {
        stop(paste("stride has to be of the same length as the rank of the dataspace,", rank))
    }
    if(length(count) != rank) {
        stop(paste("count has to be of the same length as the rank of the dataspace,", rank))
    }
    if(length(block) != rank) {
        stop(paste("block has to be of the same length as the rank of the dataspace,", rank))
    }
    ## correct for first element 0
    start <- start - 1
    herr <- .Call("R_H5Sselect_hyperslab", id, op, rev(start), rev(stride), rev(count), rev(block),
                  PACKAGE = "hdf5r")$return_val
    if(herr < 0) {
        stop("Error when selecting hyperslab")
    }
    return(NULL)
}



##' Select multiple hyperslabs in a space
##'
##' Selects multiple hyperslabs in a space. Before the selection, the space selection will be cleared.
##' @title Select multiple hyperslabs in a space
##' @param id The id of the space
##' @param hyperslab_array The array with the hyperslabs. Is of dimension num_dim x num_hyperslabs x 4. With the elements
##' being start, count, stride and block
##' @return \code{NULL}. The space has been manipulated as a side effect
##' @author Holger Hoefling
##' @keywords internal
standalone_H5S_select_multiple_hyperslab <- function(id, hyperslab_array) {
    num_hyperslabs <- dim(hyperslab_array)[[2]]

    stopifnot(num_hyperslabs > 0)
    
    ## select the first hyperslab
    start <- hyperslab_array[, 1, 1] - 1
    stride <- hyperslab_array[, 1, 3]
    count <- hyperslab_array[, 1, 2]
    block <- hyperslab_array[, 1, 4]
    herr <- .Call("R_H5Sselect_hyperslab", id, h5const$H5S_SELECT_SET, rev(start), rev(stride), rev(count), rev(block),
                  PACKAGE = "hdf5r")$return_val
    if(herr < 0) {
        stop("Error when selecting hyperslab")
    }
    
    
    if(num_hyperslabs > 1) {
        for(i in 2:num_hyperslabs) {
            start <- hyperslab_array[, i, 1] - 1
            stride <- hyperslab_array[, i, 3]
            count <- hyperslab_array[, i, 2]
            block <- hyperslab_array[, i, 4]
            herr <- .Call("R_H5Sselect_hyperslab", id, h5const$H5S_SELECT_OR, rev(start), rev(stride), rev(count), rev(block),
                          PACKAGE = "hdf5r")$return_val
            if(herr < 0) {
                stop("Error when selecting hyperslab")
            }
        }
    }
    return(NULL)
}



standalone_H5S_get_simple_extent_dims=function(id) {
    rank <- standalone_H5S_get_simple_extent_ndims(id)
    res <- suppressWarnings(.Call("R_H5Sget_simple_extent_dims", id, request_empty(rank), request_empty(rank), PACKAGE = "hdf5r"))
    if(res$return_val < 0) {
        stop("Error when retrieving extent of simple dataspace")
    }
    names(res) <- c("rank", "dims", "maxdims")
    res$dims <- rev(res$dims)
    res$maxdims <- rev(res$maxdims)
    return(res)                           
}



---
File: /R/R6Classes_H5T.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################


##' Extract HDF5-ids and return as a vector
##'
##' Internal helper function. Given a list of id-type-objects, it extracts the
##' ids itself and returns them as a vector
##' @title Extract HDF5-ids and return as a vector
##' @param dtype_ids Ids itself or class objects to extract the ids from. 
##' @return The ids as a integer64-vector
##' @author Holger Hoefling
##' @importFrom bit64 as.integer64
##' @keywords internal
H5T_extractID <- function(dtype_ids) {
    if(inherits(dtype_ids, "H5T")) {
        dtype_ids_out <- dtype_ids$id
    }
    else if(is.list(dtype_ids)) {
        for(i in seq_along(dtype_ids)) {
            dtype_ids[[i]] <- H5T_extractID(dtype_ids[[i]])
        }
        dtype_ids_out <- unlist(dtype_ids)
        class(dtype_ids_out) <- "integer64"
    }
    else if(is.numeric(dtype_ids)) {
        if(any(bit64::as.integer64(dtype_ids)  != dtype_ids)) {
            stop("Numeric values cannot be coerced to integer")
        }
        else {
            dtype_ids_out <- bit64::as.integer64(dtype_ids)
            names(dtype_ids_out) <- names(dtype_ids)
        }
    }
    else {
        stop("'dtype_ids' has to be a vector or list with elements of type 'H5T' or integer (or coercible to integer)")
    }
    return(dtype_ids_out)
}


##' Turn ids into  \code{\link{H5T}} objects
##'
##' Gets the HDF5 internal class for an id and dispatches them so that the correct
##' R6es are being created.
##' @title Turn ids into  \code{\link{H5T}} objects
##' @param ids The ids to return as objects
##' @param do_copy Should the ids be copied using HDF5s internal copy mechanism
##' @return An object of type R6 class \code{\link{H5T}}
##' @author Holger Hoefling
##' @importFrom bit64 as.integer64
##' @keywords internal
H5T_factory <- function(ids, do_copy=FALSE) {
    if(!missing(ids)) {
        ids <- H5T_extractID(ids)

        ## look at the ids and their class, and produce the appropriate H5T class
        res <- vector("list", length=length(ids))
        for(i in seq_along(ids)) {
            if(do_copy) {
                foo <- .Call("R_H5Tcopy", bit64::as.integer64(ids[i]), PACKAGE="hdf5r")$return_val
                ids[i] <- foo
            }
            if(is.na(ids[i]) || ids[i] < 0) {
                stop("Invalid ids")
            }
            cls_id <- .Call("R_H5Tget_class", bit64::as.integer64(ids[i]), PACKAGE="hdf5r")$return_val
            if(cls_id == "H5T_NO_CLASS") {
                stop("Unknown cls_id")
            }
            class_name <- as.character(cls_id)

            ## now if it is a compound, need to check if it should be a H5T_COMPLEX
            if(class_name == "H5T_COMPOUND") {
                labels <- .Call("h5get_compound_names", ids[i], PACKAGE="hdf5r")$return_val
                if(length(labels) == 2 && all(labels == c("Real", "Imaginary"))) {
                    class_name <- "H5T_COMPLEX"
                }
            }

            ## if is enum, need to check if it is logical
            if(class_name == "H5T_ENUM") {
                labels = .Call("h5get_enum_labels", ids[i], PACKAGE="hdf5r")$return_val
                values = .Call("h5get_enum_values", ids[i], PACKAGE="hdf5r")$return_val
                if(length(labels) == 3 && length(values) == 3 && all(labels==c("FALSE", "TRUE", "NA")) && all(values==c(0,1,2))) {
                    class_name <- "H5T_LOGICAL"
                }
                else if(length(labels) == 2 && length(values) == 2 && all(labels==c("FALSE", "TRUE")) && all(values==c(0,1))) {
                    class_name <-"H5T_LOGICAL"
                }
            }
                           
            res[[i]] <- switch(class_name, H5T_COMPOUND=H5T_COMPOUND$new(id=ids[i]), H5T_COMPLEX=H5T_COMPLEX$new(id=ids[i]),
                               H5T_ENUM=H5T_ENUM$new(id=ids[i]), H5T_LOGICAL=H5T_LOGICAL$new(id=ids[i]),
                               H5T_ARRAY=H5T_ARRAY$new(id=ids[i]), H5T_STRING=H5T_STRING$new(id=ids[i]),
                               H5T_VLEN=H5T_VLEN$new(id=ids[i]), H5T_INTEGER=H5T_INTEGER$new(id=ids[i]), H5T_FLOAT=H5T_FLOAT$new(id=ids[i]),
                               H5T_BITFIELD=H5T_BITFIELD$new(id=ids[i]),
                               H5T$new(id=ids[i]))
        }
        if(length(ids)==1) {
            return(res[[1]])
        }
        else {
            names(res) <- names(ids)
            return(res)
        }
    }
    else {
        return(list())
    }
}

##' Convert a text description to a datatype
##'
##' Converts a text to a datatype using the HDF5 function H5LT_text_to_dtype. 
##' @title Convert a text description to a datatype
##' @param text The text to convert to the datatype
##' @param lang_type The type of language to use; currently only \code{H5LT_DDL} is supported.
##' @return A datatype corresponding to the text with the appropriate class inheriting from \code{\link{H5T}}.
##' @author Holger Hoefling
##' @export
text_to_dtype <- function(text, lang_type=h5const$H5LT_DDL) {
    id <- .Call("R_H5LTtext_to_dtype", paste(as.character(text), collapse = "\n"), h5const$H5LT_DDL, PACKAGE = "hdf5r")$return_val
    if(id < 0) {
        stop("Error trying to convert text to a datatype")
    }
    return(H5T_factory(ids=id))
}


#' Class for HDF5 datatypes.
#'
#' This is the base class for all datatypes, but most have a specialised class.
#' This class represents an HDF5 datatype. It inherits all functions of the
#' \code{\link{H5RefClass}}. It is also the base class for many other classes well, specifically
#' \describe{
#' \item{Integer}{\code{\link{H5T_INTEGER}}}
#' \item{Bitfield}{\code{\link{H5T_BITFIELD}} (currently identical to the integer class)}
#' \item{Float}{\code{\link{H5T_FLOAT}}}
#' \item{Enum}{\code{\link{H5T_ENUM}}}
#' \item{Compound}{\code{\link{H5T_COMPOUND}}}
#' \item{String}{\code{\link{H5T_STRING}}}
#' \item{Complex}{\code{\link{H5T_COMPLEX}}}
#' \item{Array}{\code{\link{H5T_ARRAY}}}
#' \item{Variable Length}{\code{\link{H5T_VLEN}}}
#' }
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link{H5T}}.
#' @author Holger Hoefling
#'
#' @examples
#' my_int <- h5types$H5T_NATIVE_INT
#' my_int$to_text()
#' my_int$get_size()
#'
#' # Show how to commit a datatype
#' fname <- tempfile(fileext = ".h5")
#' file <- H5File$new(fname, mode = "a")
#' my_int$is_committed()
#' file$commit("my_int", my_int)
#' my_int$is_committed()
#'
#' # can now also add attributes
#' h5attr(my_int, "test") <- "A string"
#' h5attributes(my_int)
#' 
#' file$close_all()
#' file.remove(fname)
#' @export
H5T <- R6Class("H5T",
               inherit=H5RefClass,
               public=list(
                   initialize=function(id) {
                       "Internal use only"
                       super$initialize(id)
                   },
                   get_class=function() {
                       "This function implements the HDF5-API function H5Tget_class."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       cls_id <- .Call("R_H5Tget_class", self$id, PACKAGE="hdf5r")$return_val
                       return(cls_id)
                   },
                   get_size=function(...) {
                       "This function implements the HDF5-API function H5Tget_size."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."
                       "@param ... ignored"

                       return(.Call("R_H5Tget_size", self$id, PACKAGE="hdf5r")$return_val)
                   },
                   set_size=function(size) {
                       "This function implements the HDF5-API function H5Tset_size."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       if(size==Inf) {
                           if(self$get_class() != h5const$H5T_STRING) {
                               stop("Can only set to infinite size if datatype is a string; use H5T_VLEN instead for variable length data")
                           }
                           herr <- .Call("R_H5Tset_size", self$id, Inf, PACKAGE="hdf5r")$return_val
                       }
                       else {
                           herr <- .Call("R_H5Tset_size", self$id, as.integer(size), PACKAGE="hdf5r")$return_val
                       }
                       if(herr < 0) {
                           stop("Could not set size to specified value")
                       }
                       return(invisible(self))
                   },
                   set_precision=function(precision) {
                       "This function implements the HDF5-API function H5Tset_precision."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       herr <- .Call("R_H5Tset_precision", self$id, as.integer(precision), PACKAGE = "hdf5r")$return_val
                       if(herr < 0) {
                           stop("Could not set precision")
                       }
                       return(invisible(self))
                   },
                   get_precision=function() {
                       "This function implements the HDF5-API function H5Tget_precision."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       prec <- .Call("R_H5Tget_precision", self$id, PACKAGE = "hdf5r")$return_val
                       if(prec < 0) {
                           stop("There was an error retrieving the precision")
                       }
                       return(prec)
                   },
                   set_order=function(order) {
                       "This function implements the HDF5-API function H5Tset_order."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       herr <- .Call("R_H5Tset_order", self$id, as.integer(order), PACKAGE = "hdf5r")$return_val
                       if(herr < 0) {
                           stop("Could not set order")
                       }
                       return(invisible(self))
                   },
                   get_order=function() {
                       "This function implements the HDF5-API function H5Tget_order."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       order <- .Call("R_H5Tget_order", self$id, PACKAGE = "hdf5r")$return_val
                       if(order < 0) {
                           stop("There was an error retrieving the order")
                       }
                       return(order)
                   },
                   set_offset=function(offset) {
                       "This function implements the HDF5-API function H5Tset_offset."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       herr <- .Call("R_H5Tset_offset", self$id, as.integer(offset), PACKAGE = "hdf5r")$return_val
                       if(herr < 0) {
                           stop("Could not set offset")
                       }
                       return(invisible(self))
                   },
                   get_offset=function() {
                       "This function implements the HDF5-API function H5Tget_offset."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       offset <- .Call("R_H5Tget_offset", self$id, PACKAGE = "hdf5r")$return_val
                       if(offset < 0) {
                           stop("There was an error retrieving the offset")
                       }
                       return(offset)
                   },
                   set_pad=function(pad) {
                       "This function implements the HDF5-API function H5Tset_pad."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       herr <- .Call("R_H5Tset_pad", self$id, as.integer(pad), PACKAGE = "hdf5r")$return_val
                       if(herr < 0) {
                           stop("Could not set pad")
                       }
                       return(invisible(self))
                   },
                   get_pad=function() {
                       "This function implements the HDF5-API function H5Tget_pad."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       pad <- .Call("R_H5Tget_pad", self$id, PACKAGE = "hdf5r")$return_val
                       if(pad < 0) {
                           stop("There was an error retrieving the pad")
                       }
                       return(pad)
                   },
                   copy=function() {
                       "This function implements the HDF5-API function H5Tcopy."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       id <- .Call("R_H5Tcopy", self$id, PACKAGE="hdf5r")$return_val
                       return(H5T_factory(id, do_copy=FALSE))
                   },
                   is_committed=function() {
                       "This function implements the HDF5-API function H5Tcommitted."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       htri <- .Call("R_H5Tcommitted", self$id, PACKAGE="hdf5r")$return_val
                       if(htri < 0) {
                           stop("Error checking if a datatype has been committed")
                       }
                       return(as.logical(htri))
                   },
                   equal=function(dtype) {
                       "This function implements the HDF5-API function H5Tequal."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       if(is.numeric(dtype)) {
                           dtype <- bit64::as.integer64(dtype)
                       }
                       if(inherits(dtype, "H5T")) {
                           dtype <- dtype$id
                       }
                       if(!is.integer64(dtype)) {
                           stop("'dtype' has to be either numeric, coercible to integer of of class 'H5T'")
                       }
                       eq_res <- .Call("R_H5Tequal", self$id, dtype, PACKAGE="hdf5r")$return_val
                       if(eq_res < 0) {
                           stop("There was a problem in the comparison")
                       }
                       return(as.logical(eq_res))
                   },
                   is_vlen=function() {
                       "This function detects if the underlying type is H5T_VLEN or a variable length string. This is used to know if"
                       "after reading a dataset, memory has to be freed"

                       htri <- .Call("R_H5Tdetect_vlen", self$id, PACKAGE = "hdf5r")$return_val
                       if(htri < 0) {
                           stop("Error trying to detect if type is of variable length")
                       }
                       return(as.logical(htri))
                   },
                   detect_class=function(dtype_class) {
                       "This function implements the HDF5-API function H5Tdetect_class."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       htri <- .Call("R_H5Tdetect_class", self$id, dtype_class, PACKAGE = "hdf5r")$return_val
                       if(htri < 0) {
                           stop("Error trying to detect if type is of variable length")
                       }
                       return(as.logical(htri))
                   },
                   get_native_type=function(direction=h5const$H5T_DIR_ASCEND) {
                       "This function implements the HDF5-API function H5Tget_native_type."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       id <- .Call("R_H5Tget_native_type", self$id, direction, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving native-c-type")
                       }
                       return(H5T_factory(id=id))
                   },
                   get_create_plist=function() {
                       "This function implements the HDF5-API function H5Tget_create_plist."
                       "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                       id <- .Call("R_H5Tget_create_plist", self$id, PACKAGE="hdf5r")$return_val
                       if(id < 0) {
                           stop("Error retrieving type_creation_plist")
                       }
                       return(H5P_TYPE_CREATE$new(id=id))
                   },
                   to_text=function(lang_type=h5const$H5LT_DDL) {
                       "This function implements the HDF5-API function H5LTdtype_to_text."
                       res <- standalone_H5T_dtype_to_text(self$id, lang_type)

                       return(res)
                   },
                   print=function(...){
                       "Prints information for the group"
                       "@param ... ignored"
                       
                       is_valid <- self$is_valid
                       
                       print_class_id(self, is_valid)

                       if(is_valid) {
                           type_text <- self$to_text()
                           cat("Datatype: ", type_text, "\n", sep="")
                       }
                       return(invisible(self))
                   }
                   ),
               private=list(
                   closeFun=function(id) if(!is.na(id) && is.loaded("R_H5Tclose", PACKAGE="hdf5r")) {
                          invisible(.Call("R_H5Tclose", id, PACKAGE = "hdf5r"))
                   }
                   ),
               cloneable=FALSE
               )

## add a common function
R6_set_list_of_items(H5T, "public", commonFGDT, overwrite=TRUE)
R6_set_list_of_items(H5T, "public", commonFGT, overwrite=TRUE)


standalone_H5T_dtype_to_text <- function(h5t_id, lang_type) {
    res <- .Call("R_H5LTdtype_to_text", h5t_id, character(0), lang_type, request_empty(1), PACKAGE="hdf5r")
    if(res$return_val < 0) {
        stop("Could not retrieve the necessary size of the buffer to convert type to text")
    }
    char_buf <- paste(rep(" ", res$len + 1), collapse="")
    res <- .Call("R_H5LTdtype_to_text", h5t_id, char_buf, lang_type, nchar(char_buf), PACKAGE="hdf5r")
    if(res$return_val < 0) {
        stop("Could not convert type to text")
    }
    return(res$str)
}


#' Class for HDF5 integer-datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}.
#' Users should not create integer datatypes themselves using this class. Instead, integer should be derived
#' from one of the base-types such as \code{h5types$H5T_NATIVE_INT} (which internally automatically creates a copy of the type).
#' For a complete list of types see \code{h5types$overview}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_INTEGER]{H5T_INTEGER}}.
#' @export
#' @aliases H5T_BITFIELD H5T_BITFIELD
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
#'
#' @examples
#' my_int <- h5types$H5T_NATIVE_INT
#'
#' # make an int with 2 bit
#' my_int$set_sign(h5const$H5T_SGN_NONE)
#' my_int$set_size(1)
#' my_int$set_precision(2)
#' my_int$describe()
H5T_INTEGER <- R6Class("H5T_INTEGER",
                       inherit=H5T,
                       public=list(
                           set_sign=function(sign) {
                               "This function implements the HDF5-API function H5Tset_sign."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               herr <- .Call("R_H5Tset_sign", self$id, as.integer(sign), PACKAGE = "hdf5r")$return_val
                               if(herr < 0) {
                                   stop("Could not set sign")
                               }
                               return(invisible(self))
                           },
                           get_sign=function() {
                               "This function implements the HDF5-API function H5Tget_sign."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               sign <- .Call("R_H5Tget_sign", self$id, PACKAGE = "hdf5r")$return_val
                               return(sign)
                               if(sign < 0) {
                                   stop("There was an error retrieving the sign")
                               }
                           },
                           describe=function() {
                               "Return a vector that describes the key features of the datatype"
                               return(list(size=self$get_size(), precision=self$get_precision(), sign=self$get_sign(),
                                           order=self$get_order()))
                           }
                           ),
                       cloneable=FALSE)

H5T_BITFIELD <- H5T_INTEGER


#' Class for HDF5 floating point datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}. Users should not create float types with this class, but instead
#' use e.g. \code{h5types$H5T_NATIVE_DOUBLE}. Using the functions of this class, many aspects of the representation of the
#' floating point number can then be manipulated.
#' 
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_FLOAT]{H5T_FLOAT}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
H5T_FLOAT <- R6Class("H5T_FLOAT",
                       inherit=H5T,
                       public=list(
                           set_fields=function(spos, epos, esize, mpos, msize) {
                               "This function implements the HDF5-API function H5Tset_fields."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               herr <- .Call("R_H5Tset_fields", self$id, spos, epos, esize, mpos, msize, PACKAGE="hdf5r")$return_val
                               if(herr < 0) {
                                   stop("Error setting fields")
                               }
                           },
                           get_fields=function() {
                               "This function implements the HDF5-API function H5Tget_fields."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               res <- .Call("R_H5Tget_fields", self$id, request_empty(1), request_empty(1), request_empty(1), request_empty(1),
                                            request_empty(1), PACKAGE="hdf5r")
                               if(res$return_val < 0) {
                                   stop("Error retrieving fields")
                               }
                               return(list(spos=res$spos, epos=res$epos, esize=res$esize, mpos=res$mpos, msize=res$msize))
                           },
                           set_ebias=function(ebias) {
                               "This function implements the HDF5-API function H5Tset_ebias."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               herr <- .Call("R_H5Tset_ebias", self$id, as.integer(ebias), PACKAGE = "hdf5r")$return_val
                               if(herr < 0) {
                                   stop("Could not set ebias")
                               }
                               return(invisible(self))
                           },
                           get_ebias=function() {
                               "This function implements the HDF5-API function H5Tget_ebias."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               ebias <- .Call("R_H5Tget_ebias", self$id, PACKAGE = "hdf5r")$return_val
                               return(ebias)
                               if(ebias < 0) {
                                   stop("There was an error retrieving the ebias")
                               }
                           },
                           set_norm=function(norm) {
                               "This function implements the HDF5-API function H5Tset_norm."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               herr <- .Call("R_H5Tset_norm", self$id, as.integer(norm), PACKAGE = "hdf5r")$return_val
                               if(herr < 0) {
                                   stop("Could not set norm")
                               }
                               return(invisible(self))
                           },
                           get_norm=function() {
                               "This function implements the HDF5-API function H5Tget_norm."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               norm <- .Call("R_H5Tget_norm", self$id, PACKAGE = "hdf5r")$return_val
                               return(norm)
                               if(norm < 0) {
                                   stop("There was an error retrieving the norm")
                               }
                           },
                           set_inpad=function(inpad) {
                               "This function implements the HDF5-API function H5Tset_inpad."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               herr <- .Call("R_H5Tset_inpad", self$id, as.integer(inpad), PACKAGE = "hdf5r")$return_val
                               if(herr < 0) {
                                   stop("Could not set inpad")
                               }
                               return(invisible(self))
                           },
                           get_inpad=function() {
                               "This function implements the HDF5-API function H5Tget_inpad."
                               "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                               inpad <- .Call("R_H5Tget_inpad", self$id, PACKAGE = "hdf5r")$return_val
                               return(inpad)
                               if(inpad < 0) {
                                   stop("There was an error retrieving the inpad")
                               }
                           },
                           describe=function() {
                               "Print a detailed description of the datatype; this is experimental"
                               return(list(size=self$get_size(), precision=self$get_precision(),
                                           fields=self$get_fields(), ebias=self$get_ebias(), norm=self$get_norm(),
                                           inpad=self$get_inpad()))
                           }
                           ),
                     cloneable=FALSE)

#' Class for HDF5 enumeration datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}.
#' @docType class
#' @importFrom R6 R6Class
#' @importFrom utils compareVersion
#' @return Object of class \code{\link[=H5T_ENUM]{H5T_ENUM}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
#'
#' @examples
#' nucleotide_enum <- H5T_ENUM$new(labels=c("A", "C", "G", "T"), values=0:3)
#' nucleotide_enum
#' # For HDF5 1.8.16 or higher, the size and precision are set optimally
#' nucleotide_enum$get_size()
#' nucleotide_enum$get_precision()
H5T_ENUM <- R6Class("H5T_ENUM",
                    inherit=H5T_INTEGER,
                    public=list(
                        initialize=function(labels, values=seq_along(labels), id=NULL) {
                            "Create an enumeration datatype. This is either a factor-like object or a logical variable (that is"
                            "internally represented as an ENUM-type."
                            "@param labels The labels of the ENUM-type"
                            "@param values The values corresponding to the labels"
                            "@param id Internal use only"
                            if(!is.null(id)) {
                                super$initialize(id=id)
                                return(self)
                            }
                            if(!missing(labels)) {
                                if(missing(values)) {
                                    values <- seq_along(labels)
                                }
                                max_abs <- max(abs(values))
                                has_neg <- any(values < 0)
                                needed_precision <- ceiling(log2(max_abs + 1))
                                if(has_neg) {
                                    needed_precision <- needed_precision + 1
                                }
                                size <- ceiling(needed_precision / 8)

                                if(has_neg) {
                                    if(size <= 1) {
                                        dtype_id <- h5types$H5T_NATIVE_CHAR
                                    }
                                    else if(size <= 2) {
                                        dtype_id <- h5types$H5T_NATIVE_SHORT
                                    }
                                    else if(size <= 4) {
                                        dtype_id <- h5types$H5T_NATIVE_INT
                                    }
                                    else {
                                        dtype_id <- h5types$H5T_NATIVE_LLONG
                                    }
                                }
                                else {
                                    if(size <= 1) {
                                        dtype_id <- h5types$H5T_NATIVE_UCHAR
                                    }
                                    else if(size <= 2) {
                                        dtype_id <- h5types$H5T_NATIVE_USHORT
                                    }
                                    else if(size <= 4) {
                                        dtype_id <- h5types$H5T_NATIVE_UINT
                                    }
                                    else {
                                        if(needed_precision==64) {
                                            stop("Can't support UINT64; unsigned precision of 64bit not possible")
                                        }
                                        else {
                                            dtype_id <- h5types$H5T_NATIVE_LLONG
                                        }
                                    }
                                }
                                if(compareVersion(h5version(verbose=FALSE), "1.8.16") >= 0) {
                                    ## can only do this for 1.8.16 or above
                                    ## lower version have problems getting native type of an enum based on a non-native type
                                    dtype_id$set_size(size)
                                    dtype_id$set_precision(needed_precision)
                                }
                                id <- .Call("h5create_enum_type", as.character(labels), values, dtype_id$id, PACKAGE="hdf5r")$return_val
                                super$initialize(id=id)
                                return(self)
                            }
                            stop("None of the parameters were set")
                        },
                        get_labels=function() {
                            "Return all the labels of the enumeration type"
                            return(.Call("h5get_enum_labels", self$id, PACKAGE="hdf5r")$return_val)
                        },
                        get_values=function() {
                            "Return the values of the enumeration type"
                            return(.Call("h5get_enum_values", self$id, PACKAGE = "hdf5r")$return_val)
                        },
                        set_size=function(size) {
                            "Base type of every enum is \\code{H5T_INTEGER}. This disables the set_size function"
                            stop("Function 'set_size' not allowed for 'H5T_ENUM'")
                        },
                        get_super=function() {
                            "Returns \\code{\\link{H5T_INTEGER}} that is the base type of the enumeration"
                            id <- .Call("R_H5Tget_super", self$id, PACKAGE="hdf5r")$return_val
                            if(id < 0) {
                                stop("Error retrieving super_type")
                            }
                            return(H5T_factory(id=id))
                        },
                        describe=function() {
                            "Print a detailed description of the datatype; this is experimental"

                            return(list(super=self$get_super()$describe(), labels=self$get_labels(), values=self$get_values()))
                        }

                        ),
                    cloneable=FALSE
                    )



#' Class for HDF5 logical datatypes. This is an enum with the 3 values FALSE, TRUE and NA mapped on values 0, 1 and 2.
#' Is transparently mapped onto a logical variable
#'
#' Inherits from class \code{\link[=H5T]{H5T}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_LOGICAL]{H5T_LOGICAL}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}, \code{\link[=H5T_ENUM]{H5T_ENUM}}
H5T_LOGICAL <-  R6Class("H5T_LOGICAL",
                    inherit=H5T_ENUM,
                    public=list(
                        initialize=function(include_NA=TRUE, id=NULL) {
                            "Create a logical datatype. This is"
                            "internally represented by an ENUM-type"
                            "@param id Internal use only"
                            if(!is.null(id)) {
                                super$initialize(id=id)
                                return(self)
                            }
                            if(include_NA) {
                                dtype_id <- h5types$H5T_NATIVE_UCHAR
                                if(compareVersion(h5version(verbose=FALSE), "1.8.16") >= 0) {
                                    ## can only do this for 1.8.16 or above
                                    ## lower version have problems getting native type of an enum based on a non-native type
                                        dtype_id$set_size(1)
                                        dtype_id$set_precision(2)
                                }
                                id <- .Call("h5create_enum_type", as.character(c("FALSE","TRUE", "NA")), as.integer(c(0,1,2)), dtype_id$id, PACKAGE="hdf5r")$return_val
                                super$initialize(id=id)
                                return(self)
                            }
                            else {
                                dtype_id <- h5types$H5T_NATIVE_UCHAR
                                if(compareVersion(h5version(verbose=FALSE), "1.8.16") >= 0) {
                                    ## can only do this for 1.8.16 or above
                                    ## lower version have problems getting native type of an enum based on a non-native type
                                        dtype_id$set_size(1)
                                        dtype_id$set_precision(1)
                                }
                                id <- .Call("h5create_enum_type", as.character(c("FALSE","TRUE")), as.integer(c(0,1)), dtype_id$id, PACKAGE="hdf5r")$return_val
                                super$initialize(id=id)
                                return(self)
                            }
                        }),
                        cloneable=FALSE
                        )

#' Class for HDF5 compound datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_COMPOUND]{H5T_COMPOUND}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
#'
#' @examples
#' # create a H5T_COMPOUND  corresponding to a data-frame
#' my_cpd <- H5T_COMPOUND$new(c("name", "age", "salary"),
#'     dtypes=list(H5T_STRING$new(size=200), h5types$H5T_NATIVE_INT, h5types$H5T_NATIVE_DOUBLE))
#' my_cpd
H5T_COMPOUND <- R6Class("H5T_COMPOUND",
                        inherit=H5T,
                        public=list(
                            initialize=function(labels, dtypes, size=NULL, offset=NULL, id=NULL) {
                                "Create at compound type that is the HDF5 equivalent of a table"
                                "@param labels The labels of the columns of the compound object"
                                "@param dtypes The datatypes of the columns of the object; this is usually a list of objects"
                                "of class \\code{\\link{H5T}}"
                                "@param size The size of each datatype; if \\code{NULL}, automatically inferred"
                                "@param offset The offset where each datatype starts; can be different from the sum of the individual sizes"
                                "so that datatypes are aligned with memory addresses. If \\code{NULL}, inferred automatically"
                                "@param id Internal use only"
                                if(is.null(id)) {
                                    if(missing(dtypes) || missing(labels)) {
                                        stop("Either 'id' or ('dtype_ids' and 'labels') have to be given")
                                    }
                                    dtype_ids <- H5T_extractID(dtypes)
                                    if(length(labels) != length(dtype_ids)) {
                                        stop("'labels' and 'dtype_ids' have to have the same length")
                                    }
                                    if(!is.character(labels)) {
                                        stop("'labels' has to be a character vector")
                                    }
                                    labels <- as.character(labels)
                                    id <- .Call("h5create_compound_type", labels, dtype_ids, as.integer(size), as.integer(offset), PACKAGE="hdf5r")$return_val
                                }
                                super$initialize(id)
                            },
                            pack=function() {
                                "This function implements the HDF5-API function H5Tpack."
                                "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                                herr <- .Call("R_H5Tpack", self$id, PACKAGE="hdf5r")$return_val
                                if(herr < 0) {
                                    stop("Error removing padding")
                                }
                                return(invisible(self))
                            },
                            get_cpd_types=function() {
                                "Return \\code{\\link{H5T}} objects that represent the datatypes of the columns of the "
                                "compound object. Returned as a list if more than 1"
                                dtype_ids <- .Call("h5get_compound_types", self$id, PACKAGE="hdf5r")$return_val
                                return(H5T_factory(ids=dtype_ids))
                            },
                            get_cpd_labels=function() {
                                "Return the labels of the columns as a character vector"
                                return(.Call("h5get_compound_names", self$id, PACKAGE="hdf5r")$return_val)
                            },
                            get_cpd_classes=function() {
                                "Return the classes of the columns as an object of type \\code{\\link{factor_ext}}"
                                return(.Call("h5get_compound_classes", self$id, PACKAGE="hdf5r")$return_val)
                            },
                            get_cpd_offsets=function() {
                                "Return the offsets of the datatypes"
                                return(.Call("h5get_compound_offsets", self$id, PACKAGE="hdf5r")$return_val)
                            },
                            describe=function() {
                                "Print a detailed description of the datatype; this is experimental"

                                cpd_types <- self$get_cpd_types()
                                if(!is.list(cpd_types)) {
                                    cpd_types <- list(cpd_types)
                                }
                                cpd_describe <- lapply(cpd_types, function(x) x$describe())
                                return(list(cpd_types=cpd_describe, labels=self$get_cpd_labels(),
                                            classes=self$get_cpd_classes(), offsets=self$get_cpd_offsets(),
                                            size=self$get_size()))
                            }
                            ),
                        cloneable=FALSE
                        )

#' Class for HDF5 string datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_STRING]{H5T_STRING}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
#'
#' @examples
#' # fixed width string
#' str_flen <- H5T_STRING$new(size=100)
#' str_flen$is_vlen()
#' str_flen
#' 
#' # variable length string
#' str_vlen <- H5T_STRING$new(size=Inf)
#' str_vlen$is_vlen()
#' str_vlen
H5T_STRING <- R6Class("H5T_STRING",
                      inherit=H5T,
                      public=list(
                          initialize=function(type=c("c", "fortran"), size=1, id=NULL) {
                              "Create a string datatype"
                              "@param A C or fortran type string"
                              "@param size Size of the string object. Set to \\code{Inf} for variable size strings"
                              "@param id internal use only"
                              newid <- FALSE
                              if(is.null(id)) {
                                  type <- match.arg(type)
                                  id <- switch(type, c=h5types$H5T_C_S1, fortran=h5types$H5T_FORTRAN_S1)
                                  ## need to copy it through the low level function; copy function returns an
                                  ## object; and that object closes the id; so it needs to be copied this way
                                  id <- .Call("R_H5Tcopy", id$id, PACKAGE="hdf5r")$return_val
                                  newid <- TRUE
                              }
                              super$initialize(id=id)
                              if(newid) {
                                  self$set_size(size)
                              }
                              return(self)
                          },
                          get_size=function(variable_as_inf=TRUE) {
                              "Retrieves the length of the string, setting it to \\code{Inf} it is of variable length."
                              "This function implements the HDF5-API function H5Tis_variable_str."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                              ## needs to be overloaded to properly assess if it is a variable length string
                              ## first check if the string has variable length
                              if(variable_as_inf) {
                                  is_var_string = .Call("R_H5Tis_variable_str", self$id, PACKAGE = "hdf5r")$return_val
                                  if(is_var_string < 0) {
                                      error("Could not determine if datatype is a variable length string")
                                  }
                                  if(is_var_string) {
                                      return(Inf)
                                  }
                                  else {
                                      return(super$get_size())
                                  }
                              }
                              else {
                                  return(super$get_size())
                              }
                          },
                          get_cset=function() {
                              "This function implements the HDF5-API function H5Tget_cset."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                              cset_res = .Call("R_H5Tget_cset", self$id, PACKAGE = "hdf5r")$return_val
                              return(cset_res)
                          },
                          set_cset=function(cset=c("unknown", "UTF-8")) {
                              "This function implements the HDF5-API function H5Tset_cset."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                              if(is.character(cset)) {
                                  cset <- match.arg(cset)
                                  cset <- switch(cset, unknown=h5const$H5T_CSET_ASCII, "UTF-8"=h5const$H5T_CSET_UTF8)
                              }
                              cset_res <- .Call("R_H5Tset_cset", self$id, as.integer(cset), PACKAGE = "hdf5r")$return_val
                              if(cset_res < 0) {
                                  stop("Error when trying to set cset")
                              }
                              return(self)
                          },
                          set_strpad=function(strpad) {
                              "This function implements the HDF5-API function H5Tset_strpad."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                              herr <- .Call("R_H5Tset_strpad", self$id, as.integer(strpad), PACKAGE = "hdf5r")$return_val
                              if(herr < 0) {
                                  stop("Could not set strpad")
                              }
                              return(invisible(self))
                          },
                          get_strpad=function() {
                              "This function implements the HDF5-API function H5Tget_strpad."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                              strpad <- .Call("R_H5Tget_strpad", self$id, PACKAGE = "hdf5r")$return_val
                              return(strpad)
                              if(strpad < 0) {
                                  stop("There was an error retrieving the strpad")
                              }
                          },
                          describe=function() {
                              "Print a detailed description of the datatype; this is experimental"

                              return(list(size=self$get_size(), cset=self$get_cset(), strpad=self$get_strpad()))
                          }

                          ),
                      cloneable=FALSE
                      )



#' Class for HDF5 complex datatypes
#'
#' In HDF5, complex numbers don't actually exist. They are represented as H5T_COMPOUND with two columns named \code{Real} and
#' \code{Imaginary}.
#' Inherits from class \code{\link[=H5T_COMPOUND]{H5T_COMPOUND}}.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_COMPLEX]{H5T_COMPLEX}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}, \code{\link[=H5T_COMPOUND]{H5T_COMPOUND}}
H5T_COMPLEX <- R6Class("H5T_COMPLEX",
                       inherit=H5T_COMPOUND,
                       public=list(
                           initialize=function(id=NULL) {
                               "Create a new complex datatype"
                               "@param id Internal use only"
                               if(is.null(id)) {
                                   labels <- c("Real", "Imaginary")
                                   dtypes <- rep(h5types$H5T_NATIVE_DOUBLE$id,2)
                                   super$initialize(labels=labels, dtypes=dtypes, size=NULL, offset=NULL)
                               }
                               else {
                                   super$initialize(id=id)
                               }
                           }
                           ),
                       cloneable=FALSE
                       )


#' Class for HDF5 array datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}. This class represents an array. As datasets in HDF5
#' are itself already arrays, this datatype is not needed there. It is mostly useful when a column in a
#' \code{H5T_COMPUND} object is intended to be an array. This however makes it difficult to work
#' with such objects in R - as a column of the corresponding \code{data.frame} has to be an array. So please
#' use with care.
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_ARRAY]{H5T_ARRAY}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
H5T_ARRAY <- R6Class("H5T_ARRAY",
                     inherit=H5T,
                     public=list(
                         initialize=function(dims, dtype_base, id=NULL) {
                             "Create an array datatype."
                             "@param dims The dimension of the datatype"
                             "@param dtype_base The datatype that makes up the elements of the array"
                             "@param id internal use only"
                             if(is.null(id)) {
                                 ## ok, check that we have the right base type available
                                 if(missing(dims) || missing(dtype_base)) {
                                     stop("When creating a new array datatype, either id has to be given (for an existing one), or dims and dtype_base")
                                 }
                                 if(inherits(dtype_base, "H5T")) {
                                     dtype_base <- dtype_base$id
                                 }
                                 rank <- length(dims)
                                 dims <- rev(dims)
                                 id <- .Call("R_H5Tarray_create2", bit64::as.integer64(dtype_base), as.integer(rank), as.integer(dims), PACKAGE = "hdf5r")$return_val
                             }
                             super$initialize(id)
                         },
                         get_array_ndims=function() {
                             "This function implements the HDF5-API function H5Tget_array_ndims."
                             "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                             res <- .Call("R_H5Tget_array_ndims", self$id, PACKAGE="hdf5r")$return_val
                             if(res < 0) {
                                 stop("Error trying to get rank of array-type")
                             }
                             return(res)
                         },
                         get_array_dims=function() {
                             "This function implements the HDF5-API function H5Tget_array_dims2."
                             "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                             rank <- self$get_array_ndims()
                             dims <- integer(rank)
                             res <- .Call("R_H5Tget_array_dims2", self$id, dims, PACKAGE="hdf5r")
                             if(res$return_val < 0) {
                                 stop("Error trying to get array-type dimensions")
                             }
                             return(rev(res$dims))
                         },
                         get_super=function() {
                             "This function implements the HDF5-API function H5Tget_super."
                             "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                             id <- .Call("R_H5Tget_super", self$id, PACKAGE="hdf5r")$return_val
                             if(id < 0) {
                                 stop("Error retrieving super_type")
                             }
                             return(H5T_factory(id=id))
                         },
                         describe=function() {
                             "Print a detailed description of the datatype; this is experimental"

                             return(list(super=self$get_super()$describe(), array_dims=self$get_array_dims()))
                         }
                         ),
                     cloneable=FALSE
                     )



#' Class for HDF5 variable-length datatypes.
#'
#' Inherits from class \code{\link[=H5T]{H5T}}. This can make any datatype a variable length datatype.
#' This would mostly be intended for storing ragged arrays. 
#' @docType class
#' @importFrom R6 R6Class
#' @return Object of class \code{\link[=H5T_VLEN]{H5T_VLEN}}.
#' @export
#' @author Holger Hoefling
#' @seealso \code{\link[=H5T]{H5T}}
#'
#' @examples
#' vlen_int <- H5T_VLEN$new(h5types$H5T_NATIVE_INT)
#' vlen_int
H5T_VLEN <- R6Class("H5T_VLEN",
                    inherit=H5T,
                    public=list(
                        initialize=function(dtype_base, id=NULL) {
                            "Create a variable length datatype"
                            "@param dtype_base The basis-type of the variable length datatype"
                            "@param id Internal use only"
                            if(is.null(id)) {
                                if(inherits(dtype_base, "H5T")) {
                                    dtype_base <- dtype_base$id
                                }
                                id <- .Call("R_H5Tvlen_create", bit64::as.integer64(dtype_base), PACKAGE="hdf5r")$return_val
                            }
                            super$initialize(id=id)
                        },
                        get_super=function() {
                            "This function implements the HDF5-API function H5Tget_super."
                            "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_t.html} for details."

                            id <- .Call("R_H5Tget_super", self$id, PACKAGE="hdf5r")$return_val
                            if(id < 0) {
                                stop("Error retrieving super_type")
                            }
                            return(H5T_factory(id=id))
                        },
                        describe=function() {
                            "Print a detailed description of the datatype; this is experimental"

                            return(list(super=self$get_super()$describe()))
                        }
                        ),
                    cloneable=FALSE
                    )



---
File: /R/R6Classes.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



##' Base class that tracks the ids and allows for closing an id
##' 
##' This class is not intended for creating objects, but as a base class for all other
##' H5-derived classes to provide common functionality for id tracking
##' @docType class
##' @importFrom R6 R6Class
##' @return Object of reference class \code{\link{H5RefClass}}. 
##' @field id Returns the id of the object as an integer
##' @export
##' @importFrom bit64 as.integer64
##' @importFrom bit64 is.na.integer64
##' @author Holger Hoefling
H5RefClass <- R6Class("H5RefClass",
                      public=list(
                          initialize=function(id=NULL) {
                              "Constructor for the basic class for hdf5 objects. Takes an id and stores it appropriately, including"
                              "the necessary counting of object references that the package implements. This reference counting is"
                              "included in addition to R's internal method in order to allow for the invalidation of objects"
                              "in R itself when all open handles in an R-file are being closed."
                              if(is.null(id)) {
                                  stop("Id has to be specified")
                              }
                              if(is.na(id)) {
                                  stop("'id' cannot be NA")
                              }
                              if(!is.numeric(id) || (as.integer64(id) != id)) {
                                  stop("'id' has to be integer or can be coerced to integer")
                              }
                              ## check the r object count as well as the hdf5 object count
                              item <- incr_count(as.integer64(id))
                              private$pid <- item$obj

                              r_count <- item$count
                              h5_count <- self$get_ref()

                              # cat("ID: ", id, " R-count: ", r_count, " h5-count: ", h5_count, "\n")
                              
                              if(r_count == h5_count + 1) {
                                  new_count <- self$inc_ref()
                                  cat("New count is ", new_count, "\n")
                              }
                              else if(r_count > h5_count + 1) {
                                  stop("r_count can never be more than 1 larger than h5_count")
                              }
                              else if(r_count < h5_count) {
                                  stop("r_count can never be less than h5_count")
                              }
                              ## only for debug; file_ids can often exist more than once
                              #if(r_count==2) {
                              #    warning("Same object exists twice")
                              #}
                              
                              reg.finalizer(self, function(e) { e$close()}, onexit=TRUE)
                          },
                          close=function() {
                              "Closes an object and calls the appropriate HDF5 function for the type of object"
                              if(self$is_valid) {
                                  id <- private$pid$id
                                  private$closeFun(id)
                                  decr_count(id)
                              }
                              private$pid <- NA
                              return(invisible(self))

                          },
 #                         erase=function() {
 #                             private$pid <- NA
 #                             private$pmessage <- "erased"
 #                         },
                          print=function(...) {
                              "Prints the class of the object and the id"

                              is_valid <- self$is_valid

                              print_class_id(self, is_valid)
                              return(invisible(self))
                          },
                          methods=function() {
                              "Prints available methods on the screen"
                              cat(format(self), sep="\n")
                          }
                          ),
                      active=list(
                          id=function() {
                              "Returns the id of the object"
                              if(is.environment(private$pid)) {
                                  if(is.na(private$pid$id)) {
                                      stop("id is invalid")
                                  }
                                  else {
                                      return(private$pid$id)
                                  }
                              }
                              else {
                                  stop("id is invalid")
                              }
                          },
                          id_env=function() {
                              return(private$pid)
                          },
                          is_valid=function() {
                              "This function implements the HDF5-API function H5Iis_valid."
                              "Please see the documentation at \\url{https://support.hdfgroup.org/documentation/hdf5/latest/group___h5_i.html} for details."
                              "Additionally, the R-object representing the HDF5-id can be invalidated as well. In this"
                              "case, the class id is set to \\code{NA} and \\code{is_valid} returns \\code{FALSE}."
                              
                              if(!is.environment(private$pid) || is.na(private$pid$id)) {
                                  return(FALSE)
                              }
                              if(!is.loaded("R_H5Iis_valid", PACKAGE = "hdf5r")) { ## package has already been unloaded; ignore
                                  return(FALSE)
                              }
                              res <- .Call("R_H5Iis_valid", self$id, PACKAGE = "hdf5r")$return_val
                              if(res < 0) {
                                  stop(paste("Error determining validity of id", as_hex(self$id)))
                              }
                              return(res > 0)
                          },
                          message=function() {
                              "Legacy function; currently not used; may be removed"
                              return(private$pmessage)
                          }
                          ),
                      private=list(
                          pid=NA,
                          closeFun=identity,
                          pmessage=character(0),
                          stopOnInvalid=function(error.msg="The object is invalid") {
                              if(!self$is_valid) {
                                  stop(error.msg)
                              }
                          }
                          ),
                      cloneable=FALSE                      
                      )

R6_set_list_of_items(H5RefClass, "public", interface, overwrite=TRUE)







---
File: /R/zzz.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

.onLoad <- function(libname, pkgname) {
#    .Call("R_H5dont_atexit", PACKAGE="hdf5r")
    .Call("R_H5open", PACKAGE="hdf5r")
    .Call("R_H5error", PACKAGE = "hdf5r")
    ## initialize the C data types
    .Call("init_dtypes", PACKAGE="hdf5r")
    install_types_const(h5types, h5const)

    ## install some global options
    op <- options
    op.hdf5r <- list(
        hdf5r.chunk_size = 2^13,
        hdf5r.default_string_len = Inf,
        hdf5r.flush_on_write=TRUE,
        hdf5r.h5tor_default=h5const$H5TOR_CONV_INT64_NOLOSS,
        hdf5r.point_to_hyperslabs_ratio=4,
        hdf5r.print_id=FALSE
        )
    toset <- !(names(op.hdf5r) %in% names(op))
    if(any(toset)) options(op.hdf5r[toset])

    ## need to set the size of the ref_obj for use in functions
    ref_obj_size$H5R_OBJECT <- h5types$H5T_STD_REF_OBJ$get_size()
    ref_obj_size$H5R_DATASET_REGION <- h5types$H5T_STD_REF_DSETREG$get_size()

    # adapt function calls to new functions in version 1.10.3
    adapt_classes()
    
    return(invisible())
    
}

.onUnload <- function(libpath) {
    if(is.loaded("R_H5close", PACKAGE="hdf5r")) {
        ## first close all open files
        gc()
        obj_ids <- as.integer64(ls(envir=obj_tracker))
        for(i in seq_along(obj_ids)) {
            H5_close_any(obj_ids[i])
            rm_obj(obj_ids[i])
        }
        ## need to call gc to ensure that all those untracked objects are
        ## actually deleted and the open handles closed
        gc()
        ## close all open objects in hdf5
                                        #    print("Before closing library")
        .Call("R_H5close", PACKAGE="hdf5r")
                                        #    print(".onUnload finished")
    }
    return(invisible())
}





---
File: /tests/testthat/test-64bit_support.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("64bit-support")

test_that("Dataset with more than 2^31 rows", {
    ## but will only support to the length of LONG accuracy
    ## just as normal R arrays
    large_space <- H5S$new(type="simple", dim=as.integer64(2)^33)

    ## first try that writing a hyperslab is done correctly
    large_space$select_hyperslab(start=1, count=1, stride=1, block=as.integer64(2)^32)
    expect_equal(large_space$get_select_hyper_blocklist()[,1], setNames(c(1, 2^32), c("block_1_start", "block_1_end")))

    ## now test that the reading also works correctly using the high-level array functionality
    large_space$select_none()
    large_space[2:2^32]
    expect_equal(large_space$get_select_hyper_blocklist()[,1], setNames(c(2, 2^32), c("block_1_start", "block_1_end")))
    large_space$select_none()
    large_space[as.integer64(2):(as.integer64(2)^32)]
    expect_equal(large_space$get_select_hyper_blocklist()[,1], setNames(c(2, 2^32), c("block_1_start", "block_1_end")))

    ## create a large dataset on disk for read/write test (won't actually be physically large in size
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    large_ds <- file.h5$create_dataset("large_ds", dtype=h5types$H5T_NATIVE_INT, space=large_space, chunk_dims=1e6, gzip_level = 4)
    large_ds[(2^32-10):(2^32+10)] <- 1:21
    expect_equal(large_ds[(2^32-20):(2^32+20)], c(rep(0L,10), 1:21, rep(0L, 10)))
    file.h5$close_all()
    file.remove(test_file)

})

truncateVec <- function(x, min, max) {
    # truncate values, leave na alone
    x[!is.na(x) & x < min] <- min
    x[!is.na(x) & x > max] <- max
    return(x)
}

value_LLONG_MAX <- function() {
    res <- bit64::as.integer64(0)
    for(i in 0:62) {
        res <- res + bit64::as.integer64(2)^i
    }
    return(res)
}

test_that("Datatype conversion with 64bit", {
    ## note that some of this duplicates some other tests in test-convert
    LLONG_MAX <- value_LLONG_MAX()
    dtype_uint64 <- h5types$H5T_NATIVE_ULLONG
    dtype_int64 <- h5types$H5T_NATIVE_LLONG

    ## first test the uint64 behaviour
    ## Should differ between truncation, NA and FLOAT_FORCE
    dbl_vec_pos <- c(1, 2, 2^31-1, 2^31, 2^32, 2^33, 2^62, 2^63, 1.5 * 2^63, 2^65)
    dbl_vec <- c(-dbl_vec_pos, dbl_vec_pos)
    dbl_vec_int64 <- suppressWarnings(bit64::as.integer64(dbl_vec))

    res_dbl_uint64_default <- hdf5r:::convertRoundTrip(dbl_vec, dtype_uint64, flags=h5const$H5TOR_CONV_NONE)
    res_dbl_uint64_na <- suppressWarnings(hdf5r:::convertRoundTrip(dbl_vec, dtype_uint64, flags=h5const$H5TOR_CONV_UINT64_NA))
    res_dbl_uint64_force <- hdf5r:::convertRoundTrip(dbl_vec, dtype_uint64, flags=h5const$H5TOR_CONV_INT64_FLOAT_FORCE)


    ## for truncation - need to convert to int64, then set NA to LLONG_MAX
    dbl_vec_int64_trunc <- suppressWarnings(bit64::as.integer64(dbl_vec))
    dbl_vec_int64_trunc[dbl_vec < 0] <- 0
    dbl_vec_int64_trunc[is.na(dbl_vec_int64_trunc)] <- LLONG_MAX
    dbl_vec_int64_na <- suppressWarnings(bit64::as.integer64(dbl_vec))
    suppressWarnings({
      dbl_vec_int64_na[18] <- dbl_vec_int64_na[18] + 1
    })
    dbl_vec_int64_na[dbl_vec < 0] <- 0
    expect_equal(suppressWarnings(truncateVec(dbl_vec_int64_trunc, 0, LLONG_MAX)), res_dbl_uint64_default$output)
    expect_equal(suppressWarnings(truncateVec(dbl_vec_int64_na, 0, LLONG_MAX)), res_dbl_uint64_na$output)

    dbl_vec_force <- truncateVec(dbl_vec, 0, 2^64) ## only trunctaed at uint64, not int64
    expect_equal(dbl_vec_force, res_dbl_uint64_force$output)


    ## now test the regular integer behaviour
    ## first, no conversion
    res_dbl_int64_default <- suppressWarnings(hdf5r:::convertRoundTrip(dbl_vec, dtype_int64, flags=h5const$H5TOR_CONV_NONE))
    expect_equal(dbl_vec_int64, res_dbl_int64_default$output)

    ## conversion to integer if no loss is incurred
    res_dbl_int64_int_noloss_short_int <- hdf5r:::convertRoundTrip(dbl_vec[abs(dbl_vec) < 2^31], dtype_int64,
                                                                   flags=h5const$H5TOR_CONV_INT64_INT_NOLOSS)
    expect_equal(as.integer(dbl_vec[abs(dbl_vec) < 2^31]), res_dbl_int64_int_noloss_short_int$output)

    res_dbl_int64_int_noloss_short_int_withNA <- hdf5r:::convertRoundTrip(c(dbl_vec[abs(dbl_vec) < 2^31], NA), dtype_int64,
                                                                   flags=h5const$H5TOR_CONV_INT64_INT_NOLOSS)
    expect_equal(as.integer(c(dbl_vec[abs(dbl_vec) < 2^31], NA)), res_dbl_int64_int_noloss_short_int_withNA$output)

    res_dbl_int64_int_noloss <- suppressWarnings(hdf5r:::convertRoundTrip(dbl_vec, dtype_int64,
                                                         flags=h5const$H5TOR_CONV_INT64_INT_NOLOSS))
    expect_equal(dbl_vec_int64, res_dbl_int64_int_noloss$output)

    ## covnersion to float if no loss is incurred
    res_dbl_int64_float_noloss_short_float <- hdf5r:::convertRoundTrip(dbl_vec[abs(dbl_vec) < 2^51], dtype_int64,
                                                           flags=h5const$H5TOR_CONV_INT64_FLOAT_NOLOSS)
    expect_equal(as.numeric(dbl_vec[abs(dbl_vec) < 2^51]), res_dbl_int64_float_noloss_short_float$output)

    res_dbl_int64_float_noloss_short_float_withNA <- hdf5r:::convertRoundTrip(c(dbl_vec[abs(dbl_vec) < 2^51], NA), dtype_int64,
                                                           flags=h5const$H5TOR_CONV_INT64_FLOAT_NOLOSS)
    expect_equal(as.numeric(c(dbl_vec[abs(dbl_vec) < 2^51], NA)), res_dbl_int64_float_noloss_short_float_withNA$output)

    res_dbl_int64_float_noloss <- suppressWarnings(hdf5r:::convertRoundTrip(dbl_vec, dtype_int64,
                                                           flags=h5const$H5TOR_CONV_INT64_FLOAT_NOLOSS))
    expect_equal(dbl_vec_int64, res_dbl_int64_int_noloss$output)


    ## conversion to integer or float if no loss is incurred
    res_dbl_int64_noloss <- suppressWarnings(hdf5r:::convertRoundTrip(dbl_vec, dtype_int64, flags=h5const$H5TOR_CONV_INT64_NOLOSS))
    expect_equal(dbl_vec_int64, res_dbl_int64_noloss$output)

    res_dbl_int64_noloss_short_int <- hdf5r:::convertRoundTrip(dbl_vec[abs(dbl_vec) < 2^31], dtype_int64,
                                                               flags=h5const$H5TOR_CONV_INT64_NOLOSS)
    expect_equal(as.integer(dbl_vec[abs(dbl_vec) < 2^31]), res_dbl_int64_noloss_short_int$output)
    res_dbl_int64_noloss_short_float <- hdf5r:::convertRoundTrip(dbl_vec[abs(dbl_vec) < 2^51], dtype_int64,
                                                                 flags=h5const$H5TOR_CONV_INT64_NOLOSS)
    expect_equal(as.numeric(dbl_vec[abs(dbl_vec) < 2^51]), res_dbl_int64_noloss_short_float$output)


    ## forced coercion to double
    suppressWarnings(res_dbl_int64_force <- hdf5r:::convertRoundTrip(dbl_vec, dtype_int64, flags=h5const$H5TOR_CONV_INT64_FLOAT_FORCE))
    expect_equal(suppressWarnings(as.numeric(dbl_vec_int64)), res_dbl_int64_force$output)


})



---
File: /tests/testthat/test-convert.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("Conversion")


truncateVec <- function(x, min, max) {
    x[is.na(x) | x < min] <- min
    x[!is.na(x) & x > max] <- max
    return(x)
}


test_that("Convert H5T_FLOAT works", {
    dtype_double <- h5types$H5T_NATIVE_DOUBLE
    dtype_float <- h5types$H5T_NATIVE_FLOAT
    ## with double input
    Robj <- (-10:10) / 2
    res_double <- convertRoundTrip(Robj, dtype_double)
    res_float <- convertRoundTrip(Robj, dtype_float)
    expect_equal(res_double$input, res_double$output)

    ## with integer input
    Robj_int <- -10:10
    res_int_double <- convertRoundTrip(Robj_int, dtype_double)
    res_int_float <- convertRoundTrip(Robj_int, dtype_float)
    expect_equal(as.double(res_int_double$input), res_int_double$output)
    expect_equal(as.double(res_int_float$input), res_int_float$output)

    ## with 64bit integer input
    Robj_int64 <- as.integer64(-10:10)
    res_int64_double <- convertRoundTrip(Robj_int64, dtype_double)
    res_int64_float <- convertRoundTrip(Robj_int64, dtype_float)
    expect_equal(as.double(res_int64_double$input), res_int64_double$output)
    expect_equal(as.double(res_int64_float$input), res_int64_float$output)
    
})


## Some constants relevant for integers here
SHORT_MIN <- -2^15
SHORT_MAX <- 2^15 - 1
INT_MIN <- as.integer64(-2^31)
INT_MAX <- as.integer64(2^31 - 1)
UINT_MIN <- as.integer64(0)
UINT_MAX <- as.integer64(2^32-1)
INT64_MAX <- as.integer64(2)^62 - 1 + as.integer64(2)^62

test_that("Convert H5T_INTEGER works", {
    dtype_int64 <- h5types$H5T_NATIVE_LLONG
    dtype_uint64 <- h5types$H5T_NATIVE_ULLONG
    dtype_int <- h5types$H5T_NATIVE_INT
    dtype_uint <- h5types$H5T_NATIVE_UINT
    dtype_short <- h5types$H5T_NATIVE_SHORT
    dtype_double <- h5types$H5T_NATIVE_DOUBLE

    robj_int64 <- c(as.integer64(c(-1, 1, 2^31-1, 2^31)), as.integer(2)^62, suppressWarnings(as.integer64(2^64)))
    robj_double <- c(-1, 1, 2^31-1, 2^31, 2^62, 2^64, 2^64+2^30)
    robj_double_int64 <- suppressWarnings(as.integer64(robj_double))
    robj_double_int64[is.na(robj_double_int64)] <- INT64_MAX
    robj_double_int64[robj_double_int64 < 0] <- 0
    
    res_double_uint64 <- convertRoundTrip(robj_double, dtype_uint64)
    res_int64_int64 <- convertRoundTrip(robj_int64, dtype_int64)
    res_int64_int <- suppressWarnings(convertRoundTrip(robj_int64, dtype_int))
    res_int64_uint <- suppressWarnings(convertRoundTrip(robj_int64, dtype_uint))
    res_int64_short <- suppressWarnings(convertRoundTrip(robj_int64, dtype_short))
    suppressWarnings(res_double_int64 <- convertRoundTrip(robj_double, dtype_int64))
    suppressWarnings(res_double_int <- convertRoundTrip(robj_double, dtype_int))
    suppressWarnings(res_double_uint <- convertRoundTrip(robj_double, dtype_uint))
    suppressWarnings(res_double_short <- convertRoundTrip(robj_double, dtype_short))

    expect_equal(res_int64_int64$input, res_int64_int64$output)
    expect_equal(suppressWarnings(as.integer(res_int64_int$input)), res_int64_int$output)
    expect_equal(as.numeric(truncateVec(res_int64_uint$input, UINT_MIN, UINT_MAX)), res_int64_uint$output)
    expect_equal(as.integer(truncateVec(res_int64_short$input, SHORT_MIN, SHORT_MAX)), res_int64_short$output)
    expect_true(sum(res_double_uint64$output - robj_double_int64) == 0)
})

test_that("Convert H5T_ENUM works", {
    ## Need to test logical, factors and enums with arbitrary values
    obj_logical <- c(FALSE, TRUE)
    obj_factor <- factor(paste("test", 1:10, sep=""))
    obj_factor_ext <- factor_ext(rep(-10:10, 2), levels=paste("test", -10:10, sep=""))
    
    ## object intended to provoke an error
    obj_error <- obj_factor_ext
    attr(obj_error, "values") <- 0:10
    obj_character <- paste("test", 1:10)

    ## create the enums for these cases
    enum_logical <- H5T_LOGICAL$new(include_NA=TRUE)
    enum_factor <- H5T_ENUM$new(labels=levels(obj_factor))
    enum_factor_ext <- H5T_ENUM$new(labels=attr(obj_factor_ext, "levels"), values=attr(obj_factor_ext, "values"))
    
    expect_equal(enum_logical$get_values(), as.integer(c(0,1,2)))
    expect_equal(enum_factor$get_values(), 1:10)
    expect_equal(enum_factor_ext$get_values(), -10:10)

    expect_equal(enum_logical$get_labels(), c("FALSE", "TRUE", "NA"))
    expect_equal(enum_factor$get_labels(), levels(obj_factor))
    expect_equal(enum_factor_ext$get_labels(), levels(obj_factor_ext))

    library(utils)
    if(compareVersion(h5version(verbose=FALSE), "1.8.16") >= 0) {
        expect_equal(enum_logical$get_precision(), 2)
        expect_equal(enum_factor$get_precision(), 4)
        expect_equal(enum_factor_ext$get_precision(), 5)
    }
    else { ## in 1.8.14 and below, there is an issue getting the native version of an enum
           ## that is based on an non-native type
        expect_equal(enum_logical$get_precision(), 8)
        expect_equal(enum_factor$get_precision(), 8)
        expect_equal(enum_factor_ext$get_precision(), 8)
    }
    
    res_logical <- convertRoundTrip(obj_logical, enum_logical)
    res_factor <- convertRoundTrip(obj_factor, enum_factor)
    res_factor_ext <- convertRoundTrip(obj_factor_ext, enum_factor_ext)
    expect_equal(res_logical$input, res_logical$output)
    expect_equal(res_factor$input, res_factor$output)
    expect_equal(res_factor_ext$input, res_factor_ext$output)

    res_error <- try(convertRoundTrip(obj_error, enum_factor_ext), silent=TRUE)
    res_character <- try(convertRoundTrip(obj_character, enum_factor_ext), silent=TRUE)
    expect_true(inherits(res_error, "try-error"))
    expect_true(inherits(res_character, "try-error"))

    ## check that enums work appropriate with 64 bit values
    enum_64bit <- H5T_ENUM$new(labels="Test", values=INT_MAX + 1)
    expect_equal(enum_64bit$get_values(), INT_MAX + 1)
})

test_that("Convert H5T_STRING works", {
#    string1.utf8 <- "\x46\x6F\x6F\x20\xC2\xA9\x20\x62\x61\x72\x20\xF0\x9D\x8C\x86\x20\x62\x61\x7A\x20\xE2\x98\x83\x20\x71\x75\x78"
#    Encoding(string1.utf8) <- "UTF-8"
    string.latin1 <- "H\xF6her w\xE4re sch\xF6ner!"
    Encoding(string.latin1) <- "latin1"
    string.utf8 <- enc2utf8(string.latin1)

    stringVec <- paste("test", 1:10)

    dtype_string_unknown <- H5T_STRING$new()$set_size(30)$set_cset("unknown")
    dtype_string_utf8 <- H5T_STRING$new()$set_size(30)$set_cset("UTF-8")
    dtype_string_short_unknown <- H5T_STRING$new()$set_size(10)$set_cset(h5const$H5T_CSET_ASCII)
    dtype_string_short_utf8 <- H5T_STRING$new()$set_size(10)$set_cset(h5const$H5T_CSET_UTF8)
    dtype_string_variable_unknown <- H5T_STRING$new()$set_size(Inf)$set_cset(h5const$H5T_CSET_ASCII)
    dtype_string_variable_utf8 <- H5T_STRING$new()$set_size(Inf)$set_cset(h5const$H5T_CSET_UTF8)

##    res_string1_utf8_unknown <- convertRoundTrip(string1.utf8, dtype_string_unknown)
##    res_string1_utf8_utf8 <- convertRoundTrip(string1.utf8, dtype_string_utf8)
##    res_string1_utf8_short_unknown <- convertRoundTrip(string1.utf8, dtype_string_short_unknown)
##    res_string1_utf8_short_utf8 <- convertRoundTrip(string1.utf8, dtype_string_short_utf8)
##    res_string1_utf8_variable_unknown <- convertRoundTrip(string1.utf8, dtype_string_variable_unknown)
##    res_string1_utf8_variable_utf8 <- convertRoundTrip(string1.utf8, dtype_string_variable_utf8)

    res_string_utf8_unknown <- convertRoundTrip(string.utf8, dtype_string_unknown)
    res_string_utf8_utf8 <- convertRoundTrip(string.utf8, dtype_string_utf8)
    res_string_utf8_short_unknown <- convertRoundTrip(string.utf8, dtype_string_short_unknown)
    res_string_utf8_short_utf8 <- convertRoundTrip(string.utf8, dtype_string_short_utf8)
    res_string_utf8_variable_unknown <- convertRoundTrip(string.utf8, dtype_string_variable_unknown)
    res_string_utf8_variable_utf8 <- convertRoundTrip(string.utf8, dtype_string_variable_utf8)

    res_string_latin1_unknown <- convertRoundTrip(string.latin1, dtype_string_unknown)
    res_string_latin1_utf8 <- convertRoundTrip(string.latin1, dtype_string_utf8)
    res_string_latin1_short_unknown <- convertRoundTrip(string.latin1, dtype_string_short_unknown)
    res_string_latin1_short_utf8 <- convertRoundTrip(string.latin1, dtype_string_short_utf8)
    res_string_latin1_variable_unknown <- convertRoundTrip(string.latin1, dtype_string_variable_unknown)
    res_string_latin1_variable_utf8 <- convertRoundTrip(string.latin1, dtype_string_variable_utf8)

    ## now check only the ones where we expect equality depending on the locale
    if(l10n_info()[["UTF-8"]]) { ## check if the current locale is UTF-8
        expect_equal(res_string_utf8_unknown$input, res_string_utf8_unknown$output)
        expect_equal(res_string_utf8_variable_unknown$input, res_string_utf8_variable_unknown$output)
    }
    if(l10n_info()[["Latin-1"]]) {
        expect_equal(res_string_latin1_unknown$input, res_string_latin1_unknown$output)
        expect_equal(res_string_latin1_variable_unknown$input, res_string_latin1_variable_unknown$output)
    }
    ## now the ones where we always expect equality, because the utf-8 charset is specified in the dtype
    expect_equal(res_string_utf8_utf8$input, res_string_utf8_utf8$output)
    expect_equal(res_string_utf8_variable_utf8$input, res_string_latin1_variable_utf8$output)
    expect_equal(res_string_latin1_utf8$input, res_string_utf8_utf8$output)
    expect_equal(res_string_latin1_variable_utf8$input, res_string_latin1_variable_utf8$output)

    ## for the short, we just check that the length of the returned string is 10
    expect_equal(length(charToRaw(res_string_utf8_short_utf8$output)), 10)
    expect_equal(length(charToRaw(res_string_utf8_short_unknown$output)), 10)
    expect_equal(length(charToRaw(res_string_latin1_short_utf8$output)), 10)
    expect_equal(length(charToRaw(res_string_latin1_short_utf8$output)), 10)

    ## convert an entire vector
    res_stringVec_fixed <- convertRoundTrip(stringVec, dtype_string_utf8)
    res_stringVec_variable <- convertRoundTrip(stringVec, dtype_string_variable_utf8)
    expect_equal(res_stringVec_fixed$input, res_stringVec_fixed$output)
    expect_equal(res_stringVec_variable$input, res_stringVec_variable$output)

    ## convert a string that is NA
    string_NA <- as.character(NA)
    res_stringNA <- convertRoundTrip(string_NA, dtype_string_variable_utf8)
    expect_equal("NA", res_stringNA$output)
})


test_that("Convert R_Complex works", {
    r_cmplx <- complex(real=-5:5, imaginary = 5:(-5))
    dtype_complex <- H5T_COMPLEX$new()
    res <- convertRoundTrip(r_cmplx, dtype_complex)
    expect_equal(res$input, res$output)
})


test_that("Convert H5T_COMPOUND works", {
    test_frame <- data.frame(a=1:3, b=4:6)
    test_frame_frame <- test_frame
    test_frame_frame$c <- test_frame

    dtype_int <- h5types$H5T_NATIVE_SHORT
    dtype_cpd <- H5T_COMPOUND$new(dtypes=list(dtype_int, dtype_int), labels=c("a", "b"))
    dtype_cpd_cpd <- H5T_COMPOUND$new(dtypes=list(dtype_int, dtype_int, dtype_cpd), labels=c("a", "b", "c"))

    res_test <- convertRoundTrip(test_frame, dtype_cpd)
    res_test2 <- convertRoundTrip(test_frame_frame, dtype_cpd_cpd)
    
    expect_equal(res_test$input, res_test$output)
    expect_equal(res_test2$input, res_test2$output)
})


test_that("Convert H5T_ARRAY works", {
    dtype_array <- H5T_ARRAY$new(dtype_base=h5types$H5T_NATIVE_LLONG, dims=c(2,3))
    test_data <- array(1:120, dim=c(20,2,3))
    res_test <- convertRoundTrip(test_data, dtype_array, nelem=20)
    expect_equal(as.integer(res_test$input), res_test$output)
    expect_equal(dtype_array$get_array_ndims(), 2)
    expect_equal(dtype_array$get_array_dims(), c(2,3))
})


test_that("Convert H5T_VLEN works", {
    dtype_vlen <- H5T_VLEN$new(dtype_base=h5types$H5T_NATIVE_LLONG)
    test_data <- list(a=1:4, b=3:12, c=c(-1.5, 2.5))
    res_test <- convertRoundTrip(test_data, dtype_vlen)
    res_test_input_as_int <- unname(lapply(res_test$input, as.integer))
    expect_equal(res_test_input_as_int, res_test$output)
})


test_that("guess_dtype", {
    ## test array types
    int_array <- guess_dtype(as.integer(1:4), scalar=TRUE)
    expect_equal(int_array$get_class(), h5const$H5T_ARRAY)
    expect_equal(int_array$get_super()$get_class(), h5const$H5T_INTEGER)
    expect_equal(int_array$get_array_dims(), 4)
    int_array2 <- guess_dtype(matrix(as.integer(1:4), ncol=2), scalar=TRUE)
    expect_equal(int_array2$get_class(), h5const$H5T_ARRAY)
    expect_equal(int_array2$get_super()$get_class(), h5const$H5T_INTEGER)
    expect_equal(int_array2$get_array_dims(), c(2,2))

    ## test data frame
    cpd_type <- guess_dtype(data.frame(a=1:4, b=5:8/2), scalar=FALSE)
    expect_equal(cpd_type$get_class(), h5const$H5T_COMPOUND)
    expect_equal(cpd_type$get_cpd_labels(), c("a", "b"))
    expect_equal(cpd_type$get_cpd_classes(), c(h5const$H5T_INTEGER, h5const$H5T_FLOAT))
    
    ## test list
    list_equal_length_type <- guess_dtype(list(a=1:4, b=5:8/2), scalar=FALSE)
    expect_equal(list_equal_length_type$get_class(), h5const$H5T_COMPOUND)

    list_unequal_length_type <- guess_dtype(list(a=1:4, b=1:8), scalar=FALSE)
    expect_equal(list_unequal_length_type$get_class(), h5const$H5T_VLEN)
    
    ## test factor_ext
    factor_ext_type <- guess_dtype(factor_ext(c("a", "b"), values=2:3))
    expect_equal(factor_ext_type$get_class(), h5const$H5T_ENUM)
    
    ## test factor
    factor_ext_type <- guess_dtype(factor(c("a", "b")))
    expect_equal(factor_ext_type$get_class(), h5const$H5T_ENUM)

    ## test character
    char_type <- guess_dtype("asdf", string_len="estimate")
    expect_equal(char_type$get_class(), h5const$H5T_STRING)
    expect_equal(char_type$get_size(), 5)

    char_10_type <- guess_dtype("asdf", string_len = 10)
    expect_equal(char_10_type$get_class(), h5const$H5T_STRING)
    expect_equal(char_10_type$get_size(), 10)

    char_Inf_type <- guess_dtype("asdf", string_len = Inf)
    expect_equal(char_Inf_type$get_class(), h5const$H5T_STRING)
    expect_equal(char_Inf_type$get_size(), Inf)

    ## test logical
    logical_type <- guess_dtype(TRUE)
    expect_equal(logical_type$get_class(), h5const$H5T_ENUM)
    expect_equal(logical_type$get_labels(), c("FALSE", "TRUE", "NA"))
    
    ## test integer64
    int64_type <- guess_dtype(as.integer64(1))
    expect_equal(int64_type$get_class(), h5const$H5T_INTEGER)
    expect_equal(int64_type$get_size(), 8)
    
    ## test integer
    int_type <- guess_dtype(as.integer(1))
    expect_equal(int_type$get_class(), h5const$H5T_INTEGER)
    expect_equal(int_type$get_size(), 4)

    ## test numeric
    double_type <- guess_dtype(as.double(1))
    expect_equal(double_type$get_class(), h5const$H5T_FLOAT)
    expect_equal(double_type$get_size(), 8)

    ## test complex
    complex_type <- guess_dtype(complex(length.out=1, real=1, imaginary=1))
    expect_equal(complex_type$get_class(), h5const$H5T_COMPOUND)
    expect_equal(complex_type$get_cpd_labels(), c("Real", "Imaginary"))

    ## test matrix; here was a bug where it always created an array for a matrix
    ## that is why we have the test here
    int_dtype <- guess_dtype(matrix(as.integer(1:10), ncol=2))
    expect_equal(int_dtype$get_class(), h5const$H5T_INTEGER)
})

test_that("guess_space", {
    Robj <- matrix(1:100, nrow=10)
    dtype_int <- h5types$H5T_NATIVE_INT
    dtype_array <- H5T_ARRAY$new(dims=10, dtype_base=dtype_int)

    space_int_chunked <- guess_space(Robj, dtype_int, chunked=TRUE)
    expect_equal(space_int_chunked$get_simple_extent_dims(), list(rank=2, dims=c(10,10), maxdims=c(Inf, Inf)))
    space_int_unchunked <- guess_space(Robj, dtype_int, chunked=FALSE)
    expect_equal(space_int_unchunked$get_simple_extent_dims(), list(rank=2, dims=c(10,10), maxdims=c(10, 10)))
    space_array_chunked <- guess_space(Robj, dtype_array, chunked=TRUE)
    expect_equal(space_array_chunked$get_simple_extent_dims(), list(rank=1, dims=c(10), maxdims=c(Inf)))
    space_array_unchunked <- guess_space(Robj, dtype_array, chunked=FALSE)
    expect_equal(space_array_unchunked$get_simple_extent_dims(), list(rank=1, dims=c(10), maxdims=c(10)))
})


test_that("guess_chunks", {
    expect_equal(guess_chunks(c(10, 10), 8, 8 * 200), c(10,10))
    expect_equal(guess_chunks(c(100, 100), 8, 8 * 200), c(15,15))

    expect_equal(guess_chunks(c(5, 2, 4), 8, 8 * 200), c(5, 2, 4))
    expect_equal(guess_chunks(c(5, 2, 50), 8, 8 * 200), c(5, 2, 20))
    expect_equal(guess_chunks(c(50, 2, 50), 8, 8 * 200), c(10, 2, 10))
})

test_that("reorder", {
    array_rank3 <- array(as.integer(1:60), dim=c(3,4,5))
    ## item size is 4 bytes per integer
    array_reorder_c <- array_reorder(array_rank3, c(3,4,5), 2, 4:1, 4)
    array_reorder_r <- array_rank3[, 4:1,]
    expect_equal(array_reorder_c, array_reorder_r)
})


test_that("Logical with and without NA", {
    logical_NA <- c(TRUE, FALSE, NA)
    logical_noNA <- c(TRUE, FALSE)

    dtype_logical_noNA <- h5types$H5T_LOGICAL
    dtype_logical_NA <- h5types$H5T_LOGICAL_NA

    res_noNA_noNA <- convertRoundTrip(logical_noNA, dtype_logical_noNA)  
    res_NA_noNA <- try(convertRoundTrip(logical_NA, dtype_logical_noNA), silent=TRUE)  
    res_noNA_NA <- convertRoundTrip(logical_noNA, dtype_logical_NA)  
    res_NA_NA <- convertRoundTrip(logical_NA, dtype_logical_NA)

    expect_equal(res_noNA_noNA$input, res_noNA_noNA$output)
    expect_true(inherits(res_NA_noNA, "try-error"));
    expect_equal(res_noNA_NA$input, res_noNA_NA$output)
    expect_equal(res_NA_NA$input, res_NA_NA$output)
})



---
File: /tests/testthat/test-factor_ext.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("factor_ext")

test_that("Factor_ext", {
    test1 <- factor_ext(x=c("Test1", "Test2", "Test1"), values=c(0,1))
    test2 <- factor_ext(x=c("Test1", "Test2", "Test1"), values=c(1,2))

    ## make sure that test2 is coercible to a factor
    expect_true(!coercible_to_factor(test1))
    expect_true(coercible_to_factor(test2))

    test2_as_factor <- coerce_to_factor(test2)
    test2_factor <- factor(c("Test1", "Test2", "Test1"))
    expect_equal(test2_as_factor, test2_factor)

    expect_equal(levels(test1), c("Test1", "Test2"))
    expect_equal(values(test1), c(0,1))
    
    expect_true(all(test1 == c("Test1", "Test2", "Test1")))
    expect_true(!any(test1 != c("Test1", "Test2", "Test1")))

    test1[2] <- "Test1"
    expect_true(all(test1=="Test1"))

    ## concatenate
    test3 <- c(test1, test1)

    ## equality of factor with itself
    expect_true(all(test1==test1))

    ## test that the values are always ordered
    factor_misordered <- factor_ext(x=c("Test1", "Test2", "Test1"), values=c(1, 0), levels=c("Test2", "Test1"))
    expect_equal(values(factor_misordered), c(0,1))
    expect_equal(levels(factor_misordered), c("Test1", "Test2"))
})



---
File: /tests/testthat/test-h5a.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5A")

read_write_roundtrip <- function(h5attr, robj) {
    h5attr$write(robj)
    res <- h5attr$read()
    return(list(input=robj, output=res))
}

test_that("Basic dataset function", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    dtype_int64 <- h5types$H5T_NATIVE_LLONG
    dspace <- H5S$new(type="simple", dims=20, maxdims=20)
    attr_int64 <- file.h5$create_attr(attr_name="int64", dtype=dtype_int64, space=dspace)
    
    ## test out the basic functions
    dspace_new <- attr_int64$get_space()
    expect_true(inherits(dspace_new, "H5S"))
    expect_equal(dspace_new$get_simple_extent_dims()$dims, 20)

    expect_true(attr_int64$get_type()$equal(h5types$H5T_NATIVE_LLONG))

    expect_equal(attr_int64$get_storage_size(), 160)
    res_int64 <- read_write_roundtrip(attr_int64, 1:20)

    file.h5$flush()

    expect_equal(attr_int64$get_storage_size(), 160)

    ## rename the attributes; get info by name and by idx;
    ## try out the various functions that originate from the file or the group
    file.h5$create_group("sub")
    attr_int64_sub <- file.h5$create_attr_by_name("int64", "sub", dtype=dtype_int64, space=dspace)
    expect_equal(attr_int64_sub$attr_name(), "int64")

    attr_int64_sub_name <- file.h5$attr_open_by_name("int64", "sub")
    expect_equal(attr_int64_sub_name$attr_name(), "int64")

    attr_int64_sub_index <- file.h5$attr_open_by_idx(0, "sub")
    expect_equal(attr_int64_sub_index$attr_name(), "int64")

    ## check the exists function
    expect_true(file.h5$attr_exists_by_name("int64", "sub"))
    expect_true(file.h5$open("sub")$attr_exists("int64"))

    ## rename the attribute and then back again
    file.h5$attr_rename_by_name("int64", "int64_new", "sub")
    expect_true(file.h5$attr_exists_by_name("int64_new", "sub"))
    expect_true(!file.h5$attr_exists_by_name("int64", "sub"))
    file.h5$open("sub")$attr_rename("int64_new", "int64")
    expect_true(file.h5$attr_exists_by_name("int64", "sub"))
    expect_true(!file.h5$attr_exists_by_name("int64_new", "sub"))


    ## get attribute info by various ways
    attr_info_direct <- attr_int64_sub$get_info()
    attr_info_name <- file.h5$attr_info_by_name("int64", "sub")
    attr_info_idx <- file.h5$open("sub")$attr_info_by_idx(0, ".")
    expect_equal(attr_info_direct, attr_info_name)
    expect_equal(attr_info_direct, attr_info_idx)
    

    ## delete the attribute in various ways
    ## for that we first need to create a few more
    file.h5$create_attr_by_name("int64_copy_1", "sub", dtype=dtype_int64, space=dspace)
    file.h5$create_attr_by_name("int64_copy_2", "sub", dtype=dtype_int64, space=dspace)
    expect_equal(file.h5$obj_info_by_name("sub")$num_attrs, 3)

    ## check the attribute names by idx
    expect_equal(file.h5$attr_name_by_idx(0, "sub"), "int64")
    expect_equal(file.h5$attr_name_by_idx(1, "sub"), "int64_copy_1")
    expect_equal(file.h5$attr_name_by_idx(2, "sub"), "int64_copy_2")

    ## check that from the group we can retrieve the correct number of attributes
    group_sub <- file.h5[["sub"]]
    expect_equal(group_sub$attr_get_number(), 3)
    
    ## now delete each of them in one of the 3 possible ways
    file.h5$open("sub")$attr_delete("int64")
    file.h5$attr_delete_by_name("int64_copy_1", "sub")
    file.h5$attr_delete_by_idx(0, "sub")

    ## now check that there are no attributes left
    expect_equal(file.h5$obj_info_by_name("sub")$num_attrs, 0)
    
    ## cleanup
    file.h5$close_all()
    file.remove(test_file)
})

test_that("Creating attributes of different types", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    ## now create different types
    ## integer, long integer, float, enum, compound, strings
    ## create a dataset for each of them
    dtype_int64 <- h5types$H5T_NATIVE_LLONG
    dtype_int32 <- h5types$H5T_NATIVE_INT
    dtype_float <- h5types$H5T_NATIVE_FLOAT
    dtype_double <- h5types$H5T_NATIVE_DOUBLE

    ## enums
    enum_logical <- H5T_LOGICAL$new()
    factor_levels <- paste("test", 1:10, sep="")
    enum_factor <- H5T_ENUM$new(labels=factor_levels)

    ## strings
    dtype_string_variable_utf8 <- H5T_STRING$new()$set_size(Inf)$set_cset(h5const$H5T_CSET_UTF8)
    dtype_string_short_utf8 <- H5T_STRING$new()$set_size(10)$set_cset(h5const$H5T_CSET_UTF8)

    ## compound
    dtype_cpd <- H5T_COMPOUND$new(dtypes=list(dtype_int32, dtype_int32), labels=c("a", "b"))


    ## now create a simple dataspace for the new objects;
    ## will be the same for all, single dimension of size 20
    attrspace <- H5S$new(type="simple", dims=20, maxdims=20)

    ## create named datasets for all these types
    attr_int64 <- file.h5$create_attr(attr_name="int64", dtype=dtype_int64, space=attrspace)
    attr_int32 <- file.h5$create_attr(attr_name="int32", dtype=dtype_int32, space=attrspace)
    attr_float <- file.h5$create_attr(attr_name="float", dtype=dtype_float, space=attrspace)
    attr_double <- file.h5$create_attr(attr_name="double", dtype=dtype_double, space=attrspace)
    attr_logical <- file.h5$create_attr(attr_name="enum_logical", dtype=enum_logical, space=attrspace)
    attr_factor <- file.h5$create_attr(attr_name="enum_factor", dtype=enum_factor, space=attrspace)
    attr_string_short <- file.h5$create_attr(attr_name="string_short", dtype=dtype_string_short_utf8, space=attrspace)
    attr_string_variable <- file.h5$create_attr(attr_name="string_variable", dtype=dtype_string_variable_utf8, space=attrspace)
    attr_cpd <- file.h5$create_attr(attr_name="cpd", dtype=dtype_cpd, space=attrspace)

        ## now write data into the dataset, and read it back out again
    res_int32 <- read_write_roundtrip(attr_int32, 1:20)
    expect_equal(res_int32$input, res_int32$output)

    res_int64 <- read_write_roundtrip(attr_int64, 1:20)
    expect_equal(res_int64$input, res_int64$output)

    res_float <- read_write_roundtrip(attr_float, 1:20/4)
    expect_equal(res_float$input, res_float$output)

    res_double <- read_write_roundtrip(attr_double, 1:20/4)
    expect_equal(res_double$input, res_double$output)

    res_logical <- read_write_roundtrip(attr_logical, rep(c(FALSE, TRUE), 10))
    expect_equal(res_logical$input, res_logical$output)

    res_factor <- read_write_roundtrip(attr_factor, factor(rep(paste("test", 1:10, sep=""), 2), levels=paste("test", 1:10, sep="")))
    expect_equal(res_factor$input, res_factor$output)

    res_string_short <- read_write_roundtrip(attr_string_short, rep(paste("teststring", 1:20, sep="")))
    expect_equal(substr(res_string_short$input, 1,10), res_string_short$output)

    res_string_variable <- read_write_roundtrip(attr_string_variable, rep(paste("teststring", 1:20, sep="")))
    expect_equal(res_string_variable$input, res_string_variable$output)

    res_cpd <- read_write_roundtrip(attr_cpd, data.frame(a=1:20, b=21:40))
    expect_equal(res_cpd$input, res_cpd$output)
    
    file.h5$close_all()
    file.remove(test_file)
})



test_that("Creating attributes of different types of length 0", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    ## now create different types
    ## integer, long integer, float, enum, compound, strings
    ## create a dataset for each of them
    dtype_int64 <- h5types$H5T_NATIVE_LLONG
    dtype_int32 <- h5types$H5T_NATIVE_INT
    dtype_float <- h5types$H5T_NATIVE_FLOAT
    dtype_double <- h5types$H5T_NATIVE_DOUBLE

    ## enums
    enum_logical <- H5T_LOGICAL$new()
    factor_levels <- paste("test", 1:10, sep="")
    enum_factor <- H5T_ENUM$new(labels=factor_levels)

    ## strings
    dtype_string_variable_utf8 <- H5T_STRING$new()$set_size(Inf)$set_cset(h5const$H5T_CSET_UTF8)
    dtype_string_short_utf8 <- H5T_STRING$new()$set_size(10)$set_cset(h5const$H5T_CSET_UTF8)

    ## compound
    dtype_cpd <- H5T_COMPOUND$new(dtypes=list(dtype_int32, dtype_int32), labels=c("a", "b"))


    ## now create a simple dataspace for the new objects;
    ## will be the same for all, single dimension of size 0
    attrspace <- H5S$new(type="simple", dims=0, maxdims=0)

    ## create named datasets for all these types
    attr_int64 <- file.h5$create_attr(attr_name="int64", dtype=dtype_int64, space=attrspace)
    attr_int32 <- file.h5$create_attr(attr_name="int32", dtype=dtype_int32, space=attrspace)
    attr_float <- file.h5$create_attr(attr_name="float", dtype=dtype_float, space=attrspace)
    attr_double <- file.h5$create_attr(attr_name="double", dtype=dtype_double, space=attrspace)
    attr_logical <- file.h5$create_attr(attr_name="enum_logical", dtype=enum_logical, space=attrspace)
    attr_factor <- file.h5$create_attr(attr_name="enum_factor", dtype=enum_factor, space=attrspace)
    attr_string_short <- file.h5$create_attr(attr_name="string_short", dtype=dtype_string_short_utf8, space=attrspace)
    attr_string_variable <- file.h5$create_attr(attr_name="string_variable", dtype=dtype_string_variable_utf8, space=attrspace)
    attr_cpd <- file.h5$create_attr(attr_name="cpd", dtype=dtype_cpd, space=attrspace)

        ## now write data into the dataset, and read it back out again
    res_int32 <- read_write_roundtrip(attr_int32, integer(0))
    expect_equal(res_int32$input, res_int32$output)

    res_int64 <- read_write_roundtrip(attr_int64, integer(0))
    expect_equal(res_int64$input, res_int64$output)

    res_float <- read_write_roundtrip(attr_float, numeric(0))
    expect_equal(res_float$input, res_float$output)

    res_double <- read_write_roundtrip(attr_double, numeric(0))
    expect_equal(res_double$input, res_double$output)

    res_logical <- read_write_roundtrip(attr_logical, logical(0))
    expect_equal(res_logical$input, res_logical$output)

    res_factor <- read_write_roundtrip(attr_factor, factor(character(0), levels=paste("test", 1:10, sep="")))
    expect_equal(res_factor$input, res_factor$output)

    res_string_short <- read_write_roundtrip(attr_string_short, character(0))
    expect_equal(substr(res_string_short$input, 1,10), res_string_short$output)

    res_string_variable <- read_write_roundtrip(attr_string_variable, character(0))
    expect_equal(res_string_variable$input, res_string_variable$output)

    res_cpd <- read_write_roundtrip(attr_cpd, data.frame(a = numeric(0), b = numeric(0)))
    expect_equal(res_cpd$input, res_cpd$output)
    
    file.h5$close_all()
    file.remove(test_file)
})



---
File: /tests/testthat/test-h5d.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



context("H5D")

read_write_roundtrip <- function(ds, robj) {
    ds$write_low_level(robj)
    res <- ds$read()
    return(list(input=robj, output=res))
}

test_that("Basic dataset function", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    dtype_int64 <- h5types$H5T_NATIVE_LLONG
    dspace <- H5S$new(type="simple", dims=20, maxdims=20)
    ds_int64_chunked <- file.h5$create_dataset(name="int64_chunked", dtype=dtype_int64, space=dspace)
    
    ## test out the basic functions
    dspace_new <- ds_int64_chunked$get_space()
    expect_true(inherits(dspace_new, "H5S"))
    expect_equal(dspace_new$get_simple_extent_dims()$dims, 20)
    expect_equal(as.character(ds_int64_chunked$get_space_status()), "H5D_SPACE_STATUS_NOT_ALLOCATED")
    expect_equal(ds_int64_chunked$dims, 20)
    expect_equal(ds_int64_chunked$maxdims, 20)
    expect_equal(ds_int64_chunked$chunk_dims, 20)
    
    expect_true(ds_int64_chunked$get_type()$equal(h5types$H5T_NATIVE_LLONG))

    expect_equal(ds_int64_chunked$get_storage_size(), 0)
    expect_equal(ds_int64_chunked$vlen_get_buf_size(ds_int64_chunked$get_type(), ds_int64_chunked$get_space()), 0)
    res_int64 <- read_write_roundtrip(ds_int64_chunked, 1:20)

    file.h5$flush()

    expect_equal(ds_int64_chunked$get_storage_size(), 49)
    expect_true(inherits(try(ds_int64_chunked$get_offset(), silent=TRUE), "try-error"))
    ## vlen is still 0, as it is not variable length data
    expect_equal(ds_int64_chunked$vlen_get_buf_size(ds_int64_chunked$get_type(), ds_int64_chunked$get_space()), 0)

    ## now try the same, unchunked
    ds_int64_unchunked <- file.h5$create_dataset(name="int64_unchunked", dtype=dtype_int64, space=dspace, chunk_dim=NULL)
    res_int64_unchunked <- read_write_roundtrip(ds_int64_unchunked, 1:20)
    expect_equal(ds_int64_unchunked$get_storage_size(), 160)
    expect_equal(ds_int64_unchunked$chunk_dims, NA)


    ## now write a dataset directly
    ds_int64_robj <- file.h5$create_dataset(name="int64_robj", 1:20)
    ## check that we can read the data out
    expect_equal(ds_int64_robj$read_low_level(), 1:20)

    ## also try it with a 2-dimensional space; and a version with a one-dimensional space and an internal array
    array_type <- H5T_ARRAY$new(4, h5types$H5T_NATIVE_INT)
    ds_array <- file.h5$create_dataset(name="int_array", dtype=array_type, space=H5S$new(dims=5))
    res_array <- read_write_roundtrip(ds_array, matrix(1:20, ncol=4))
    expect_equal(res_array$input, res_array$output)

    ds_2_dim <- file.h5$create_dataset(name="int_2_dim", dtype=h5types$H5T_NATIVE_INT, space=H5S$new(dims=c(5, 4)))
    res_2_dim <- read_write_roundtrip(ds_2_dim, matrix(1:20, ncol=4))
    expect_equal(res_2_dim$input, res_2_dim$output)

    ## do a read and a write using NULL as an argument
    ds_2_dim$write(args=list(1:5, NULL), value=numeric(0))
    expect_equal(ds_2_dim$read(args=list(1:5, NULL)), matrix(numeric(0), nrow=5, ncol=0))
    
    ## cleanup
    file.h5$close_all()
    file.remove(test_file)
})



test_that("Creating datasets of different types", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    ## now create different types
    ## integer, long integer, float, enum, compound, strings
    ## create a dataset for each of them
    dtype_int64 <- h5types$H5T_NATIVE_LLONG
    dtype_int32 <- h5types$H5T_NATIVE_INT
    dtype_float <- h5types$H5T_NATIVE_FLOAT
    dtype_double <- h5types$H5T_NATIVE_DOUBLE

    ## enums
    enum_logical <- H5T_LOGICAL$new()
    factor_levels <- paste("test", 1:10, sep="")
    enum_factor <- H5T_ENUM$new(labels=factor_levels)

    ## strings
    dtype_string_variable_utf8 <- H5T_STRING$new()$set_size(Inf)$set_cset(h5const$H5T_CSET_UTF8)
    dtype_string_short_utf8 <- H5T_STRING$new()$set_size(10)$set_cset(h5const$H5T_CSET_UTF8)

    ## compound
    dtype_cpd <- H5T_COMPOUND$new(dtypes=list(dtype_int32, dtype_int32), labels=c("a", "b"))


    ## now create a simple dataspace for the new objects;
    ## will be the same for all, single dimension of size 20
    dspace <- H5S$new(type="simple", dims=20, maxdims=20)

    ## create named datasets for all these types
    ds_int64 <- file.h5$create_dataset(name="int64", dtype=dtype_int64, space=dspace)
    ds_int32 <- file.h5$create_dataset(name="int32", dtype=dtype_int32, space=dspace)
    ds_float <- file.h5$create_dataset(name="float", dtype=dtype_float, space=dspace)
    ds_double <- file.h5$create_dataset(name="double", dtype=dtype_double, space=dspace)
    ds_logical <- file.h5$create_dataset(name="enum_logical", dtype=enum_logical, space=dspace)
    ds_factor <- file.h5$create_dataset(name="enum_factor", dtype=enum_factor, space=dspace)
    ds_string_short <- file.h5$create_dataset(name="string_short", dtype=dtype_string_short_utf8, space=dspace)
    ds_string_variable <- file.h5$create_dataset(name="string_variable", dtype=dtype_string_variable_utf8, space=dspace)
    ds_cpd <- file.h5$create_dataset(name="cpd", dtype=dtype_cpd, space=dspace)

    ## also create an anonymous dataset
    ds_anon <- file.h5$create_dataset(dtype=dtype_int64, space=dspace)
    
    ## now write data into the dataset, and read it back out again
    res_int32 <- read_write_roundtrip(ds_int32, 1:20)
    expect_equal(res_int32$input, res_int32$output)

    res_int64 <- read_write_roundtrip(ds_int64, 1:20)
    expect_equal(res_int64$input, res_int64$output)

    res_float <- read_write_roundtrip(ds_float, 1:20/4)
    expect_equal(res_float$input, res_float$output)

    res_double <- read_write_roundtrip(ds_double, 1:20/4)
    expect_equal(res_double$input, res_double$output)

    res_logical <- read_write_roundtrip(ds_logical, rep(c(FALSE, TRUE), 10))
    expect_equal(res_logical$input, res_logical$output)

    res_factor <- read_write_roundtrip(ds_factor, factor(rep(paste("test", 1:10, sep=""), 2), levels=paste("test", 1:10, sep="")))
    expect_equal(res_factor$input, res_factor$output)

    res_string_short <- read_write_roundtrip(ds_string_short, rep(paste("teststring", 1:20, sep="")))
    expect_equal(substr(res_string_short$input, 1,10), res_string_short$output)

    res_string_variable <- read_write_roundtrip(ds_string_variable, rep(paste("teststring", 1:20, sep="")))
    expect_equal(res_string_variable$input, res_string_variable$output)

    res_cpd <- read_write_roundtrip(ds_cpd, data.frame(a=1:20, b=21:40))
    expect_equal(res_cpd$input, res_cpd$output)

    ## check that the fill-value can be retrieved
    expect_equal(ds_int32$get_fill_value(), 0)
    expect_equal(ds_string_short$get_fill_value(), "")
    expect_equal(ds_cpd$get_fill_value(), data.frame(a=0, b=0))


    ## check other ways of creating a dataset
    ## using the dims parameter
    ds_dimsparam <- file.h5$create_dataset(name="dims_param", dtype=dtype_int32, dims=c(2,3,4))
    expect_equal(ds_dimsparam$dims, c(2,3,4))
    res_dimsparam <- read_write_roundtrip(ds_dimsparam, array(1:24 * 2, dim=c(2,3,4)))
    expect_equal(res_dimsparam$input, res_dimsparam$output)
    
    file.h5$close_all()
    file.remove(test_file)
})



test_that("Chunking failures as intended", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    ## create a dataset with a chunk-size that is larger than the dataset itself
    res1 <- try({file.h5$create_dataset("test", dtype=h5types$H5T_NATIVE_INT, space=H5S$new(dims=c(10), maxdims=c(Inf)),
                           chunk_dim=c(20))}, silent=TRUE)
    expect_true(!inherits(res1, "try-error"))
    res2 <- try({file.h5$create_dataset("test2", dtype=h5types$H5T_NATIVE_INT, space=H5S$new(dims=c(10, 10), maxdims=c(Inf, 10)),
                           chunk_dim=c(20, 10))}, silent=TRUE)
    expect_true(!inherits(res2, "try-error"))
    suppressWarnings({res3 <- try({file.h5$create_dataset("test3", dtype=h5types$H5T_NATIVE_INT, space=H5S$new(dims=c(10, 10), maxdims=c(Inf, 10)),
                           chunk_dim=c(20, 20))}, silent=TRUE)})
    expect_true(inherits(res3, "try-error"))

    file.h5$close_all()
    file.remove(test_file)
})





---
File: /tests/testthat/test-h5error.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5Error messages")

test_that("HDF5 error message forwarding", {
    
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    file.h5.again <- try(H5File$new(test_file, mode="w"), silent=TRUE)
    expect_true(inherits(file.h5.again, "try-error"))
    expect_true(grepl("HDF5-API Errors:", file.h5.again))
})


          



---
File: /tests/testthat/test-h5file_h5group.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5File and H5Group")

test_that("File creation", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    ## test that ls works on an empty file
    file.h5$ls()
    
    test1 <- file.h5$create_group("test1")
    test2 <- test1$create_group("test2")

    file_ls <- file.h5$ls(recursive=TRUE)
    expect_equal(file_ls$name, c("test1", "test1/test2"))

    ## also check that ls prints the dimension of a file in the appropriate order when doing ls
    file.h5[["test_matrix"]] <- matrix(0, nrow=10, ncol=5)
    file.h5[["test_vector"]] <- numeric(10)
    ls_res <- file.h5$ls()
    ls_matrix <- ls_res[ls_res$name == "test_matrix",]
    expect_equal(ls_matrix$dataset.dims, "10 x 5")
    expect_equal(ls_matrix$dataset.rank, 2)
    ls_vector <- ls_res[ls_res$name == "test_vector",]
    expect_equal(ls_vector$dataset.dims, "10")
    expect_equal(ls_vector$dataset.rank, 1)
    
    ## test that we can open the group by name and by index
    test1_opened <- file.h5$open("test1")
    test1_opened_idx <- file.h5$open_by_idx(0)
    test2_opened <- test1_opened$open("test2")
    expect_equal(test1_opened$get_obj_name(), test1_opened_idx$get_obj_name())
    expect_equal(test2$get_obj_name(), test2_opened$get_obj_name())

    ## check that exists works
    expect_true(file.h5$exists("test1"))
    expect_true(file.h5$exists("/test1/test2"))
    expect_true(file.h5$path_valid("/test1/test2"))
    
    ## create a new link
    test3 <- test1$link(test2, "test3")

    ## create a new file; copy a group into it; copy a group out of it
    test_file2 <- tempfile(fileext=".h5")
    file.h5.new <- H5File$new(test_file2, mode="w")
    file.h5.new$obj_copy_from(file.h5, "test1", "test_1_copy_from")
    file.h5$obj_copy_to(file.h5.new, "test1_copy_to", "test1")

    ## test getting obj_info in various ways
    obj_info_test1 <- test1$obj_info()
    obj_info_test1_byname <- file.h5$obj_info_by_name("test1")
    obj_info_test1_byindex <- file.h5$obj_info_by_idx(0)
    expect_equal(obj_info_test1, obj_info_test1_byname)
    expect_equal(obj_info_test1, obj_info_test1_byindex)

    ## not just obj info, but also group info
    root_info <- file.h5$group_info()
    test1_info <- test1$group_info()
    root_info_by_name <- file.h5$group_info_by_name(".")
    root_info_by_idx <- file.h5$group_info_by_idx(0)
    expect_equal(root_info, root_info_by_name)
    expect_equal(test1_info, root_info_by_idx)

    ## retrieve the filesize and info and name
    ## in order not to get an error on OSx, need to replace // in filename
    expect_equal(normalizePath(file.h5$get_filename(), mustWork = FALSE), normalizePath(test_file, mustWork=FALSE))
    expect_true(nrow(file.h5$file_info()) == 1)
    expect_true(file.h5$get_filesize() > 0)
        
    ## close the testfile
    file.h5$close_all()
    file.h5.new$close_all()
    expect_true(is_hdf5(test_file))
    
    ## open the testfile again in various different modes
    file.h5 <- H5File$new(test_file, mode="a")
    expect_true(file.h5$exists("test1"))
    file.h5$close_all()
    
    file.h5 <- H5File$new(test_file, mode="r+")
    expect_true(file.h5$exists("test1"))
    file.h5$close_all()

    file.h5 <- H5File$new(test_file, mode="r")
    expect_true(file.h5$exists("test1"))
    file.h5$close_all()

    suppressWarnings(foo <- try({file.h5 <- H5File$new(test_file, mode="x")}, silent=TRUE))
    expect_true(inherits(foo, "try-error"))

    
    test_file3 <- tempfile(fileext=".h5")
    file.h5 <- H5File$new(test_file3, mode="x")
    expect_true(!is.na(file.h5$id))
    file.h5$close_all()
    
    file.remove(test_file)
    file.remove(test_file2)
    file.remove(test_file3)
})



test_that("File mounting", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    test_file2 <- tempfile(fileext=".h5")
    file2.h5 <- H5File$new(test_file2, mode="w")

    ## now create a a group in each of them, as well as some data
    grp1 <- file.h5$create_group("grp1")
    grp2 <- file2.h5$create_group("grp2")

    file.h5[["grp1"]][["num_vec"]] <- 1:10
    file2.h5[["grp2"]][["char_vec"]] <- LETTERS[1:10]

    
    file.h5$mount("grp1", file2.h5)

    grp1_mount <- file.h5[["grp1"]]

    ## now check what can be accesses using ls
    ## from grp1 - only the dataset
    ## from grp1_mount, we can access grp2
    expect_equal(grp1$ls()$name, "num_vec")
    expect_equal(grp1_mount$ls()$name, "grp2")

    expect_equal(grp1$group_info()$mounted, 1)
    expect_equal(grp1_mount$group_info()$mounted, 0)

    ## now unmount
    file.h5$unmount("grp1")
    expect_equal(grp1$group_info()$mounted, 0)
    expect_equal(file.h5[["grp1"]]$ls()$name, "num_vec")
   
    file.h5$close_all()
    file2.h5$close_all()
    file.remove(test_file)
    file.remove(test_file2)
})



---
File: /tests/testthat/test-h5I.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5I")

test_that("Interface functions in H5RefClass", {
    ## create a datatype, check that it is a datatype
    ## get the ref_count, increase it, decrease it, return
    dtype_int32 <- h5types$H5T_NATIVE_INT
    expect_equal(as.character(dtype_int32$get_obj_type()), "H5I_DATATYPE")
    expect_equal(dtype_int32$get_ref(), 1)
    dtype_int32$inc_ref()
    expect_equal(dtype_int32$get_ref(), 2)
    dtype_int32$dec_ref()
    expect_equal(dtype_int32$get_ref(), 1)
})

          



---
File: /tests/testthat/test-h5p.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################



context("H5P")

test_that("H5P works", {
    h5p_obj <- H5P_factory(h5const$H5P_DATASET_CREATE)
    ## now test out the various standard functions
    h5p_cls <- h5p_obj$get_class()
    expect_true(h5p_cls$equal(h5const$H5P_DATASET_CREATE))

    h5p_cls_name <- h5p_obj$get_class_name()
    expect_equal(h5p_cls_name, "dataset create")

    h5p_obj_cpy <- h5p_obj$copy()
    expect_true(h5p_obj$equal(h5p_obj_cpy))

})

test_that("H5P_FILE_CREATE works", {
    file_create_pl <- H5P_FILE_CREATE$new()
    file_create_pl$set_userblock(1024)
    expect_equal(file_create_pl$get_userblock(), 1024)

    file_create_pl$set_sizes(16, 16)
    expect_equal(file_create_pl$get_sizes(), list(sizeof_addr=16, sizeof_size=16))

    file_create_pl$set_sym_k(32, 8)
    expect_equal(file_create_pl$get_sym_k(), list(ik=32, lk=8))

    file_create_pl$set_istore_k(32)
    expect_equal(file_create_pl$get_istore_k(), 32)

    require(utils)
    if(compareVersion(h5version(verbose=FALSE), "1.10.0") >= 0) { # functions only available in 1.10.0
        file_create_pl$set_file_space(h5const$H5F_FILE_SPACE_ALL_PERSIST, 2)
        foo <- file_create_pl$get_file_space()
        expect_equal(foo$threshold, 2)
        expect_equal(as.character(foo$strategy), as.character(h5const$H5F_FILE_SPACE_ALL_PERSIST))
    }

})

test_that("H5P_FILE_ACCESS works", {
    file_access_pl <- H5P_FILE_ACCESS$new()
    file_access_pl$set_cache(953, 2^24, 0.5)
    cache_params <- file_access_pl$get_cache()
    expect_equal(cache_params, list(rdcc_nslots=953, rdcc_nbytes=2^24, rdcc_w0=0.5))
})


test_that("H5P_DATASET_CREATE works", {
    h5p_obj <- H5P_DATASET_CREATE$new()
    h5p_obj$set_layout(layout=h5const$H5D_CHUNKED)
    expect_equal(as.character(h5p_obj$get_layout()), "H5D_CHUNKED")

    ## get/set chunk
    h5p_obj$set_chunk(chunk=c(100, 200))
    expect_equal(h5p_obj$get_chunk(2), c(100,200))

    ## get/set fill value
    dtype_int <- h5types$H5T_NATIVE_INT
    h5p_obj$set_fill_value(dtype_int, 1)
    expect_equal(h5p_obj$get_fill_value(dtype_int), 1)

    ## get/set fill time
    h5p_obj$set_fill_time(h5const$H5D_FILL_TIME_NEVER)
    expect_equal(h5p_obj$get_fill_time(), h5const$H5D_FILL_TIME_NEVER)

    ## get/set alloc time
    h5p_obj$set_alloc_time(h5const$H5D_ALLOC_TIME_EARLY)
    expect_equal(h5p_obj$get_alloc_time(), h5const$H5D_ALLOC_TIME_EARLY)

    ## try out various filters
    h5p_obj$set_deflate(3)
    expect_equal(h5p_obj$get_nfilters(), 1)
    expect_equal(h5p_obj$get_filter(0)$filter, h5const$H5Z_FILTER_DEFLATE)
    expect_true(    h5p_obj$all_filters_avail())
    h5p_obj$remove_filter()
    expect_equal(h5p_obj$get_nfilters(), 0)

    h5p_obj$set_fletcher32()
    h5p_obj$set_nbit()
    h5p_obj$set_scaleoffset()
    h5p_obj$set_shuffle()

    expect_equal(h5p_obj$get_nfilters(), 4)
    expect_equal(h5p_obj$get_filter(0)$filter, h5const$H5Z_FILTER_FLETCHER32)
    expect_equal(h5p_obj$get_filter(1)$filter, h5const$H5Z_FILTER_NBIT)
    expect_equal(h5p_obj$get_filter(2)$filter, h5const$H5Z_FILTER_SCALEOFFSET)
    expect_equal(h5p_obj$get_filter(3)$filter, h5const$H5Z_FILTER_SHUFFLE)

    ## now set an external file
    h5p_obj$set_external("test", 10, 100)
    expect_equal(h5p_obj$get_external_count(), 1)
    external_1 <- h5p_obj$get_external(0)
    expect_equal(external_1$name, "test")
    expect_equal(external_1$offset, 10)
    expect_equal(external_1$size, 100)
})

test_that("H5P_DATASET_ACCESS works", {
    h5p_obj <- H5P_DATASET_ACCESS$new()
    h5p_obj$set_chunk_cache(rdcc_nslots=-1, rdcc_nbytes=-1, rdcc_w0=-1)
    expect_equal(h5p_obj$get_chunk_cache()$rdcc_nslots, 521)
    expect_equal(h5p_obj$get_chunk_cache()$rdcc_nbytes, 1048576)
    expect_equal(h5p_obj$get_chunk_cache()$rdcc_w0, 0.75)
})

test_that("H5P_DATASET_XFER", {
    h5p_obj <- H5P_DATASET_XFER$new()
    h5p_obj$set_edc_check(h5const$H5Z_DISABLE_EDC)
    expect_equal(h5p_obj$get_edc_check(), h5const$H5Z_DISABLE_EDC)

    h5p_obj$set_hyper_vector_size(1000)
    expect_equal(h5p_obj$get_hyper_vector_size(), 1000)

    h5p_obj$set_btree_ratios(0.25, 0.5, 0.75)
    expect_equal(h5p_obj$get_btree_ratios(), list(left=0.25, middle=0.5, right=0.75))
})

test_that("H5P_LINK_CREATE", {
    h5p_obj <- H5P_LINK_CREATE$new()
    h5p_obj$set_char_encoding(h5const$H5T_CSET_ASCII)
    expect_equal(h5p_obj$get_char_encoding(), h5const$H5T_CSET_ASCII)
    h5p_obj$set_char_encoding(h5const$H5T_CSET_UTF8)
    expect_equal(h5p_obj$get_char_encoding(), h5const$H5T_CSET_UTF8)

    h5p_obj$set_create_intermediate_group(FALSE)
    expect_equal(h5p_obj$get_create_intermediate_group(), FALSE)
    h5p_obj$set_create_intermediate_group(TRUE)
    expect_equal(h5p_obj$get_create_intermediate_group(), TRUE)
})

test_that("H5P_LINK_ACCESS", {
    h5p_obj <- H5P_LINK_ACCESS$new()
    h5p_obj$set_nlinks(5)
    expect_equal(h5p_obj$get_nlinks(), 5)

    h5p_obj$set_elink_prefix("test")
    expect_equal(h5p_obj$get_elink_prefix(), "test")

    h5p_obj$set_elink_acc_flags(h5const$H5F_ACC_RDONLY)
    expect_equal(h5p_obj$get_elink_acc_flags(), h5const$H5F_ACC_RDONLY)
})

test_that("H5P_OBJECT_CREATE", {
    h5p_obj <- H5P_OBJECT_CREATE$new()

    h5p_obj$set_obj_track_times(FALSE)
    expect_equal(h5p_obj$get_obj_track_times(), FALSE)
    h5p_obj$set_obj_track_times(TRUE)
    expect_equal(h5p_obj$get_obj_track_times(), TRUE)

    h5p_obj$set_attr_phase_change(9,5)
    expect_equal(h5p_obj$get_attr_phase_change(), list(max_compact=9, min_dense=5))

    h5p_obj$set_attr_creation_order(h5const$H5P_CRT_ORDER_TRACKED + h5const$H5P_CRT_ORDER_INDEXED)
    expect_equal(h5p_obj$get_attr_creation_order(), as.integer(h5const$H5P_CRT_ORDER_TRACKED + h5const$H5P_CRT_ORDER_INDEXED))
})


test_that("H5P_OBJECT_COPY", {
    h5p_obj <- H5P_OBJECT_COPY$new()
    h5p_obj$set_copy_obj(h5const$H5O_COPY_SHALLOW_HIERARCHY_FLAG)
    expect_equal(h5p_obj$get_copy_obj(), as.integer(h5const$H5O_COPY_SHALLOW_HIERARCHY_FLAG))
})

test_that("H5P_ATTRIBUTE_CREATE", {
    h5p_obj <- H5P_ATTRIBUTE_CREATE$new()
    h5p_obj$set_char_encoding(h5const$H5T_CSET_ASCII)
    expect_equal(h5p_obj$get_char_encoding(), h5const$H5T_CSET_ASCII)
    h5p_obj$set_char_encoding(h5const$H5T_CSET_UTF8)
    expect_equal(h5p_obj$get_char_encoding(), h5const$H5T_CSET_UTF8)
})




---
File: /tests/testthat/test-h5s.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5S")

test_that("Setting different types of dataspaces", {
    ds_simple <- H5S$new(type="simple")
    ds_scalar <- H5S$new(type="scalar")
    ds_null <- H5S$new(type="null")

    ## check that the types are as expected
    expect_true(ds_simple$get_select_type() == "H5S_SEL_ALL")
    expect_equal(ds_simple$get_simple_extent_type(), h5const$H5S_SIMPLE)
    expect_equal(ds_scalar$get_simple_extent_type(), h5const$H5S_SCALAR)
    expect_equal(ds_null$get_simple_extent_type(), h5const$H5S_NULL)
})

test_that("Setting extensions of dataspace", {
    ## create one with extent set immediately
    ## then one where the extent is set after creation
    ds_extent_new <- H5S$new(dims=as.double(c(4,6,3,4)), maxdims=c(Inf, 6, Inf, 8))
    ds_extent_later <- H5S$new(type="simple")
    ds_extent_later$set_extent_simple(dims=c(4,6,3,4), maxdims=c(Inf, 6, Inf, 8))
    expect_true(ds_extent_new$extent_equal(ds_extent_later))
})

test_that("Retrieving dimensions", {
    ds_simple <- H5S$new(type="simple", dims=c(10,20), maxdims=c(Inf, 30))
    ds_scalar <- H5S$new(type="scalar")
    ds_null <- H5S$new(type="null")

    expect_equal(ds_null$dims, NULL)
    expect_equal(ds_null$maxdims, NULL)
    expect_equal(ds_scalar$dims, integer(0))
    expect_equal(ds_scalar$maxdims, integer(0))
    expect_equal(ds_simple$dims, c(10,20))
    expect_equal(ds_simple$maxdims, c(Inf, 30))
    
})


test_that("Setting and retrieving hyperslabs", {
    ## create a simple DS, select two hyperslabs, overlapping, with AND and OR
    ds_simple <- H5S$new(type="simple", dims=c(10,10,40), maxdims=c(Inf, Inf, Inf))
    ds_simple$select_hyperslab(start=c(2,3,2), count=c(2,1,1), block=c(2,3,2), stride=c(3,5,3), op=h5const$H5S_SELECT_SET)
    blocks <- ds_simple$get_select_hyper_nblocks()
    blocklist <- ds_simple$get_select_hyper_blocklist()
    ## now check that the blocklist is as expected
    expect_equal(blocks, 2)
    expect_equal(blocklist, structure(matrix(c(2,3,2, 3, 5, 3, 5, 3, 2, 6, 5, 3), ncol=3, byrow=TRUE),
                                      dimnames=list(c("block_1_start", "block_1_end", "block_2_start", "block_2_end"), NULL)))

    
})

test_that("Testing encode/decode as well as copy", {
    ## create a new dataspace, , encode it, then decode it again, then compare
    ## the old one to the new one
    ds_simple <- H5S$new(type="simple", dims=c(10,10,40), maxdims=c(Inf, Inf, Inf))
    ds_simple$select_hyperslab(start=c(2,3,2), count=c(2,1,1), block=c(2,3,2), stride=c(3,5,3), op=h5const$H5S_SELECT_SET)
    buf <- ds_simple$encode()
    ds_decode <- H5S$new(decode_buf=buf)
    ds_copy <- ds_simple$copy()
    
    ## now check that in various aspects, the new and the old dataspace are identical
    expect_equal(ds_simple$get_select_type(), ds_decode$get_select_type())
    expect_equal(ds_simple$get_select_hyper_blocklist(), ds_decode$get_select_hyper_blocklist())
    expect_equal(ds_simple$get_select_type(), ds_copy$get_select_type())
    expect_equal(ds_simple$get_select_hyper_blocklist(), ds_copy$get_select_hyper_blocklist())

    ## ds_simple$offset_simple(c(5,1,1))
    ## ds_simple$select_valid()
    ## ds_simple$offset_simple(c(6,1,1))
    ## ds_simple$select_valid()
})

test_that("Setting of individual points", {
    ds_simple <- H5S$new(type="simple", dims=c(12,10,40), maxdims=c(Inf, Inf, Inf))
    coords <- matrix(c(1:5, 2:6, 3:7), ncol=3)
    ds_simple$select_elements(coord=coords, byrow=TRUE)
    coords_selected <- ds_simple$get_select_elem_pointlist()

    expect_equal(coords, coords_selected)

    ## now add the selection using an AND statement
    ds_simple$select_elements(coord=c(2,3,4), op=h5const$H5S_SELECT_APPEND)
    coords_selected_2 <- ds_simple$get_select_elem_pointlist()
    expect_equal(rbind(coords, c(2,3,4)), coords_selected_2)

    ## ds_simple$offset_simple(c(9,1,1))
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    ## ds_simple$offset_simple(c(10,1,1))
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    ## ds_simple$offset_simple(c(11,1,1))
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    
    ## ds_simple <- H5S$new(type="simple", dims=c(5,10,20), maxdims=c(Inf, Inf, Inf))
    ## ds_simple$select_elements(coord=c(1,1,1), byrow=TRUE)
    ## ds_simple$select_valid()

    ## ds_simple$offset_simple(NULL)
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    ## ds_simple$offset_simple(c(4,0,0))
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    ## ds_simple$offset_simple(c(5,0,0))
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    ## ds_simple$offset_simple(c(6,0,0))
    ## ds_simple$get_select_bounds()
    ## ds_simple$select_valid()
    
})



---
File: /tests/testthat/test-h5t.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5T")

test_that("H5T_ENUM works", {
    labels1 <- LETTERS[1:10]
    labels2 <- paste0("B", 1:300)
    enum_test1 <- H5T_ENUM$new(labels=labels1)
    enum_test2<- H5T_ENUM$new(labels=labels2)

    expect_equal(as.character(enum_test1$get_class()), "H5T_ENUM")
    expect_equal(enum_test1$get_size(), 1)
    expect_equal(enum_test2$get_size(), 2)

    expect_equal(enum_test1$get_labels(), labels1)
    expect_equal(enum_test2$get_labels(), labels2)
})

test_that("H5T_COMPOUND works", {
    labels1 <- LETTERS[1:10]
    enum_test1 <- H5T_ENUM$new(labels=labels1)
    cpd_dtypes <-h5types$overview$Type_id
    names(cpd_dtypes) <- h5types$overview$Name
    cpd_test1 <- H5T_COMPOUND$new(labels=names(cpd_dtypes), dtypes=cpd_dtypes)
    cpd_test1_types <- cpd_test1$get_cpd_types()
    cpd_test2 <- H5T_factory(cpd_dtypes, do_copy = TRUE)

    ## check that the factory actually does a copy for all of these, except the last one
    cpd_test2_ids <- unlist(lapply(cpd_test2, function(x) x$id))
    expect_equal(unname(cpd_test2_ids == cpd_dtypes), rep(FALSE, length(cpd_test2_ids)))

    ## test that the give_compound_types returns the same thing as the factory produces
    ## tests the 'equal' function of H5T at the same time
    expect_equal(length(cpd_test1_types), length(cpd_test2))
    eq_res <- logical(length(cpd_test1))
    for(i in seq_along(cpd_test1_types)) {
        eq_res[i] <- cpd_test1_types[[i]]$equal(cpd_test2[[i]])
    }
    expect_true(all(eq_res))

    ## now check that classes are returned correctly
    cpd_test1_classes <- cpd_test1$get_cpd_classes()
    cpd_test2_classes <- unname(do.call("c", lapply(cpd_test2, function(x) x$get_class())))
    expect_equal(cpd_test1_classes, unname(cpd_test2_classes))


    ## also insert a test here that a complex can be created
    ## and on copy is returned as the correct r6 class
    cplx_dt <- H5T_COMPLEX$new()
    expect_true(inherits(cplx_dt$copy(), "H5T_COMPLEX"))
})

test_that("INTEGER", {
    ## get an integer type, set its precision and its sign
    dtype_int <- h5types$H5T_NATIVE_LLONG
    dtype_int$set_precision(16)
    dtype_int$set_size(2)
    dtype_int$set_sign(h5const$H5T_SGN_NONE)
    dtype_int$set_order(h5const$H5T_ORDER_BE)

    expect_true(dtype_int$equal(h5types$H5T_STD_U16BE))

    expect_equal(dtype_int$get_size(), 2)
    expect_equal(dtype_int$get_precision(), 16)
    expect_equal(dtype_int$get_sign(), h5const$H5T_SGN_NONE)
    expect_equal(dtype_int$get_order(), h5const$H5T_ORDER_BE)
})

test_that("FLOAT", {
    ## change a double data type into a float by setting all the important bits
    dtype_float <- h5types$H5T_NATIVE_FLOAT
    dtype_double <- h5types$H5T_NATIVE_DOUBLE

    ## now change the double into a float
    do.call(dtype_double$set_fields, args=dtype_float$get_fields())
    dtype_double$set_ebias(dtype_float$get_ebias())
    dtype_double$set_norm(dtype_float$get_norm())
    dtype_double$set_inpad(dtype_float$get_inpad())
    dtype_double$set_size(dtype_float$get_size())

    expect_true(dtype_double$equal(dtype_float))
})

test_that("native datatypes", {
    int_test <- h5types$H5T_STD_U32BE
    int_test_native_c_type <- int_test$get_native_type()
    expect_true(int_test_native_c_type$equal(h5types$H5T_NATIVE_UINT32))

    ## create a compound type with BE and LE 16 bit integers in it, as well as 64 bit BE and LE
    ## then get a native_c and native_r datatype
    ## compare to the artificially created ones
    cpd_test <- H5T_COMPOUND$new(labels=c("U16LE", "U326BE", "U64LE", "I64BE", "FLOAT"),
                                 dtypes=list(h5types$H5T_STD_U16LE, h5types$H5T_STD_U32BE, h5types$H5T_STD_U64LE, h5types$H5T_STD_I64BE,
                                     h5types$H5T_NATIVE_FLOAT))
    cpd_native_c <- H5T_COMPOUND$new(labels=c("U16LE", "U326BE", "U64LE", "I64BE", "FLOAT"),
                                     dtypes=list(h5types$H5T_NATIVE_UINT16, h5types$H5T_NATIVE_UINT32,
                                     h5types$H5T_NATIVE_UINT64, h5types$H5T_NATIVE_INT64, h5types$H5T_NATIVE_FLOAT),
                                     size=32, offset=c(0, 4, 8, 16, 24))
    cpd_native_r <- H5T_COMPOUND$new(labels=c("U16LE", "U326BE", "U64LE", "I64BE", "FLOAT"),
                                     dtypes=list(h5types$H5T_NATIVE_INT, h5types$H5T_NATIVE_LLONG,
                                     h5types$H5T_NATIVE_LLONG, h5types$H5T_NATIVE_LLONG, h5types$H5T_NATIVE_DOUBLE),
                                     size=40, offset=c(0, 8, 16, 24, 32))

    cpd_test_native_c <- cpd_test$get_native_type()
    expect_true(cpd_test_native_c$equal(cpd_native_c))
    expect_equal(cpd_test_native_c$describe(), cpd_native_c$describe())

})

test_that("Committing a datatype", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    labels1 <- LETTERS[1:10]
    enum_test1 <- H5T_ENUM$new(labels=labels1)

    file.h5$commit("enum_test", enum_test1)

    ## open it again; check that it is the same
    ## and then check it is committed
    dtype_enum_committed <- file.h5$open("enum_test")

    expect_true(dtype_enum_committed$is_committed())
    expect_true(enum_test1$is_committed())


    file.h5$close_all()
    file.remove(test_file)
})

test_that("Describe", {
    ## no test performed; will just run describe
    ## on all standard types
    overview <- h5types$overview
    for(i in seq_len(nrow(overview))) {
        dtype <- get(overview$Name[i], envir=h5types)
        if(!as.character(dtype$get_class()) %in% c("H5T_REFERENCE", "H5T_TIME", "H5T_OPAQUE")) {
            dtype$describe()
        }
    }

})

test_that("is_vlen", {
    vlen_int <- H5T_VLEN$new(h5types$H5T_NATIVE_INT)
    vlen_string <- H5T_STRING$new(size=Inf)
    nonvlen_string <- H5T_STRING$new(size=2)
    nonvlen_int <- h5types$H5T_NATIVE_INT

    expect_true(vlen_int$is_vlen())
    expect_true(vlen_string$is_vlen())
    expect_true(!nonvlen_int$is_vlen())
    expect_true(!nonvlen_string$is_vlen())

})


test_that("dtype to text", {
    
    
    ## now check that dtype to text to dtype conversion works
#    cpd_test1_round_trip <- text_to_dtype(h5types$H5O_info_t$to_text())
#    expect_true(cpd_test1$equal(cpd_test1_round_trip))
#    text_to_dtype("H5T_COMPOUND { H5T_STD_I32BE \"a\"; H5T_IEEE_F32BE \"b\"; H5T_IEEE_F64BE \"c\"; }")
})



---
File: /tests/testthat/test-high_level_UI.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("High-level-UI")

test_that("Names and [[", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    test1 <- file.h5$create_group("test1")
    test2 <- test1$create_group("test2")
    test3 <- file.h5$create_group("test3")

    expect_equal(names(file.h5), c("test1", "test3"))
    expect_equal(file.h5$names, c("test1", "test3"))
    expect_equal(names(test1), "test2")
    expect_equal(names(test2), character(0))

    test4 <- file.h5[["test1", dataset_access_pl=h5const$H5P_DEFAULT]]
    expect_equal(test1$get_obj_name(), test4$get_obj_name())
    test.error <- try(file.h5[["asdf"]], silent=TRUE)
    expect_true(inherits(test.error, "try-error"))


    ## now test various assignments
    ## first the group
    ## here we have to try test2; test1 in fact does not raise an error, as an hdf5 object can be assigned onto itself
    expect_true(inherits(try(file.h5[["test1"]] <- test2, silent=TRUE), "try-error"))
    file.h5[["test_hard_link"]] <- test1
    test_hard_link <- file.h5[["test_hard_link"]]
    ## should contain the same
    expect_equal(test_hard_link$obj_info(), test1$obj_info())

    ## now a dataset
    robj <- matrix(as.integer(1:20), ncol=4)
    test_dataset <- test1$create_dataset("test_dataset", robj)
    file.h5[["dataset_hard_link"]] <- test_dataset
    test_dataset_hl <- file.h5[["dataset_hard_link"]]
    expect_equal(test_dataset_hl$obj_info(), test_dataset$obj_info())

    ## and a type
    file.h5[["test_type"]] <- h5types$H5T_NATIVE_INT64
    expect_true(h5types$H5T_NATIVE_INT64$equal(file.h5[["test_type"]]))

    ## and a dataset
    file.h5[["test_dataset2"]] <- robj
    expect_equal(file.h5[["test_dataset2"]]$read(), robj)

    file.h5$close_all()
    file.remove(test_file)
})


index_logical <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE)
index_regular <- c(3, 4, 5, 6)
index_regular2 <- c(3, 5, 7, 9)
index_positive <- c(1, 5, 6, 10, 15)
index_ident <- c(1, 3, 3, 6)
index_ident2 <- c(1, 3, 5, 1)
index_decreasing <- c(5, 4, 2, 1)
index_negative_all <- -index_regular
index_negative_some <- c(1, 3, -2, 5, 6)
index_large <- c(1, 20)
index_empty <- list(quote(expr=))

example_indices <- list(index_logical,
                            index_regular,
                            index_regular2,
                            index_positive,
                            index_ident,
                            index_ident2,
                            index_decreasing,
                            index_negative_all,
                            index_large,
                            quote(expr=),
                            NULL)

test_that("args_regularity_evaluation to selection", {
    ## first, check arg for hyperslab func, i.e. for functions that can directly be interpreted as a
    ## a range of example arguments
    a <- 4
    example_calls <- list(call(":", a, 8),
                          call("seq_len", 6),
                          call("seq", from=4, to=9, by=2),
                          call("seq", from=4, length.out=4, by=1),
                          call(":", -2, 2),
                          expression(1:5 / 10 * 2))
    check_for_func_res <- lapply(example_calls, hdf5r:::check_arg_for_hyperslab_func, envir=sys.frame())
    expect_equal(check_for_func_res, list(c(4, 1, 1, 5), c(1, 1, 1, 6), c(4, 3, 2, 1), c(4, 1, 1, 4), c(NA, NA, NA, NA), c(NA, NA, NA, NA)))

    
    ## now do the argument regularity evaluation
    ds_dims <- rep(10, length(example_indices))
    example_indices_regularity <- hdf5r:::args_regularity_evaluation(example_indices, ds_dims, envir=sys.frame())
    ## now need to check every component
    NA_hyperslab_row <- c(NA, NA, NA, NA)
    example_indices_intended_output <- list(
        args_in=example_indices,
        args_point=list(c(1, 3, 4, 6, 10), NULL, NULL, index_positive, unique(index_ident), NULL, sort(index_decreasing),
            seq_len(10)[index_negative_all], NULL, NULL, numeric(0)),
        is_hyperslab=c(FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE),
        ## hyperslab components: c("start", "count", "stride", "block")
        hyperslab=matrix(c(NA_hyperslab_row, c(3, 1, 1, 4), c(3, 4, 2, 1), NA_hyperslab_row, NA_hyperslab_row, c(1, 3, 2, 1),
            NA_hyperslab_row, NA_hyperslab_row, c(1, 2, 19, 1), c(1, 1, 1, 10), NA_hyperslab_row),
            byrow=TRUE, ncol=4, dimnames=list(NULL, c("start", "count", "stride", "block"))),
        result_dims_pre_shuffle=c(5, 4, 4, 5, 3, 3, 4, 6, 2, 10, 0),
        result_dims_post_shuffle=c(5, 4, 4, 5, 4, 4, 4, 6, 2, 10, 0),
        max_dims=c(10, 6, 9, 15, 6, 5, 5, 10, 20, 10, -Inf),
        needs_reshuffle=c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE),
        reshuffle=list(NULL, NULL, NULL, NULL, c(1, 2, 2, 3), c(1, 2, 3, 1), c(4, 3, 2, 1), NULL, NULL, NULL, NULL)
        )
    expect_equal(example_indices_regularity, example_indices_intended_output)
    expect_error(hdf5r:::args_regularity_evaluation(list(index_negative_some), ds_dims=10, envir=sys.frame()))

    ## now need to translate the regularity evaluation either into a hyperslab or a pointlist selection
    ## three cases; one with only points; one with a hyperslab and points and one with only hyperslabs
    only_points_regularity <- hdf5r:::args_regularity_evaluation(list(index_positive, index_positive), ds_dims=c(10, 10), envir=sys.frame())
    mixed_regularity <- hdf5r:::args_regularity_evaluation(list(index_regular, index_positive), ds_dims=c(10, 10), envir=sys.frame())
    only_hyperslab_regularity <- hdf5r:::args_regularity_evaluation(list(index_regular, index_regular2, quote(expr=)),
                                                            ds_dims=c(10, 10, 10), envir=sys.frame())

    only_points_selection <- hdf5r:::regularity_eval_to_selection(only_points_regularity)
    mixed_selection <- hdf5r:::regularity_eval_to_selection(mixed_regularity)
    only_hyperslab_selection <- hdf5r:::regularity_eval_to_selection(only_hyperslab_regularity)

    expect_equal(only_points_selection, structure(matrix(c(rep(index_positive, times=5), rep(index_positive, each=5)), ncol=2), class="point_selection"))
    mixed_selection_array <- array(0, dim=c(2, 5, 4))
    mixed_selection_array[1,,] <- rep(c(3, 1, 1, 4), each=5)
    mixed_selection_array[2,,] <- 1
    mixed_selection_array[2,,1] <- index_positive
    expect_equal(mixed_selection, structure(mixed_selection_array, class="hyperslab_selection"))

    only_hyperslab_array <- array(0, dim=c(3, 1, 4))
    only_hyperslab_array[1,,] <- c(3, 1, 1, 4)
    only_hyperslab_array[2,,] <- c(3, 4, 2, 1)
    only_hyperslab_array[3,,] <- c(1, 1, 1, 10)
    expect_equal(only_hyperslab_selection, structure(only_hyperslab_array, class="hyperslab_selection"))
})



test_that("subset_h5.H5S", {
    ## create a dataspace
    h5s_obj <- H5S$new(type="simple", dims=c(15, 15, 20), maxdims=c(15, 15, 20))
    subset_h5.H5S(h5s_obj, seq_len(3), seq(2,4,by=3), 5:9)
    expect_equal(h5s_obj$get_select_type(), h5const$H5S_SEL_HYPERSLABS)
    expect_equal(h5s_obj$get_select_hyper_blocklist(), matrix(c(1,3,2,2,5,9), nrow=2, dimnames=list(c("block_1_start", "block_1_end"), NULL)))

    subset_h5.H5S(h5s_obj, seq_len(3), seq(2,4,by=3), c(1,2,4))
    expect_equal(h5s_obj$get_select_type(), h5const$H5S_SEL_POINTS)


    ## setting one that is outside the limits of the space
    expect_error(h5s_obj[16, 1, 1], "The following coordinates are outside the dataset dimensions: 1")

    


    ## test passing in a NULL value
    foo <- h5s_obj[1:3, NULL, c(1,2,4)]
    expect_equal(h5s_obj$get_select_type(), h5const$H5S_SEL_NONE)

    foo <- h5s_obj[,,]
    
    subset_h5.H5S(h5s_obj, seq_len(3), NULL, c(1,2,4))
    expect_equal(h5s_obj$get_select_type(), h5const$H5S_SEL_NONE)

    ## complicated subsetting in various forms
    ## using logial
    ## using non-uniform index
    ## using decreasing index
    ## using negative index (all of them)
    ## using index (some of them)
    ## using index with several identical values
    ## GOAL: Ensure that a hyperslab selection is being done in the intended places

    ## index_logical <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE)
    ## index_regular <- 3:6
    ## index_positive <- c(1, 5, 6, 10)
    ## index_ident <- c(1, 3, 3, 6)
    ## index_decreasing <- c(5, 4, 2, 1)
    ## index_negative_all <- -index_regular
    ## index_negative_some <- c(1, 3, -2, 5, 6)
    ## index_large <- c(1, 15)

    ## now make the tests with these indices; will use the h5s_obj
    ## only use single indices
    h5s_logical <- subset_h5.H5S(h5s_obj, index_logical, , )
    expect_equal(h5s_logical$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_regular <- subset_h5.H5S(h5s_obj, index_regular, ,)
    expect_equal(h5s_regular$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_positive <- subset_h5.H5S(h5s_obj, index_positive, ,)
    expect_equal(h5s_positive$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_ident <- subset_h5.H5S(h5s_obj, index_ident, ,)
    expect_equal(h5s_ident$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_ident2 <- subset_h5.H5S(h5s_obj, index_ident2, ,)
    expect_equal(h5s_ident$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_decreasing <- subset_h5.H5S(h5s_obj, index_decreasing, ,)
    expect_equal(h5s_decreasing$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_negative_all <- subset_h5.H5S(h5s_obj, index_negative_all, ,)
    expect_equal(h5s_negative_all$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    expect_error(subset_h5.H5S(h5s_obj, index_negative_some, ,), regexp=".*not all subscripts are either positive or negative")
    expect_error(subset_h5.H5S(h5s_obj, index_large, ,), "The following coordinates are outside the dataset dimensions:.*")

    ## also a few using double or triple indices
    ## logical should work, as it is recycled
    h5s_logical_double <- subset_h5.H5S(h5s_obj, index_logical, index_logical, )
    expect_equal(h5s_logical_double$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    h5s_logical_triple <- subset_h5.H5S(h5s_obj, index_logical, index_logical, index_logical)
    expect_equal(h5s_logical_double$get_select_type(), h5const$H5S_SEL_POINTS)

    h5s_logical_regular <- subset_h5.H5S(h5s_obj, index_logical, , index_regular)
    expect_equal(h5s_logical_regular$get_select_type(), h5const$H5S_SEL_HYPERSLABS)

    ## test passing in a NULL value
    subset_h5.H5S(h5s_obj, seq_len(3), NULL, c(1,2,4))
    expect_equal(h5s_obj$get_select_type(), h5const$H5S_SEL_NONE)
})

test_that("subset_h5.H5D", {
    ## create a file with a dataset in it
    ## fill it with simple numbers and read it back
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    robj <- matrix(as.integer(1:100), ncol=10)
    file.h5[["test"]] <- robj
    test <- file.h5[["test"]]

    indices_test <- list(
        1:10, 
        10:1, 
        c(1,2,3,4), 
        c(4, 3, 2, 1),
        c(1, 3, 5, 7), 
        c(7, 5, 3, 1), 
        c(1, 2, 5, 9), 
        c(9, 5, 2, 1), 
        c(1:10, 1:10), 
        c(1, 2, 2, 2, 3, 4, 5), 
        c(-1, -2, -3), 
        c(-1, -3, -4))
    
    for(ind1 in indices_test) {
        for(ind2 in indices_test) {
            expect_equal(test[ind1, ind2], robj[ind1, ind2])
        }
    }
    
    expect_equal(test[1:3, 2:4], robj[1:3, 2:4])
    expect_equal(test[c(1,3,4),], robj[c(1,3,4),])
    test[1:3, 2:4] <- 1:9
    expect_equal(test[1:3, 2:4], matrix(1:9, ncol=3))

    ## write outside of the current set
    ## will trigger an automatic expansion of the current set if possible
    test[11:15, ] <- 1:50
    expect_equal(as.vector(test[11:15,]), 1:50)

    ## also test an indirect subsetting
    get_1 <- function(i, ds) {
        return(ds[i,])
    }
    expect_equal(get_1(11, test), c(1, 6, 11, 16, 21, 26, 31, 36, 41, 46))


    ## need to recreate an error where writing into an array failed when there was a missing dimension
    ## and the other given dimension was a a variable
    test2 <- file.h5$create_dataset("test_array", dtype=h5types$H5T_NATIVE_INT, space=H5S$new("simple", dims=c(10,10,100)),
                           chunk_dims=c(10,10,1))
    pos_list <- list(1)
    test2[,,pos_list[[1]]] <- 1:100
    expect_equal(test2[,,1], matrix(1:100, ncol=10))

    ## need to ensure that an error is thrown when requesting a too large dimension
    expect_error(test2[11, ,], "The following coordinates are outside the dataset dimensions: 1")

    ## check that selecting a dimension as NULL yields the correct result
    expect_equal(test[, NULL], matrix(numeric(0), ncol=0, nrow=15))
    
    # also do one-dimensional subsetting
    robj_onedim = 1:10
    file.h5[["onedim"]] <- robj_onedim
    test_onedim <- file.h5[["onedim"]]
    expect_equal(test_onedim[1:5], robj_onedim[1:5])
    # this is the issue #123 that was reported
    expect_equal(test_onedim[c(1, 3)], robj_onedim[c(1, 3)])
    expect_equal(test_onedim[c(2, 4)], robj_onedim[c(2, 4)])
    
    for(ind1 in indices_test) {
        expect_equal(test_onedim[ind1], robj_onedim[ind1])
    }

    
    file.h5$close_all()
    file.remove(test_file)
})

test_that("hyperslab_to_points", {
    # due to issue #123
    expect_equal(hdf5r:::hyperslab_to_points(c(2,2,2,1)), c(2,4))
})


test_that("attributes", {
    ## open a file, set 2 attributes, read out their names
    ## read them both, read them separately

    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    robj1 <- matrix(as.integer(1:10), ncol=2)
    robj2 <- paste("Test", 1:10)

    h5attr(file.h5, "integer") <- robj1
    h5attr(file.h5, "character") <- robj2

    expect_equal(sort(h5attr_names(file.h5)), sort(c("integer", "character")))
    all_attr <- h5attributes(file.h5)
    expect_equal(all_attr$integer, robj1)
    expect_equal(all_attr$character, robj2)

    expect_equal(h5attr(file.h5, "integer"), robj1)
    expect_equal(h5attr(file.h5, "character"), robj2)

    h5attr(file.h5, "integer") <- robj2
    expect_equal(h5attr(file.h5, "integer"), robj2)



    file.h5$close_all()
    file.remove(test_file)
})


test_that("Subsetting dimensions, drop and write", {
    test_file <- tempfile(fileext=".h5")
    file.h5 <- H5File$new(test_file, mode="w")

    ex_array <- array(1:60, dim=c(3,4,5))
    file.h5[["ex_array"]] <- ex_array
    ex_arr_ds <- file.h5[["ex_array"]]

    expect_equal(ex_arr_ds[2,,],  ex_array[2,,])
    expect_equal(ex_arr_ds[,2,],  ex_array[,2,])
    expect_equal(ex_arr_ds[,,2],  ex_array[,,2])

    expect_equal(ex_arr_ds[2,,, drop=FALSE],  ex_array[2,,, drop=FALSE])
    expect_equal(ex_arr_ds[,2,, drop=FALSE],  ex_array[,2,, drop=FALSE])
    expect_equal(ex_arr_ds[,,2, drop=FALSE],  ex_array[,,2, drop=FALSE])

    ## now test the repeated write
    ex_arr_ds[,,] <- 1
    ex_array[,,] <- 1
    expect_equal(ex_array[,,], ex_arr_ds[,,])
    ex_arr_ds[,,] <- c(1,2,3)
    ex_array[,,] <- c(1,2,3)
    expect_equal(ex_array[,,], ex_arr_ds[,,])


    ## complicated subsetting in various forms
    ## using logial
    ## using non-uniform index
    ## using decreasing index
    ## using index with several identical values
    ## GOAL: Ensure the correct values are being returned
    ex_array2 <- array(as.numeric(seq_len(15 * 15* 20)), dim=c(15, 15, 20))
    file.h5[["ex_array2"]] <- ex_array2
    ex_array2_ds <- file.h5[["ex_array2"]]

    ## index_logical <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE)
    ## index_regular <- 3:6
    ## index_regular2 <- c(3, 5, 7, 9)
    ## index_positive <- c(1, 5, 6, 8, 10)
    ## index_ident <- c(1, 3, 3, 6)
    ## index_decreasing <- c(5, 4, 2, 1)
    ## index_negative_all <- -index_regular
    ## index_negative_some <- c(1, 3, -3, 5, 6)
    ## index_large <- c(1, 15)

    ## a read/write test
    copy_change_test_reset_array <- function(hdf5_ds, r_ds, index) {
        ## make a read test
        expect_equal(hdf5_ds[index,,], r_ds[index,,])
        r_ds_changed <- r_ds
        replace_vals <- runif(length(r_ds[index,,]))
        r_ds_changed[index, ,] <- replace_vals
        hdf5_ds[index, ,] <- replace_vals
        hdf5_ds_read <- hdf5_ds[index, ,]
        ## and reset
        hdf5_ds[, ,] <- r_ds
        expect_equal(hdf5_ds_read, r_ds_changed[index, ,])
        return(invisible(NULL))
    }
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_logical)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_regular)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_regular2)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_positive)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_ident)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_ident2)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_decreasing)
    copy_change_test_reset_array(ex_array2_ds, ex_array2, index_negative_all)
    expect_equal(ex_array2_ds[,,], ex_array2[,,])

    expect_error(ex_array2_ds[index_large, ], "Number of arguments not equal to number of dimensions: 2 vs. 3")
    expect_error(ex_array2_ds[index_negative_some, ,], "In index 1 not all subscripts are either positive or negative")
    expect_error(ex_array2_ds[index_large,, ], "The following coordinates are outside the dataset dimensions:.*")

    ## also a few using double or triple indices
    ## logical should work, as it is recycled
    expect_equal(ex_array2_ds[index_logical, index_logical,], ex_array2[index_logical, index_logical,])
    expect_equal(ex_array2_ds[index_logical, index_logical, index_logical], ex_array2[index_logical, index_logical, index_logical])
    expect_equal(ex_array2_ds[index_logical, , index_regular], ex_array2[index_logical, , index_regular])


    ## we also want to try the same for compounds
    ex_cpd <- data.frame(a=LETTERS[1:15], b=1:15, stringsAsFactors = FALSE)
    file.h5[["ex_cpd"]] <- ex_cpd
    ex_cpd_ds <- file.h5[["ex_cpd"]]

    ## then also writing it
    copy_change_test_reset_cpd <- function(hdf5_cpd, r_cpd, index) {
        # and reset
        hdf5_cpd[] <- r_cpd
        ## make a read test
        ## for data.frame we currently ignore the row numbers
        hdf5_cpd_read <- hdf5_cpd[index]
        rownames(hdf5_cpd_read) <- NULL
        r_cpd_read <- r_cpd[index,]
        rownames(r_cpd_read) <- NULL
        expect_equal(hdf5_cpd_read, r_cpd_read)
        r_cpd_changed <- r_cpd
        replace_length <- nrow(r_cpd[index,])
        replace_vals <- data.frame(a=sample(LETTERS, size=replace_length), b=sample(1:50, size=replace_length), stringsAsFactors = FALSE)
        r_cpd_changed[index,] <- replace_vals
        hdf5_cpd[index] <- replace_vals

        hdf5_cpd_read <- hdf5_cpd[]
        # and reset
        hdf5_cpd[] <- r_cpd
        ## check everything after the write
        expect_equal(hdf5_cpd_read, r_cpd_changed[,])
        return(invisible(NULL))
    }
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_logical)
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_regular)
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_regular2)
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_positive)
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_ident)
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_decreasing)
    copy_change_test_reset_cpd(ex_cpd_ds, ex_cpd, index_negative_all)

    expect_error(ex_cpd_ds[index_large, ], "Number of arguments not equal to number of dimensions: 2 vs. 1")
    expect_error(ex_cpd_ds[index_negative_some], "In index 1 not all subscripts are either positive or negative")
    expect_error(ex_cpd_ds[index_large], "The following coordinates are outside the dataset dimensions:.*")

    ## create a dataset with maximal dimensions
    ## check that writing dimensions less than the maximum is ok, but larger than
    ## the maximum will fail
    h5s_finite_maxdims <- H5S$new(type="simple", dims=c(5, 10, 15), maxdims=c(10, 15, 20))
    h5d_finite_maxdims <- file.h5$create_dataset(name="ds_finite_maxdims", dtype=h5types$H5T_NATIVE_DOUBLE, space=h5s_finite_maxdims)
    h5d_finite_maxdims[10, ,1:10 ] <- 1:100
    expect_equal(h5d_finite_maxdims$dims, c(10, 10, 15))
    expect_error({h5d_finite_maxdims[11, , ] <- 151:300}, regexp="The following coordinates are larger than the largest possible dataset dimensions \\(maxdims\\): 1")




    file.h5$close_all()
    file.remove(test_file)

})


test_that("Check if index is ok before expand", {
    test_file <- tempfile(fileext=".h5")
    file.h5 <- H5File$new(test_file, mode="w")

    ex_dset <- array(81, dim=c(9,9))
    file.h5[["dset"]] <- ex_dset

    dset <- file.h5[["dset"]]

    ## needs to throw an error as too many elements
    expect_error({dset[10:11, 9] <- matrix(rep(0, 2*9), nrow = 2)})

    ## needs to throw an error if dimensions have changed
    expect_equal(dset$dims, c(9,9)) 
    file.h5$close_all()
    file.remove(test_file)
})



---
File: /tests/testthat/test-links.R
---

#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################

context("H5L")

test_that("Link functions", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    test1 <- file.h5$create_group("test1")

    ## now create a soft link and an external link
    file.h5$link_create_hard(file.h5, "test1", "test_hard")
    file.h5$link_create_soft("test1", "test_soft")
    file.h5$link_create_external("testfile", "test", "test_external")

    ## check that link exist
    expect_true(file.h5$link_exists("test_hard"))

    ## get the names by index
    num_links <- file.h5$group_info()$nlinks
    expect_equal(num_links, 4)
    expect_equal(file.h5$link_name_by_idx(0, ".", order=h5const$H5_ITER_INC), "test1")
    expect_equal(file.h5$link_name_by_idx(1, ".", order=h5const$H5_ITER_INC), "test_external")
    expect_equal(file.h5$link_name_by_idx(2, ".", order=h5const$H5_ITER_INC), "test_hard")
    expect_equal(file.h5$link_name_by_idx(3, ".", order=h5const$H5_ITER_INC), "test_soft")
    
    ## check info directly and by index
    info_hard <- file.h5$link_info("test_hard")
    info_soft <- file.h5$link_info("test_soft")
    info_external <- file.h5$link_info("test_external")

    info_hard_idx <- file.h5$link_info_by_idx(2, ".", order=h5const$H5_ITER_INC)
    info_soft_idx <- file.h5$link_info_by_idx(3, ".", order=h5const$H5_ITER_INC)
    info_external_idx <- file.h5$link_info_by_idx(1, ".", order=h5const$H5_ITER_INC)

    expect_equal(info_hard, info_hard_idx)
    expect_equal(info_soft, info_soft_idx)
    expect_equal(info_external, info_external_idx)

    ## get the link values
    expect_equal(file.h5$link_value("test_hard"), NA)
    expect_equal(file.h5$link_value("test_soft"), "test1")
    expect_equal(file.h5$link_value("test_external"), list(file_name="testfile", obj_name="test"))

    ## now the same link values by index
    expect_equal(file.h5$link_value_by_idx(2, ".", order=h5const$H5_ITER_INC), NA)
    expect_equal(file.h5$link_value_by_idx(3, ".", order=h5const$H5_ITER_INC), "test1")
    expect_equal(file.h5$link_value_by_idx(1, ".", order=h5const$H5_ITER_INC), list(file_name="testfile", obj_name="test"))

    ## now move a link
    file.h5$link_move_from(file.h5, "test1", "test_move")
    expect_true(file.h5$link_exists("test_move"))
    expect_true(!file.h5$link_exists("test1"))
    file.h5$link_move_to(file.h5, "test1", "test_move")
    expect_true(!file.h5$link_exists("test_move"))
    expect_true(file.h5$link_exists("test1"))

    ## copy a link
    file.h5$link_copy_from(file.h5, "test1", "test_copy_1")
    expect_true(file.h5$link_exists("test_copy_1"))
    file.h5$link_copy_to(file.h5, "test_copy_2", "test_copy_1")
    expect_true(file.h5$link_exists("test_copy_2"))
    
    ## delete a link, directly and by index
    file.h5$link_delete("test_copy_2")
    expect_true(!file.h5$link_exists("test_copy_2"))
    file.h5$link_delete_by_idx(0, ".", order=h5const$H5_ITER_INC)
    expect_true(!file.h5$link_exists("test1"))
    
    
    file.h5$close_all()
    file.remove(test_file)
    
})



---
File: /tests/testthat/test-print.R
---

context("Print-method")

escape_regexp <- function(string) {
    gsub("([.|()\\^{}+$*?]|\\[|\\])", "\\\\\\1", string)
}

test_that("Print functions work as expected", {
    ## create a file and call print
    test_file <- tempfile(fileext=".h5")

    ## H5S default class
    expect_output(h5const$H5S_ALL$print(), "H5S_ALL class")
    expect_output(h5const$H5P_DEFAULT$print(), "H5P_DEFAULT class")
    
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    h5group <- file.h5$create_group("test")

    ## add some attributes
    h5attr(file.h5, "attr1") <- 1.0
    h5attr(file.h5, "attr2") <- "A"
    h5attr(h5group, "grp_attr") <- "a group"

    ## create a space that defines the nsize fo the new dataset
    dset_space <- H5S$new(type="simple", dims=c(5,10,15))
    h5dset <- h5group$create_dataset("test_dset", dtype=h5types$H5T_IEEE_F64LE, space=dset_space)

    ## check that the pring output for spaces is ok
    expect_output(dset_space$print(), regexp="Class: H5S\nType: Simple\nDims: 5 x 10 x 15\nMaxdims: 5 x 10 x 15", fixed=TRUE)

    ## also test output for a scalar and a null space
    expect_output(H5S$new(type="scalar")$print(),
                  regexp="Class: H5S\nType: Scalar", fixed=TRUE)
    expect_output(H5S$new(type="null")$print(),
                  regexp="Class: H5S\nType: NULL", fixed=TRUE)
    
    ## H5File has its location as part of its output
    expect_output(file.h5$print(), regexp=paste0("Class: H5File\nFilename: ",
                                                 normalizePath(test_file, mustWork=FALSE),
                                                 "\nAccess type: H5F_ACC_RDWR\n",
                                                 "Attributes: attr1, attr2\n",
                                                 "Listing:\n",
                                                 " name  obj_type dataset.dims dataset.type_class\n",
                                                 " test H5I_GROUP         <NA>               <NA>"), fixed=TRUE)

    #H5Group also prints the name of the group
    expect_output(h5group$print(), regexp=paste0("Class: H5Group\nFilename: ",
                                                 normalizePath(test_file, mustWork=FALSE),
                                                 "\nGroup: /test\nAttributes: grp_attr\n",
                                                 "Listing:\n",
                                                 "      name    obj_type dataset.dims dataset.type_class\n",
                                                 " test_dset H5I_DATASET  5 x 10 x 15          H5T_FLOAT"), fixed=TRUE)

    ## create a dataset inside the group
    expect_output(h5dset$print(), regexp=paste0("Class: H5D\n",
                                                "Dataset: /test/test_dset\n",
                                                "Filename: ",
                                                normalizePath(test_file, mustWork=FALSE),
                                                "\nAccess type: H5F_ACC_RDWR\n",
                                                "Datatype: H5T_IEEE_F64LE\n",
                                                "Space: Type=Simple     Dims=5 x 10 x 15     Maxdims=5 x 10 x 15\n",
                                                "Chunk: 5 x 10 x 15"), fixed=TRUE)


    ## test the printing of datatypes
    test_type <- h5types$H5T_STD_I32LE
    expect_output(test_type$print(), regexp=paste0("Class: H5T_INTEGER\nDatatype: H5T_STD_I32LE"), fixed=TRUE)

    group_attr <- h5group$attr_open_by_name("grp_attr", ".")
    expect_output(group_attr$print(), regexp=paste0("Class: H5A\n",
                                                    "Attribute: grp_attr\n",
                                                    "Datatype: H5T_STRING {\n",
                                                    "      STRSIZE H5T_VARIABLE;\n",
                                                    "      STRPAD H5T_STR_NULLTERM;\n",
                                                    "      CSET H5T_CSET_ASCII;\n",
                                                    "      CTYPE H5T_C_S1;\n",
                                                    "   }\n",
                                                    "Space: Type=Simple     Dims=1     Maxdims=1"), fixed=TRUE)
    
    ## cleanup
    file.h5$close_all()
    file.remove(test_file)

})



---
File: /tests/testthat/test-reference.R
---


#############################################################################
##
## Copyright 2016 Novartis Institutes for BioMedical Research Inc.
## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at
##
## http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.
##
#############################################################################




context("HDF5 Reference objects")
test_that("Subsetting raw vector with c code", {

    ## test reading and writing of a subset of a raw vector using C code
    subset_test <- as.raw(0:255)
    index <- c(1:5, 9)

    ## item_size 16
    subset_read <- .Call("R_read_raw_subset_generic", subset_test, index, 16, PACKAGE = "hdf5r")
    subset_write <- .Call("R_write_raw_subset_generic", subset_test, as.raw(0:95), index, 16, PACKAGE = "hdf5r")
    expect_equal(subset_read, subset_test[1:16 + 16 * rep(index, each=16)])
    subset_test_write <- subset_test
    subset_test_write[1:16 + 16 * rep(index, each=16)] <- as.raw(0:95)
    expect_equal(subset_write, subset_test_write)

    ## item_size 8
    subset_read <- .Call("R_read_raw_subset_generic", subset_test, index, 8, PACKAGE = "hdf5r")
    subset_write <- .Call("R_write_raw_subset_generic", subset_test, as.raw(0:47), index, 8, PACKAGE = "hdf5r")
    expect_equal(subset_read, subset_test[1:8 + 8 * rep(index, each=8)])
    subset_test_write <- subset_test
    subset_test_write[1:8 + 8 * rep(index, each=8)] <- as.raw(0:47)
    expect_equal(subset_write, subset_test_write)

    ## item_size 4
    subset_read <- .Call("R_read_raw_subset_generic", subset_test, index, 4, PACKAGE = "hdf5r")
    subset_write <- .Call("R_write_raw_subset_generic", subset_test, as.raw(0:23), index, 4, PACKAGE = "hdf5r")
    expect_equal(subset_read, subset_test[1:4 + 4 * rep(index, each=4)])
    subset_test_write <- subset_test
    subset_test_write[1:4 + 4 * rep(index, each=4)] <- as.raw(0:23)
    expect_equal(subset_write, subset_test_write)

    ## item_size 1
    subset_read <- .Call("R_read_raw_subset_generic", subset_test, index, 1, PACKAGE = "hdf5r")
    subset_write <- .Call("R_write_raw_subset_generic", subset_test, as.raw(0:5), index, 1, PACKAGE = "hdf5r")
    expect_equal(subset_read, subset_test[index + 1])
    subset_test_write <- subset_test
    subset_test_write[1 +  index] <- as.raw(0:5)
    expect_equal(subset_write, subset_test_write)


})

test_that("Subsetting reference vector", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    ref_obj <- H5R_OBJECT$new(id=file.h5)
    ref_obj$ref <- as.raw(0:191)
    
    ref_obj_vector <- ref_obj$clone()
    ref_obj_vector$names <- LETTERS[1:24]
    expect_equal(ref_obj_vector$length, 24)

    ## now test various ways of subsetting
    expect_equal(ref_obj_vector$subset_read(c("A", "C")), ref_obj_vector$subset_read(c(1, 3)))

    expect_equal(ref_obj_vector$subset_read(c("A", "C"))$ref, c(as.raw(0:7), as.raw(16:23)))
    expect_equal(ref_obj_vector$subset_read(c("A", "C"))$names, c("A", "C"))

    expect_equal(ref_obj_vector[c("A", "C")], ref_obj_vector$subset_read(c(1, 3)))
    

    ## test the subsetting as an array
    ref_obj_array <- ref_obj$clone()
    ref_obj_array$dim <- c(4,6)
    ref_obj_array$dimnames <- list(LETTERS[1:4], tolower(LETTERS[1:6]))
    expect_equal(ref_obj_array$length, 24)

    expect_equal(ref_obj_array$subset_read(list(c("A", "C"), "a")), ref_obj_array$subset_read(list(c(1, 3), 1)))
    expect_equal(ref_obj_array$subset_read(list(c("A", "C"), "a"))$ref, c(as.raw(0:7), as.raw(16:23)))
    expect_equal(ref_obj_array$subset_read(list(c("A", "C"), "a"))$dim, NULL)
    expect_equal(ref_obj_array$subset_read(list(c("A", "C"), "a"), drop=FALSE)$dim, c(2,1))
    
    expect_equal(ref_obj_array[c("A", "C"), "a"], ref_obj_array$subset_read(list(c(1, 3), 1)))

    ## test assigning data into the vector
    ## vector to insert into the other objects
    ref_inserted <- ref_obj$ref
    obj_to_insert <- as.raw(100:115)
    ref_inserted[c(1:8, 17:24)] <- obj_to_insert

    ref_obj_vector_inserted <- ref_obj_vector$clone()
    ref_obj_vector_inserted$ref <- ref_inserted

    ref_obj_array_inserted <- ref_obj_array$clone()
    ref_obj_array_inserted$ref <- ref_inserted

    ## Vector
    expect_equal(ref_obj_vector$clone()$subset_assign(c("A", "C"), value=obj_to_insert ), ref_obj_vector_inserted)
    expect_equal(ref_obj_vector$clone()$subset_assign(c(1,3), value=obj_to_insert), ref_obj_vector_inserted)

    ## [<-
    ref_obj_vector_cloned <- ref_obj_vector$clone()
    ref_obj_vector_cloned[c("A", "C")] <- obj_to_insert
    expect_equal(ref_obj_vector_cloned, ref_obj_vector_inserted)

    ## Array
    expect_equal(ref_obj_array$clone()$subset_assign(list(c("A", "C"), "a"), value=obj_to_insert ), ref_obj_array_inserted)
    expect_equal(ref_obj_array$clone()$subset_assign(list(c(1,3), 1), value=obj_to_insert), ref_obj_array_inserted)

    ## [<-
    ref_obj_array_cloned <- ref_obj_array$clone()
    ref_obj_array_cloned[c("A", "C"), "a"] <- obj_to_insert
    expect_equal(ref_obj_array_cloned, ref_obj_array_inserted)

    ref_obj <- H5R_DATASET_REGION$new(id=file.h5)
    ref_obj$ref <- as.raw(0:191)
    expect_equal(ref_obj$length, 16)


    ## test one item subsetting and writing
    ref_obj_subsetted <- H5R_OBJECT$new(id=file.h5)
    ref_obj_subsetted$ref <- ref_obj$ref[25:32]

    ref_obj_written <- ref_obj_vector$clone()
    ref_obj_written$ref[25:32] <- as.raw(0:7)

    expect_equal(ref_obj_vector$subset2_read(4), ref_obj_subsetted)
    expect_equal(ref_obj_vector$subset2_read("D"), ref_obj_subsetted)

    ## not doing [[, but [ as [[ is used by R6 itself
    ## [[
    ref_obj_vector_elemD <- ref_obj_vector["D"]
    ref_obj_vector_elemD$names <- NULL
    expect_equal(ref_obj_vector_elemD, ref_obj_subsetted)

    expect_equal(ref_obj_vector$clone()$subset2_assign(4, value=as.raw(0:7)), ref_obj_written)
    expect_equal(ref_obj_vector$clone()$subset2_assign("D", value=as.raw(0:7)), ref_obj_written)

    ## [[<-
    ref_obj_vector_cloned <- ref_obj_vector$clone()
    ref_obj_vector_cloned["D"] <- as.raw(0:7)
    expect_equal(ref_obj_vector_cloned, ref_obj_written)

    ## test that [i] and [i,] give different results
    expect_equal(ref_obj_array[1,]$length, 6)
    expect_equal(ref_obj_array[1]$length, 1)

    ## test setting of a dim attribute using the C-function
    .Call("set_dim_attribute", ref_obj_array, c(6, 4), PACKAGE = "hdf5r")
    expect_equal(ref_obj_array$dim, c(6, 4))
    
    file.h5$close_all()
    file.remove(test_file)

})


test_that("UI functions for reference vector", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")

    r1 <- H5R_OBJECT$new(id=file.h5)
    r1$ref <- as.raw(0:31)
    r1$names <- c("A", "B", "C", "D")
    r2 <- H5R_OBJECT$new(id=file.h5)
    r2$ref <- as.raw(8:23)
    r3 <- H5R_OBJECT$new(id=file.h5)
    r3$ref <- as.raw(16:31)
    r3$names <- c("E", "F")

    ## concatenate
    r_concat <- c(r1, r2, r3)
    r_concat_compare <- H5R_OBJECT$new(id=file.h5)
    r_concat_compare$ref <- c(r1$ref, r2$ref, r3$ref)
    r_concat_compare$names <- c("A", "B", "C", "D", "", "", "E", "F")
    expect_equal(r_concat, r_concat_compare)
    
    ## make them all to matrices
    r1$dim <- c(2, 2)
    r2$dim <- c(2, 1)
    r3$dim <- c(2, 1)

    ## assign dimnames to the first one
    r1$dimnames <- list(c("A", "B"), c("C", "D"))
    
    ## bind them together by columns
    r_cbind <- cbind(r1, r2, r3)

    ## transpose them and row bind them
    r1_t <- t(r1)
    r2_t <- t(r2)
    r3_t <- t(r3)
    r1_t_cmp <- cbind(r1[1,], r1[2,])
    dimnames(r1_t_cmp) <- dimnames(r1_t)
    expect_equal(r1_t, r1_t_cmp)
    
    r_rbind <- rbind(r1_t, r2_t, r3_t)
    expect_equal(t(r_rbind), r_cbind)
    

    ## put them into a data-frame
    r_df <- data.frame(r1=r1, r2=r2, r3=r3)
    expect_equal(dim(r_df), c(2,4))
    file.h5$close_all()
    file.remove(test_file)

})


test_that("Create and dereference references; save in a dataset", {
    test_file <- tempfile(fileext=".h5")
    ## open a new one, truncate if it exists
    file.h5 <- H5File$new(test_file, mode="w")
    grp1 <- file.h5$create_group("test1")

    ## test an object reference
    ref <- grp1$create_reference()
    grp1_ref <- ref$dereference()[[1]]
    expect_equal(grp1$obj_info(), grp1_ref$obj_info())

    ## test a dataset region reference
    grp1[["test_data"]] <- matrix(1:40, ncol=4)

    ds <- grp1[["test_data"]]
    ds_space <- ds$get_space()
    ds_space <- ds_space[2:5, 1:2]
    ds_ref_1 <- ds$create_reference(2:5, 1:2)
    ds_ref_2 <- grp1$create_reference("test_data", ds_space)

    ## now de-reference again
    ds_ref_1$dereference()
    ds_ref_1$dereference(get_value=TRUE)

    expect_equal(ds_ref_1$dereference(get_value=TRUE)[[1]], ds[2:5, 1:2])
    expect_equal(ds_ref_2$dereference(get_value=TRUE)[[1]], ds[2:5, 1:2])

    ## now save them in a dataset and read them back out
    
    file.h5[["obj_ref_dataset"]] <- ref
    file.h5[["dset_ref_dataset"]] <- ds_ref_1

    ref_read <- file.h5[["obj_ref_dataset"]][]
    ds_ref_read <- file.h5[["dset_ref_dataset"]][]

    expect_equal(ref_read$dereference()[[1]]$obj_info(), grp1$obj_info())
    expect_equal(ds_ref_read$dereference(get_value=TRUE)[[1]], ds[2:5, 1:2])
    
    file.h5$close_all()
    file.remove(test_file)

})





---
File: /tests/testthat/test-zzz-Attribute.R
---

context("h5-Attribute")

fname <- tempfile(fileext=".h5")

testvec_i <- as.integer(1:90)
testmat_i <- matrix(testvec_i, ncol = 9)
testarray_i <- array(testvec_i, dim = c(3, 3, 10))

testvec_n <- as.numeric(1:90)
testmat_n <- matrix(testvec_n, ncol = 9)
testarray_n <- array(testvec_n, dim = c(3, 3, 10))

testvec_s <- paste0(LETTERS[1:90], LETTERS[seq(90, 1)])
testmat_s <- matrix(testvec_s, ncol = 9)
testarray_s <- array(testvec_s, dim = c(3, 3, 10))
maxchar <- max(nchar(testvec_s))


testvec_l <- rep(c(TRUE, FALSE), 45)
testmat_l <- matrix(testvec_l, ncol = 9)
testarray_l <- array(testvec_l, dim = c(3, 3, 10))

testall <- list(
    testvec_i, testmat_i, testarray_i,
    testvec_n, testmat_n, testarray_n, 
    testvec_l, testmat_l, testarray_l,
    testvec_s, testmat_s, testarray_s,
    testvec_s, testmat_s, testarray_s
    )

    
test_that("Attribute-Errors", {   
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  f <- function() h5attr(file, "test")
  expect_that(f(), throws_error("Attribute does not exist"))    
  h5attr(file, "test") <- c("A", "BE", "BU")
  
  f <- function() h5attr(file, "test") <- c("a", "be", "bu")
  
  group <- createGroup(file, "testgroup")
  f <- function() h5attr(group, "test")
  expect_that(f(), throws_error("Attribute does not exist"))    
  h5attr(group, "test") <- c("A", "BE", "BU")
  
  group[["testset"]] <- 1:10
  dset <- group[["testset"]] 
  f <- function() h5attr(dset, "test")
  expect_that(f(), throws_error("Attribute does not exist"))    
  h5attr(dset, "test") <- c("A", "BE", "BU")
  h5close(dset)
  h5close(group)
  h5close(file)
  
  file <- h5file(fname, "r")
  expect_that(h5attr(file, "test"), is_identical_to(c("A", "BE", "BU")))
  group <- file[["testgroup"]]
  expect_that(h5attr(group, "test"), is_identical_to(c("A", "BE", "BU")))
  dset <- group[["testset"]]
  expect_that(h5attr(dset, "test"), is_identical_to(c("A", "BE", "BU")))
  h5close(dset)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})      
      
test_that("Attribute-H5Type-File", {      
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  
  for(i in 1:length(testall)) {
    aname <- sprintf("attribute_%02d", i)
    #if(i < length(testall))
    h5attr(file, aname) <- testall[[i]]
    #else
    #  h5attr(file, aname, size = maxchar) <- testall[[i]]
  }
  
  group <- createGroup(file, "testgroup")
  
  for(i in 1:length(testall)) {
    aname <- sprintf("attribute_%02d", i)
    #if(i < length(testall))
    h5attr(group, aname) <- testall[[i]]
    #else
    #  h5attr(group, aname, size = maxchar) <- testall[[i]]
  }
 
  file[["testgroup/dset"]] <- 1:10
  dset <- file[["testgroup/dset"]]
  for(i in 1:length(testall)) {
    aname <- sprintf("attribute_%02d", i)
    #if(i < length(testall))
    h5attr(dset, aname) <- testall[[i]]
    #else
    #  h5attr(dset, aname, size = maxchar) <- testall[[i]]
  }
  h5close(group)
  h5close(dset)
  h5close(file) 
  
  file <- h5file(fname, "r")
  for(i in 1:length(testall)) {
    aname <- sprintf("attribute_%02d", i)
    expect_that(h5attr(file, aname), is_identical_to(testall[[i]]))
  }
  
  group <- file[["testgroup"]]
  for(i in 1:length(testall)) {
    aname <- sprintf("attribute_%02d", i)
    expect_that(h5attr(group, aname), is_identical_to(testall[[i]]))
  }
  
  dset <- group[["dset"]]
  for(i in 1:length(testall)) {
    aname <- sprintf("attribute_%02d", i)
    expect_that(h5attr(dset, aname), is_identical_to(testall[[i]]))
  }
  h5close(group)
  h5close(dset)
  h5close(file) 
  expect_true(file.remove(fname))
})    

test_that("Attribute-list-attributes", {      
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)
  
  # TODO(mario): Support on-the-fly group creation?
  #file[["testgroup/testset"]] <- 1:10
  g1 <- createGroup(file, "testgroup")
  g1[["testset"]] <- 1:10
  
  h5attr(file, "fileattr1") <- 1:10
  h5attr(file, "fileattr2") <- 1:10
  h5attr(file, "fileattr3") <- 1:10
  
  testset <- file[["testgroup/testset"]]
  h5attr(testset, "dsetattr1") <- 1:10
  h5attr(testset, "dsetattr2") <- 1:10
  h5attr(testset, "dsetattr3") <- 1:10
  
  # TODO(mario): check why  Attribute-list-attributes not working for file subset
  #  h5attr(file["testgroup/testset"], "dsteattr1") <- 1:10
  #  h5attr(file["testgroup/testset"], "dsteattr2") <- 1:10
  #  h5attr(file["testgroup/testset"], "dsteattr3") <- 1:10
  
  # TODO(mario): Implement list.attributes
  expect_that(list.attributes(file),
      is_identical_to(c("fileattr1", "fileattr2", "fileattr3")))
  expect_that(list.attributes(testset),
      is_identical_to(c("dsetattr1", "dsetattr2", "dsetattr3")))
  
  h5close(testset)
  # TODO(mario): check why  Attribute-list-attributes not working for file subset
  # h5attr(file[["testgroup"]], "groupattr1") <- 1:10
  # h5attr(file[["testgroup"]], "groupattr2") <- 1:10
  # h5attr(file[["testgroup"]], "groupattr3") <- 1:10
  # expect_that(list.attributes(file["testgroup"]),
  #     is_identical_to(c("groupattr1", "groupattr2", "groupattr3")))

  h5close(file) 
  expect_true(file.remove(fname))
})

test_that("Bug_AttributeGroupSubset", {        
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)
  file[["testdataset"]] <- 1:10
  h5attr(file, "testattrib") <- LETTERS[1:10]
  createGroup(file, "testgroup")
  file[["testgroup/testdataset2"]] <- 1:10

  h5attr(file[["testdataset"]], "test") <- 1:10
  h5close(file) 
  expect_true(file.remove(fname))
})

test_that("Attribute-Bug-Scalar-Issue09",{	
  fname <- system.file("test-f32.h5", package = "hdf5r", mustWork = TRUE)
  file <- h5file(fname, "r")
  expect_that(substr(h5attr(file[["floats"]], "scalar"), 1, 5), is_identical_to("Hello"))
  h5close(file)
})



---
File: /tests/testthat/test-zzz-DataSet-extend.R
---

context("h5-DataSet-extend")

fname <- tempfile(fileext=".h5")

test_that("DataSet-extend",{  
  testmat_n <- matrix(as.integer(1:90), ncol = 9)
  
  # Test normal usecase with unlimited dset
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  dspace <- H5S$new(maxdims = dim(testmat_n)) 
  # TODO(mario): this should work without setting chunk size:
  #dset1 <- createDataSet(file, "testmat_1", testmat_n, space = dspace)
  dset1 <- createDataSet(file, "testmat_1", robj = testmat_n)
  
  dimtestmat_n <- dim(testmat_n)
  dimtestmat_n_x1 <- dimtestmat_n_y1 <- dimtestmat_n
  dimtestmat_n_x1[1] <- dimtestmat_n_x1[1] - 1
  dimtestmat_n_y1[2] <- dimtestmat_n_y1[2] - 1
  
  f <- function() extendDataSet(dset1, dimtestmat_n_x1)
  expect_that(f(), throws_error("Number of extendible dimensions must be greater or equal than DataSet dimensions"))
  
  f <- function() extendDataSet(dset1, dimtestmat_n_y1)
  expect_that(f(), throws_error("Number of extendible dimensions must be greater or equal than DataSet dimensions"))
  
  
  dimtestmat_n_x1[1] <- dimtestmat_n[1] + 1
  f <- function() extendDataSet(dset1, dimtestmat_n_x1)
  # TODO(mario): How to set up dataset with specified maximum dimensions, only using set_extend?
  # expect_that(f(), throws_error("Number of extendible dimensions exceeds maximum dimensions of DataSet"))
  h5close(dset1)
  
  testmat_n_2 <- dim(testmat_n) * 2
  dset2 <- createDataSet(file, "testmat_2", robj = testmat_n)
  dset2 <- extendDataSet(dset2, testmat_n_2)
  expect_equal(dset2$dims, testmat_n_2)
  
  testmat <- rbind(cbind(testmat_n, 
      matrix(rep(0, length(testmat_n)), nrow = nrow(testmat_n))), 
      matrix(rep(0, dim(testmat_n)[1] * dim(testmat_n)[2] * 2), nrow = nrow(testmat_n)))
  
  expect_equal(readDataSet(dset2), testmat)

  h5close(dset2)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-extend-matrix-rbind",{  
  testmat_n <- matrix(as.integer(1:90), ncol = 9)
  
  # Test normal usecase with unlimited dset
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  dset1 <- createDataSet(file, "testmat_1", testmat_n)
  
  f <- function() rbind(dset1, matrix(1:8, ncol = 8))
  expect_that(f(), throws_error("Data to append does not match dataset dimensions"))
  
  # TODO(mario): Check datatype before dataset is extended
  #f <- function() rbind(dset1, matrix(LETTERS[1:9], ncol = 9))
  #expect_that(f(), throws_error("In RToH5_INTEGER can't convert type of object passed"))
  #  f <- function() rbind(dset1, matrix(integer(0), ncol = dset1@dim[2L]))
  #  expect_that(f(), throws_error("H5Sget_select_bounds failed in DataSpace::getSelectBounds"))
  dset1 <- rbind(dset1, matrix(rep(1L, dset1$dims[2]), ncol = dset1$dims[2]))
  h5close(dset1)
  dset2 <- createDataSet(file, "testmat_2", testmat_n)
  dset2 <- rbind(dset2, testmat_n)
  h5close(dset2)
  h5close(file)

  file <- h5file(fname, "r")
  dset1 <- openLocation(file, "testmat_1")
  expect_that(readDataSet(dset1), is_identical_to(rbind(testmat_n, 1L)))
  h5close(dset1)
  dset2 <- openLocation(file, "testmat_2")
  expect_that(readDataSet(dset2), is_identical_to(rbind(testmat_n, testmat_n)))
  h5close(dset2)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-extend-matrix-cbind",{  
  testmat_n <- matrix(as.integer(1:90), nrow = 10)
  
  # Test normal usecase with unlimited dset
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  dset1 <- createDataSet(file, "testmat_1", testmat_n)
  
  f <- function() cbind(dset1, matrix(1:9, nrow = 9))
  expect_that(f(), throws_error("Data to append does not match dataset dimensions"))
  
  # TODO(mario): Check datatype before dataset is extended
  # f <- function() cbind(dset1, matrix(LETTERS[1:10], nrow = 10))
  # expect_that(f(), throws_error("In RToH5_INTEGER can't convert type of object passed"))
  # f <- function() cbind(dset1, matrix(integer(0), nrow = dset1@dim[1L]))
  # expect_that(f(), throws_error("Elements of parameter count must be greater than zero"))
  
  dset1 <- cbind(dset1, matrix(as.integer(rep(1, nrow(testmat_n))), ncol = 1))
  h5close(dset1)
  dset2 <- createDataSet(file, "testmat_2", testmat_n)
  dset2 <- cbind(dset2, testmat_n)
  h5close(dset2)
  h5close(file)
  
  file <- h5file(fname, "r")
  dset1 <- openLocation(file, "testmat_1")
  expect_that(readDataSet(dset1), is_identical_to(cbind(testmat_n, 1L)))
  h5close(dset1)
  dset2 <- openLocation(file, "testmat_2")
  expect_that(readDataSet(dset2), is_identical_to(cbind(testmat_n, testmat_n)))
  h5close(dset2)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-extend-vector-c",{  
  testmat_n <- as.integer(1:90)
  
  # Test normal usecase with unlimited dset
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  dset1 <- createDataSet(file, "testmat_1", testmat_n)
  
  f <- function() c(dset1, integer(0))
  expect_that(f(), throws_error("Retrieving hyperslabs in reverse order not supported"))
  
  dset1 <- c(dset1, rep(1L, length(testmat_n)), rep(2L, length(testmat_n)))
  h5close(dset1)
  h5close(file)
  
  file <- h5file(fname, "r")
  dset1 <- openLocation(file, "testmat_1")
  testmat_n_extend <- c(testmat_n, rep(1L, length(testmat_n)), rep(2L, length(testmat_n)))
  expect_that(readDataSet(dset1), is_identical_to(testmat_n_extend))
  h5close(dset1)
  h5close(file)
  expect_true(file.remove(fname))
})





---
File: /tests/testthat/test-zzz-DataSet-IO-NA.R
---

context("h5-DataSet-Vector-NA")

test_that("DataSet-Vector-NA",{
  fname <- tempfile(fileext=".h5")
  testvec_n <- rnorm(120)
  testvec_i <- as.integer(runif(120)*10000)
  testvec_l <- as.logical(round(runif(120)))
  testvec_c <-rep(paste0(LETTERS[1:3], rev(LETTERS)[1:3]), 120/3)
  testvec_c[1] <- paste0(testvec_c[1], testvec_c[1])
  testvec_c[40] <- paste0(testvec_c[1], testvec_c[1])
  
  testvec_n[seq(1, 120, 10)] <- NA_real_
  testvec_i[seq(1, 120, 10)] <- NA_integer_
  testvec_l[seq(1, 120, 10)] <- NA
  testvec_c[seq(1, 120, 10)] <- NA_character_
      
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testvec_n", testvec_n)
  h5close(dset1)
  dset2 <- createDataSet(group, "testvec_l", testvec_l)
  h5close(dset2)
  dset3 <- createDataSet(group, "testvec_i", testvec_i)
  h5close(dset3)
  
  dset4 <- createDataSet(group, "testvec_c", testvec_c)
  h5close(dset4)

  dset5 <- createDataSet(group, "testvec_c4", testvec_c)
  h5close(dset5)
  
  h5close(group)
  h5close(file)
  
  ### Check if written data equals input data
  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset11 <- openLocation(group, "testvec_n")
  testvec_n_read <- readDataSet(dset11)
  h5close(dset11)
  expect_that(testvec_n, is_identical_to(testvec_n_read))
  
  dset12 <- openLocation(group, "testvec_l")
  testvec_l_read <- readDataSet(dset12)
  h5close(dset12)
  expect_that(testvec_l, is_identical_to(testvec_l_read))
  
  dset13 <- openLocation(group, "testvec_i")
  testvec_i_read <- readDataSet(dset13)
  h5close(dset13)
  expect_that(testvec_i, is_identical_to(testvec_i_read))

  # TODO(mario): NA handling for strings does not work properly  
  # dset14 <- openLocation(group, "testvec_c")
  # testvec_c_read <- readDataSet(dset14)
  # h5close(dset14)
  # expect_that(testvec_c, is_identical_to(testvec_c_read))
  # 
  # dset15 <- openLocation(group, "testvec_c4")
  # testvec_c_read <- readDataSet(dset15)
  # h5close(dset15)
  # expect_that(testvec_c, is_identical_to(testvec_c_read))
  
  h5close(group)
  h5close(file)		
  expect_true(file.remove(fname))
})



---
File: /tests/testthat/test-zzz-DataSet-IO.R
---

context("h5-DataSet-Vector")

fname <- tempfile(fileext=".h5")

test_that("DataSet-Vector",{
  testvec_n <- rnorm(120)
  testvec_i <- as.integer(runif(120)*10000)
  testvec_l <- as.logical(round(runif(120)))
  testvec_c <-rep(paste0(LETTERS[1:3], rev(LETTERS)[1:3]), 120/3)
  testvec_c[1] <- paste0(testvec_c[1], testvec_c[1])
  testvec_c[40] <- paste0(testvec_c[1], testvec_c[1])
  
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testvec_n", testvec_n)
  h5close(dset1)
  dset2 <- createDataSet(group, "testvec_l", testvec_l)
  h5close(dset2)
  dset3 <- createDataSet(group, "testvec_i", testvec_i)
  h5close(dset3)
  
  dset4 <- createDataSet(group, "testvec_c", testvec_c)
  h5close(dset4)

  dset5 <- createDataSet(group, "testvec_c4", testvec_c)
  h5close(dset5)
  
  h5close(group)
  h5close(file)
  
  ### Check if written data equals input data
  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset11 <- openLocation(group, "testvec_n")
  testvec_n_read <- readDataSet(dset11)
  h5close(dset11)
  expect_that(testvec_n, is_identical_to(testvec_n_read))
  
  dset12 <- openLocation(group, "testvec_l")
  testvec_l_read <- readDataSet(dset12)
  h5close(dset12)
  expect_that(testvec_l, is_identical_to(testvec_l_read))
  
  dset13 <- openLocation(group, "testvec_i")
  testvec_i_read <- readDataSet(dset13)
  h5close(dset13)
  expect_that(testvec_i, is_identical_to(testvec_i_read))
  
  dset14 <- openLocation(group, "testvec_c")
  testvec_c_read <- readDataSet(dset14)
  h5close(dset14)
  expect_that(testvec_c, is_identical_to(testvec_c_read))

  dset15 <- openLocation(group, "testvec_c4")
  testvec_c_read <- readDataSet(dset15)
  h5close(dset15)
  expect_that(testvec_c, is_identical_to(testvec_c_read))
  
  h5close(group)
  h5close(file)		
  expect_true(file.remove(fname))
})

context("DataSet-Vector-boundaries")

test_that("DataSet-Vector-boundaries",{
  
  if(file.exists(fname)) file.remove(fname)
  
  file <- h5file(fname, "a")
  
  # TODO: check if code below should work
  #  testvec_i_0 <- integer(0)
  #  dset0 <- createDataSet(file, "testvec_i_0", testvec_i_0)
  #  h5close(dset0)
  
  testvec_i_1 <- 1L
  dset1 <- createDataSet(file, "testvec_i_1", testvec_i_1)
  h5close(dset1)
  
  testvec_i_2 <- c(1L, 1L)
  dset2 <- createDataSet(file, "testvec_i_2", testvec_i_2)
  h5close(dset2)
  
  # testvec_i_max <- rep(1L, length.out = .Machine$integer.max)
  # dsetmax <- createDataSet(file, "testvec_i_max", testvec_i_max)
  # h5close(dsetmax)
  # 
  # testvec_i_max_1 <- rep(1L, length.out = .Machine$integer.max + 1)
  # dsetmax_1 <- createDataSet(file, "testvec_i_max_1", testvec_i_max_1)
  # h5close(dsetmax_1)

  h5close(file)
  
  ### Check if written data equals input data
  file <- h5file(fname, "r")
  
#  dset0 <- openLocation(file, "testvec_i_0")
#  testvec_i_0_read <- readDataSet(dset0)
#  h5close(dset0)
#  expect_that(testvec_i_0, is_identical_to(testvec_i_0_read))
  
  dset1 <- openLocation(file, "testvec_i_1")
  testvec_i_1_read <- readDataSet(dset1)
  h5close(dset1)
  expect_that(testvec_i_1, is_identical_to(testvec_i_1_read))
  
#  dsetmax <- openLocation(file, "testvec_i_max")
#  testvec_i_max_read <- readDataSet(dsetmax)
#  h5close(dsetmax)
#  expect_that(testvec_i_max, is_identical_to(testvec_i_max_read))
#  
#  dsetmax_1 <- openLocation(file, "testvec_i_max_1")
#  testvec_i_max_1_read <- readDataSet(dsetmax_1)
#  h5close(dsetmax_1)
#  expect_that(testvec_i_max_1, is_identical_to(testvec_i_max_1_read))
  
  h5close(file)
  expect_true(file.remove(fname))
})

context("DataSet-Matrix")

test_that("datatypes-Matrix",{
  
  testmat_n <- matrix(rnorm(120), ncol = 3)
  testmat_i <- matrix(as.integer(runif(120)*10000), ncol = 3)
  testmat_l <- matrix(as.logical(round(runif(120))), ncol = 3)
  testmat_c <- matrix(rep(paste0(LETTERS[1:3], rev(LETTERS)[1:3]), 120/3), ncol = 3)
  testmat_c[1,1] <- paste0(testmat_c[1,1], testmat_c[1,1])
  testmat_c[40,2] <- paste0(testmat_c[1,1], testmat_c[1,1])
  
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  h5close(dset1)
  dset2 <- createDataSet(group, "testmat_l", testmat_l)
  h5close(dset2)
  dset3 <- createDataSet(group, "testmat_i", testmat_i)
  h5close(dset3)
  
  dset4 <- createDataSet(group, "testmat_c", testmat_c)
  h5close(dset4)
  
  dset5 <- createDataSet(group, "testmat_c4", testmat_c)
  h5close(dset5)
  
  h5close(group)
  h5close(file)
  
  ### Check if written data equals input data
  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  
  dset11 <- openLocation(group, "testmat_n")
  testmat_n_read <- readDataSet(dset11)
  h5close(dset11)
  expect_that(testmat_n, is_identical_to(testmat_n_read))
  
  dset12 <- openLocation(group, "testmat_l")
  testmat_l_read <- readDataSet(dset12)
  h5close(dset12)
  expect_that(testmat_l, is_identical_to(testmat_l_read))
  
  dset13 <- openLocation(group, "testmat_i")
  testmat_i_read <- readDataSet(dset13)
  h5close(dset13)
  expect_that(testmat_i, is_identical_to(testmat_i_read))
  
  dset14 <- openLocation(group, "testmat_c")
  testmat_c_read <- readDataSet(dset14)
  h5close(dset14)
  expect_that(testmat_c, is_identical_to(testmat_c_read))
  
  dset15 <- openLocation(group, "testmat_c4")
  testmat_c4_read <- readDataSet(dset15)
  h5close(dset15)
  expect_that(testmat_c, is_identical_to(testmat_c4_read))
  
  h5close(group)
  h5close(file)
  
  expect_true(file.remove(fname))
})

context("DataSet-Array")

test_that("datatypes-Array",{
  testmat_n <- array(rnorm(120), c(3,4,10))
  testmat_i <- array(as.integer(runif(120)*10000), c(3,4,2,5))
  testmat_l <- array(as.logical(round(runif(120))), c(3,4,10))
  testmat_l <- array(as.logical(round(runif(120))), c(3,4,2,5))
  testmat_c <- array(rep(paste0(LETTERS[1:3], rev(LETTERS)[1:3]), 120/3), c(3,4,2,5))
  testmat_c[1,1,1,1] <- paste0(testmat_c[1,1,1,1], testmat_c[1,1,1,1])
  testmat_c[3,4,2,1] <- paste0(testmat_c[1,1,1,1], testmat_c[1,1,1,1])
  
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  h5close(dset1)
  dset2 <- createDataSet(group, "testmat_l", testmat_l)
  h5close(dset2)
  dset3 <- createDataSet(group, "testmat_i", testmat_i)
  h5close(dset3)
  
  dset4 <- createDataSet(group, "testmat_c", testmat_c)
  h5close(dset4)
  
  dset5 <- createDataSet(group, "testmat_c4", testmat_c)
  h5close(dset5)
  
  h5close(group)
  h5close(file)
  
  
  ### Check if written data equals input data
  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset11 <- openLocation(group, "testmat_n")
  testmat_n_read <- readDataSet(dset11)
  h5close(dset11)
  expect_that(testmat_n, is_identical_to(testmat_n_read))
  
  dset12 <- openLocation(group, "testmat_l")
  testmat_l_read <- readDataSet(dset12)
  h5close(dset12)
  expect_that(testmat_l, is_identical_to(testmat_l_read))
  
  dset13 <- openLocation(group, "testmat_i")
  testmat_i_read <- readDataSet(dset13)
  h5close(dset13)
  expect_that(testmat_i, is_identical_to(testmat_i_read))
  
  dset14 <- openLocation(group, "testmat_c")
  testmat_c_read <- readDataSet(dset14)
  h5close(dset14)
  expect_that(testmat_c, is_identical_to(testmat_c_read))
  
  dset15 <- openLocation(group, "testmat_c4")
  testmat_c4_read <- readDataSet(dset15)
  h5close(dset15)
  expect_that(testmat_c, is_identical_to(testmat_c4_read))
  h5close(group)
  h5close(file)
  
  expect_true(file.remove(fname))
})

test_that("datatypes-Array-BugWithChunksize",{
	testmat_n <- array(rnorm(347000), c(1, 1, 1, 347000))
	if(file.exists(fname)) file.remove(fname)
	file <- h5file(fname, "a")
	group <- createGroup(file, "DataSet")
	
	dset1 <- createDataSet(group, "testmat_n", testmat_n, chunk_dims = c(1, 1, 1, 347000))
	h5close(dset1)
	h5close(group)
	h5close(file)
  expect_true(file.remove(fname))
})

test_that("datatypes-Array-BugWithASCII",{
  fname <- system.file("test-ascii-length-bug.h5", package = "hdf5r", mustWork = TRUE)
  file <- h5file(fname, "r")
  
  varlength = c("mar231-21y", "ha131d", "a", "litt321le", "lamb", "its", 
      "Fleece", "As", "Wh31ite", "as", "snow")
  expect_that(file[["test/ascii"]][], is_identical_to(varlength))
  expect_that( file[["test/randomalpha"]][], 
      is_identical_to(file[["test/randomalphashort"]][]))

  h5close(file)
})





---
File: /tests/testthat/test-zzz-DataSet-scalar.R
---

context("h5-DataSet-scalar")

fname <- tempfile(fileext=".h5")

test_that("datatypes-Array-BugWithScalar",{
      fname <- system.file("test-scalar.h5", package = "hdf5r", mustWork = TRUE)
      f <- h5file(fname, "r")
      dset <- f[["/Analyses/Basecall_2D_000/BaseCalled_2D/Fastq"]]
      dat <- dset[]
      expect_identical(length(dat), 1L)
      expect_is(dat, "character")
      h5close(f)
    })



---
File: /tests/testthat/test-zzz-DataSet-Select-Subset.R
---

context("h5-DataSet-Select-Subset")

fname <- tempfile(fileext=".h5")

test_that("DataSet-Select-Subset-params",{
  testmat_n <- matrix(as.integer(1:90), ncol = 9)

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  h5close(dset1)
  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testmat_n")

  # Check elem NAs
  f <- function() dset1[c(1:5, NA), 1:5]
  expect_that(f(), throws_error("missing value where TRUE/FALSE needed"))

  # Check elem datatype
  #f <- function() readDataSet(dset1, selectDataSpace(dset1, elem = matrix("a")))
  #expect_that(f(), throws_error("Element matrix must be of type double or integer"))

  # Check elem length
  #f <- function() testmat_n_na_boundall <- readDataSet(dset1,
  #      selectDataSpace(dset1, elem = matrix(1:9, nrow = 3)))
  #expect_that(f(), throws_error("Number of elem matrix columns must equal length of dataset dimensions"))

  # Check elem positive

  # TODO(mario): Subsetting allows zero and negative values
  #f <- function() dset1[0L, 1L]
  #expect_that(f(), throws_error("Elements of parameter elem must be greater or equal than one."))

  f <- function() testmat_n_na_bound_1 <- dset1[1:11, 1:9]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 1"))

  f <- function() testmat_n_na_bound_1 <- dset1[1:10, 1:10]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 2"))

  h5close(dset1)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-vector-read",{
  testvec_n <- as.integer(1:90)

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testvec_n", testvec_n)
  h5close(dset1)

  # Write Elem
  dset2 <- createDataSet(group, "testvec_n2", testvec_n)

  subvec <- 1:3
  f <- function() dset2[89:91]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 1"))

  dset2[88:90] <- subvec
  h5close(dset2)

  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testvec_n")

  # Read entire dataset
  testvec_n_read_all <- dset1[1:dset1$dims]
  expect_that(testvec_n_read_all, is_identical_to(testvec_n))

  # Read dataset parts
  selector <- as.integer(seq(1, dset1$dims), by = 2)
  testvec_n_read_sel <- dset1[selector]
  expect_that(testvec_n_read_sel, is_identical_to(selector))
  h5close(dset1)

  dset2 <- openLocation(group, "testvec_n2")
  expect_that(dset2[], is_identical_to(c(1:87, 1:3)))

  h5close(dset2)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-read-string", {
      vec <- paste0(LETTERS[1:9], c(LETTERS[1:9]))
      vec[1] <- "AAA"
      mat <- matrix(LETTERS[1:9], nrow = 3)
      arr <- array(paste0(LETTERS[rep(1, 45)], c(LETTERS[rep(1, 45)])),
          dim = c(3, 3, 5))
      arr[1, 1, 1] <- "blablabla"

      if(file.exists(fname)) file.remove(fname)
      file <- h5file(fname)
      gr1 <- createGroup(file, "test")
      gr1[["testvec"]] <- LETTERS[1:9]
      grmat <- createGroup(gr1, "testmat")
      grmat[["testmat"]] <- mat
      gr1[["testarray"]] <- arr
      h5close(file)

      file <- h5file(fname, "r")
      testvec <- file[["test/testvec"]]
      expect_that(testvec[1:3], is_identical_to(LETTERS[1:3]))
      h5close(testvec)

      testmat <- file[["test/testmat/testmat"]]
      expect_that(testmat[1:2, ], is_identical_to(mat[1:2, ]))
      h5close(testmat)

      testarray <- file[["test/testarray"]]
      expect_that(testarray$read(), is_identical_to(arr))
      h5close(testarray)
      h5close(file)
      expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-read-string-fixed", {
      fname <- tempfile(fileext=".h5")
      vec <- paste0(LETTERS[1:9], c(LETTERS[1:9]))
      vec[1] <- "AAA"
      mat <- matrix(LETTERS[1:9], nrow = 3)
      arr <- array(paste0(LETTERS[rep(1, 45)], c(LETTERS[rep(1, 45)])),
          dim = c(3, 3, 5))
      arr[1, 1, 1] <- "blablabla"

      if(file.exists(fname)) file.remove(fname)
      file <- h5file(fname)
      gr1 <- createGroup(file, "test")
      gr1[["testvec", size = 1]] <- LETTERS[1:9]
      grmat <- createGroup(gr1, "testmat")
      grmat[["testmat", size = 1]] <- mat
      file[["testarray", size = max(nchar(as.vector(arr)))]] <- arr
      h5close(file)

      file <- h5file(fname, "r")
      testvec <- file[["test/testvec"]]
      expect_that(testvec[1:3], is_identical_to(LETTERS[1:3]))
      h5close(testvec)

      testmat <- file[["test/testmat/testmat"]]
      expect_that(testmat[1:2, ], is_identical_to(mat[1:2, ]))
      h5close(testmat)

      testarray <- file[["testarray"]]
      expect_that(testarray$read(), is_identical_to(arr))
      h5close(testarray)
      h5close(file)
      expect_true(file.remove(fname))
    })

test_that("DataSet-Select-Subset-vector-write",{
  testvec_n <- as.integer(1:90)

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testvec_n", testvec_n)
  h5close(dset1)

  # Write Elem
  dset2 <- createDataSet(group, "testvec_n2", testvec_n)

  subvec <- 1:3
  dset2[89:91] <- subvec

  f <- function() dset2[87:90] <- subvec
  expect_that(f(), throws_error("Number of objects in robj is not the same and not a multiple of number of elements selected in file"))

  dset2[88:90] <- subvec
  h5close(dset2)

  dset3 <- createDataSet(group, "testvec_n3", testvec_n)
  dset3[] <- -testvec_n

  h5close(dset3)
  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testvec_n")

  # Read entire dataset
  testvec_n_read_all <- dset1[]
  expect_that(testvec_n_read_all, is_identical_to(testvec_n))

  # Read dataset parts
  selector <- as.integer(seq(1, dset1$dims), by = 2)
  testvec_n_read_sel <- dset1[selector]
  expect_that(testvec_n_read_sel, is_identical_to(selector))
  h5close(dset1)

  dset2 <- openLocation(group, "testvec_n2")
  expect_that(dset2[], is_identical_to(as.integer(c(1:87, 1:3, 3))))

  dset3 <- openLocation(group, "testvec_n3")
  expect_that(dset3[], is_identical_to(-testvec_n))

  h5close(dset3)
  h5close(dset2)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-matrix-read",{
  testmat_n <- matrix(as.integer(1:90), ncol = 9)

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  h5close(dset1)
  dset2 <- createDataSet(group, "testmat_n2", testmat_n)
  submat <- matrix(-1L:-9L, nrow = 3)
  f <- function() dset2[10:11, 9]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 1"))

  f <- function() dset2[10, 9:10]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 2"))

  f <- function() dset2[1, 1, 1]
  expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 3 vs. 2"))

  f <- function() dset2[ , , ]
  expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 3 vs. 2"))

  h5close(dset2)
  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testmat_n")

  # Read entire dataset
  expect_that(readDataSet(dset1), is_identical_to(testmat_n))
  expect_that(dset1$read(), is_identical_to(testmat_n))
  expect_that(dset1[,], is_identical_to(testmat_n))

  # Read single element
  #testmat_n_read_2_2 <- readDataSet(dset1, selectDataSpace(dset1, elem = t(c(2L, 2L))))
  #expect_that(testmat_n_read_2_2, is_identical_to(testmat_n[2, 2]))
  expect_that(dset1[2, 2], is_identical_to(testmat_n[2, 2]))

  # Read columns / rows
  # TODO: drop should also be implemented
  expect_that(dset1[, 2], is_identical_to(testmat_n[, 2, drop = TRUE]))
  expect_that(dset1[, 2:4], is_identical_to(testmat_n[, 2:4, drop = TRUE]))
  expect_that(dset1[2, ], is_identical_to(testmat_n[2,, drop = TRUE]))
  expect_that(dset1[2:4, ], is_identical_to(testmat_n[2:4,, drop = TRUE]))

  h5close(dset1)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-matrix-write",{
  testmat_n <- matrix(as.integer(1:90), ncol = 9)

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  dset2 <- createDataSet(group, "testmat_n2", testmat_n)
  submat <- matrix(-1L:-9L, nrow = 3)

  # TODO(mario) insert check before expand
  # f <- function() dset2[10:11, 9] <- matrix(rep(0, 2*9), nrow = 2)
  # expect_that(f(), throws_error("Number of objects in robj is not the same and not a multiple of number of elements selected in file"))
  #
  # f <- function() dset2[10, 9:10] <- matrix(rep(0, 2*9), ncol = 2)
  # expect_that(f(), throws_error("Number of objects in robj is not the same and not a multiple of number of elements selected in file"))
  #
  # f <- function() dset2[1, 1, 1] <- testmat_n
  # expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 3 vs. 2"))

  f <- function() dset2[ , , ] <- testmat_n
  expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 3 vs. 2"))

  # Write single element
  dset2[2, 2] <- -2L
  expect_that(dset2[2, 2], is_identical_to(-2L))

  dset2[,] <- dset1[,]
  expect_that(dset2[,], is_identical_to(dset1[,]))

  # Assign submatrix to DataSet
  f <- function()  dset2[c(1, 3, 5, 1), c(1, 3, 5)] <- submat
  expect_that(f(), throws_error("do not match the length of object"))

  dset2[c(1, 3, 5), c(1, 3, 5)] <- submat
  h5close(dset2)

  dset2 <- openLocation(group, "testmat_n2")
  testmat_n2 <- testmat_n
  testmat_n2[c(1, 3, 5), c(1, 3, 5)] <- submat
  expect_that(readDataSet(dset2), is_identical_to(testmat_n2))

  dset3 <- createDataSet(group, "testmat_n3", testmat_n)
  dset3[1:2, ] <- matrix(rep(1L, 18), nrow = 2)

  dset4 <- createDataSet(group, "testmat_n4", testmat_n)
  dset4[, c(1, 3, 5)] <- matrix(rep(1L, 30), nrow = 10)

  h5close(dset4)
  h5close(dset3)
  h5close(dset1)
  h5close(dset2)
  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testmat_n")
  dset2 <- openLocation(group, "testmat_n2")
  dset3 <- openLocation(group, "testmat_n3")
  dset4 <- openLocation(group, "testmat_n4")

  # Read entire dataset
  expect_that(readDataSet(dset1), is_identical_to(testmat_n))

  # TODO(mario): Reading entire dataset using [] for 2-dimensional objects
  # should also work, like in
  # matrix(1:9, nrow = 3)[]

  #expect_that(dset1[], is_identical_to(testmat_n))
  #expect_that(dset2[], is_identical_to(testmat_n2))
  expect_that(dset1[,], is_identical_to(testmat_n))
  expect_that(dset2[,], is_identical_to(testmat_n2))

  testmat_n3 <- testmat_n
  testmat_n3[1:2,] <- 1L
  expect_that(dset3[,], is_identical_to(testmat_n3))
  testmat_n4 <- testmat_n
  testmat_n4[,c(1, 3, 5)] <- 1L
  expect_that(dset4[,], is_identical_to(testmat_n4))

  h5close(dset4)
  h5close(dset3)
  h5close(dset2)
  h5close(dset1)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-array-read",{
  testmat_n <- array(as.integer(1:90), dim = c(3, 3, 10))
  subarray <- array(as.integer(-100:-120), dim = c(2, 2, 5))

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  h5close(dset1)
  dset2 <- createDataSet(group, "testmat_n2", testmat_n)

  f <- function() dset2[3:4, 3, 10]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 1"))

  f <- function() dset2[3, 3:4, 10]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 2"))

  f <- function() dset2[3, 3, 10:11]
  expect_that(f(), throws_error("The following coordinates are outside the dataset dimensions: 3"))

  f <- function() dset2[1, 1, 1, 1]
  expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 4 vs. 3"))

  # TODO: This should generate an ERROR!
  #f <- function() dset2[ , , , ]
  #expect_that(f(), throws_error("incorrect number of dimensions"))

  dset2[2:3, 2:3, 3:7] <- subarray

  h5close(dset2)
  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testmat_n")

  # Read entire dataset
  expect_that(readDataSet(dset1), is_identical_to(testmat_n))
  expect_that(dset1[,,], is_identical_to(testmat_n))
  expect_that(dset1[,,], is_identical_to(testmat_n))

  # Read columns / rows
  # TODO: drop should also be implemented
  expect_that(dset1[2,,, drop = FALSE], is_identical_to(testmat_n[2,,, drop = FALSE]))
  expect_that(dset1[2:3,,, drop = FALSE ], is_identical_to(testmat_n[2:3,,, drop = FALSE]))
  expect_that(dset1[,2,, drop = FALSE], is_identical_to(testmat_n[, 2,, drop = FALSE]))
  expect_that(dset1[, 2:3,, drop = FALSE], is_identical_to(testmat_n[, 2:3,, drop = FALSE]))
  expect_that(dset1[,,2, drop = FALSE], is_identical_to(testmat_n[,,2, drop = FALSE]))
  expect_that(dset1[,,2:4, drop = FALSE], is_identical_to(testmat_n[,,2:4, drop = FALSE]))

  testmat_n_read_all <- dset1[1:3, 1:3, 1:10]
  expect_that(testmat_n_read_all, is_identical_to(testmat_n))

  testmat_n_read_2 <- c(dset1[1, 2, 3], dset1[2, 3, 10])
  expect_that(testmat_n_read_2, is_identical_to(c(testmat_n[1, 2, 3], testmat_n[2, 3, 10])))

  dset2 <- openLocation(group, "testmat_n2")
  testmat_n2_read_all <- dset2[,,]
  testmat_n2 <- testmat_n
  testmat_n2[2:3, 2:3, 3:7] <- subarray
  expect_that(testmat_n2_read_all, is_identical_to(testmat_n2))

  h5close(dset2)
  h5close(dset1)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-Select-Subset-array-write",{
  testmat_n <- array(as.integer(1:90), dim = c(3, 3, 10))
  subarray <- array(as.integer(-100:-120), dim = c(2, 2, 5))

  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  dset1 <- createDataSet(group, "testmat_n", testmat_n)
  dset2 <- createDataSet(group, "testmat_n2", testmat_n)

  # TODO(mario): Expand should throw an error
  # f <- function() dset2[4, 3, 10] <- array(1:3, dim = c(1, 1, 1))
  # expect_that(f(), throws_error("subscript out of bounds"))
  # f <- function() dset2[3, 4, 10] <- array(1:3, dim = c(1, 1, 1))
  # expect_that(f(), throws_error("subscript out of bounds"))
  #
  # f <- function() dset2[3, 3, 11] <- array(1:3, dim = c(1, 1, 1))
  # expect_that(f(), throws_error("subscript out of bounds"))

  f <- function() dset2[1, 1, 1, 1] <- testmat_n
  expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 4 vs. 3"))

  f <- function() dset2[,,,] <- testmat_n
  expect_that(f(), throws_error("Number of arguments not equal to number of dimensions: 4 vs. 3"))

  # Write single element
  dset2[2, 2, 2] <- -2L
  expect_that(dset2[2, 2, 2], is_identical_to(-2L))

  dset2[,,] <- dset1[,,]
  expect_that(dset2[,,], is_identical_to(dset1[,,]))

  # TODO: this should actually work!
  #dset2[] <- dset1[]
  #expect_that(dset2[], is_identical_to(dset1[]))

  # Assign submatrix to DataSet
  f <- function()  dset2[2:3, 2:3, 1:6] <- subarray
  expect_that(f(), throws_error("Number of objects in robj is not the same and not a multiple of number of elements selected in file"))

  dset2[2:3, 2:3, 1:5] <- subarray
  h5close(dset2)

  dset2 <- openLocation(group, "testmat_n2")
  testmat_n2 <- testmat_n
  testmat_n2[2:3, 2:3, 1:5] <- subarray
  expect_that(readDataSet(dset2), is_identical_to(testmat_n2))

  # TODO: this should actually work
  # dset3[1, 1:2, ]

  dset3 <- createDataSet(group, "testmat_n3", testmat_n)
  dset3[, 1:2, 1:3] <- array(rep(1L, 18), dim = c(3, 2, 3))

  dset4 <- createDataSet(group, "testmat_n4", testmat_n)
  dset4[1:2,,1:3] <- array(rep(1L, 18), dim = c(3, 2, 3))

  h5close(dset4)
  h5close(dset3)
  h5close(dset1)
  h5close(dset2)
  h5close(group)
  h5close(file)

  file <- h5file(fname, "r")
  group <- openLocation(file, "/testgroup")
  dset1 <- openLocation(group, "testmat_n")
  dset2 <- openLocation(group, "testmat_n2")
  dset3 <- openLocation(group, "testmat_n3")
  dset4 <- openLocation(group, "testmat_n4")

  # Read entire dataset
  expect_that(readDataSet(dset1), is_identical_to(testmat_n))
  expect_that(dset1[,,], is_identical_to(testmat_n))
  expect_that(dset2[,,], is_identical_to(testmat_n2))
  testmat_n3 <- testmat_n
  testmat_n3[, 1:2, 1:3] <- 1L
  expect_that(dset3[,,], is_identical_to(testmat_n3))
  testmat_n4 <- testmat_n
  testmat_n4[1:2,,1:3] <- 1L
  expect_that(dset4[,,], is_identical_to(testmat_n4))

  h5close(dset4)
  h5close(dset3)
  h5close(dset2)
  h5close(dset1)
  h5close(group)
  h5close(file)
  expect_true(file.remove(fname))
})



---
File: /tests/testthat/test-zzz-DataSet.R
---

context("h5-DataSet-createDataset")

fname <- tempfile(fileext=".h5")

test_that("DataSet-createDataset",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  f <- function() dset1 <- createDataSet(file, "testmat_n")
  expect_that(f(), throws_error("If a sample robj is not provided, then dtype has to be given"))

  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-createDataset-chunksize",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  f <- function() dset1 <- createDataSet(file, "testmat_n", 1:10, chunk_dims = "test")
  expect_that(f(), throws_error("In RToH5_INTEGER can't convert type of object passed"))

  dset_c9 <- createDataSet(file, "test_chunk_9", 1:10, chunk_dims = 9)
  h5close(dset_c9)

  dset_c1 <- createDataSet(file, "test_chunk_1", 1:10, chunk_dims = 1)
  h5close(dset_c1)

  f <- function() dset_c0 <- createDataSet(file, "test_chunk_0", 1:10, chunk_dims = 0)
  expect_that(f(), throws_error("all chunk dimensions must be positive"))

  # TODO (mario): Create dataset without chunking?
  # ds_nochunk <- createDataSet(file, "dset", 1:3, chunk_dims = NA)
  # expect_that(ds_nochunk@chunksize, is_identical_to(NA_real_))
  # expect_that(ds_nochunk@maxdim, is_identical_to(3))
  # expect_that(ds_nochunk@compression, is_identical_to(character(0)))
  # h5close(ds_nochunk)

  # TODO (mario): Get Chunk size from dataset
  # ds_chunk <- createDataSet(file, name = "dset2", robj = 1:3)
  # expect_that(ds_chunk@chunksize, is_identical_to(3))
  # expect_that(ds_chunk@maxdim, is_more_than(1e+19))
  # expect_that(ds_chunk@compression , is_identical_to("H5Z_FILTER_DEFLATE"))
  # expect_that(ds_chunk@datatype, is_identical_to("i"))
  # h5close(ds_chunk)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-createDataset-maxdimensions",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  # TODO(mario): H5S$new(maxdims = "test") should immediately throw error
  dspace <- H5S$new(maxdims = "test")
  #f <- function() dset1 <- createDataSet(file, "testmat_n", 1:10, chunk_dims = "test", space = dspace)
  #expect_that(f(), throws_error("Parameter maxdimensions must be of type integer"))

  f <- function() dspace2 <- H5S$new(dims = c(10), maxdims = c(Inf, Inf))
  expect_that(f(), throws_error("maxdims, if it is not NULL, has to be of the same length as dims"))

  f <- function() dspace2 <- H5S$new(dims = c(10), maxdims = c(9))
  expect_that(f(), throws_error("maxdims is smaller than dims"))

  dspace2 <- H5S$new(dims = c(10), maxdims = c(10))
  dset_md_10 <- createDataSet(file, "test_md_10", 1:10, space = dspace2)
  h5close(dset_md_10)

  testmat <- matrix(rep(1:10, 10), nrow = 10)

  f <- function() dspace2 <- H5S$new(dims = c(10, 10), maxdims = c(9, 10))
  expect_that(f(), throws_error("maxdims is smaller than dims"))

  dspace2 <- H5S$new(dims = c(10, 10), maxdims = c(10, 10))
  dset_md_10_10 <- createDataSet(file, "test_md_10_10", testmat, space = dspace2)
  h5close(dset_md_10_10)

  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-createDataset-compression",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  f <- function() dset_cp_type <- createDataSet(file, "cp_type_n", 1:10, gzip = "test")
  expect_that(f(), throws_error("gzip_level has to be between 0 and 9"))

  f <- function() dset_cp_-1 <- createDataSet(file, "cp_-1", 1:10, gzip = -1)
  expect_that(f(), throws_error("gzip_level has to be between 0 and 9"))

  f <- function() dset_cp_10 <- createDataSet(file, "cp_10", 1:10, gzip = 10)
  expect_that(f(), throws_error("gzip_level has to be between 0 and 9"))

  for(i in 0:9) {
    dset <- createDataSet(file, sprintf("cp_%d", i), 1:10, gzip = i)
    h5close(dset)
  }

  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-list-dataset",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  f <- function() list.datasets(file, path = "path doesn't exist")
  expect_that(f(), throws_error("An object with name path doesn't exist does not exist in this group"))

  expect_that(list.datasets(file), is_identical_to(character(0)))

  group <- createGroup(file, "testgroup")
  group[["testset"]] <- 1:3
  expect_that(list.datasets(file), is_identical_to(c("testgroup/testset")))

  # TODO: Fix Bug implicit group extract/create
  #expect_that(list.datasets(file["/testgroup"], recursive = FALSE),
  #    is_identical_to(c("/testgroup/testset")))
  testgroup <- file[["/testgroup"]]
  expect_that(list.datasets(testgroup, recursive = FALSE),
      is_identical_to(c("testset")))
  h5close(testgroup)
  expect_that(list.datasets(file), is_identical_to(c("testgroup/testset")))

  g1 <- createGroup(file, "testgroup/testgroup1")
  file[["testgroup/testgroup1/testset1"]] <- 1:3

  g2 <- createGroup(file, "testgroup/testgroup2")
  file[["testgroup/testgroup2/testset2"]] <- 1:3

  g3 <- createGroup(file, "testgroup3")
  createGroup(file, "testgroup3/testgroup3")
  file[["testgroup3/testgroup3/testset3"]] <- 1:3

  group <- createGroup(file, "testgroupN")
  h5close(group)

  ex <- c("testgroup/testgroup1/testset1", "testgroup/testgroup2/testset2",
          "testgroup/testset", "testgroup3/testgroup3/testset3")
  expect_that(list.datasets(file), is_identical_to(ex))

  #ex <- c("testset1", "testset2", "testset", "testset3")
  #expect_that(list.datasets(file), is_identical_to(ex))

  ex <- c("testgroup1/testset1", "testgroup2/testset2",
          "testset")
  testgroup <- file[["testgroup"]]
  expect_that(list.datasets(testgroup), is_identical_to(ex))
  h5close(testgroup)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-list-dataset",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  abc <- createGroup(file, "ABC")

  file[["ABC/1A"]] <- 1:3
  file[["ABC/1B"]] <- 1:3
  file[["ABC/1C"]] <- 1:3
  file[["ABC/1D"]] <- 1:3
  file[["ABC/1E"]] <- 1:3
  file[["ABC/1F"]] <- 1:3

  ex <- c("ABC/1A", "ABC/1B", "ABC/1C", "ABC/1D", "ABC/1E", "ABC/1F")
  expect_that(list.datasets(file), is_identical_to(ex))

  expect_that(list.datasets(file, recursive = FALSE), is_identical_to(character(0)))

  h5close(file)
  expect_true(file.remove(fname))

})

test_that("DataSet-list-dataset-link",{
  fname <- system.file("test-h5link.h5", package = "hdf5r", mustWork = TRUE)
  file <- h5file(fname, "r")

  # TODO(mario): check why H5T_STD_I64LE is not mapped to 64bit integer
  expect_that(file[["hardlink/test2"]][], is_identical_to(1:3))
  expect_that(file[["softlink/test3/test"]][], is_identical_to(1:3))

  expect_that(list.datasets(file[["softlink"]]), is_identical_to(character(0)))

  # TODO(mario): Implement follow.link
  # exp1 <- c("softlink/test3/subgroup/test-sub", "softlink/test3/test")
  # expect_that(list.datasets(file[["softlink"]], follow.link = TRUE), is_identical_to(exp1))

  exp2 <- c("hardlink/test2", "testgroup/subgroup/test-sub", "testgroup/test")
  expect_that(list.datasets(file), is_identical_to(exp2))

  #exp3 <- "softlink/test3/test"
  expect_that(list.datasets(file[["softlink/test3"]], recursive = FALSE), is_identical_to("test"))

  h5close(file)
})

test_that("DataSet-Bug-F32-Issue10",{
  fname <- system.file("test-f32.h5", package = "hdf5r", mustWork = TRUE)
  file <- h5file(fname, "r")
  expect_that(file[["floats"]][], is_identical_to(c(1, 2, 3)))
  h5close(file)
})




---
File: /tests/testthat/test-zzz-enum.R
---

# TODO(mario): Check why enum test case ist not working (test-zzz.enum.R)
# context("h5-DataSet-Enum")
# 
# test_that("DataSet-Enum-Matrix-open", {
#     # Use the sample file for the enum datatype from the HDF Group itself,
#     # see also https://www.hdfgroup.org/ftp/HDF5/examples/files/exbyapi
#     fname <- system.file("h5ex_t_enum.h5", package = "hdf5r", mustWork = TRUE)
#     datafile <- h5file(fname, "r")
#     dataset <- datafile[["DS1"]][]
#     expect_that(is.factor(dataset), is_true())
#     expect_that(levels(dataset), equals(c("SOLID", "LIQUID", "GAS", "PLASMA")))
#     h5close(datafile)
# })
# 



---
File: /tests/testthat/test-zzz-H5File-Subset.R
---

context("h5-H5File-Subset")
fname <- tempfile(fileext=".h5")

test_that("H5File-Subset-Group",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  f <- function() file[[c("1", "2", "3")]]
  expect_that(f(), throws_error("An object with name 1 does not exist in this group"))

  group3 <- createGroup(file, "/testgroup3")
  expect_that(group3, is_a("H5Group"))
  expect_that(group3$get_obj_name(), is_identical_to("/testgroup3"))

  groupnested <- createGroup(group3, "test")
  expect_that(groupnested, is_a("H5Group"))
  expect_that(groupnested$get_obj_name(), is_identical_to("/testgroup3/test"))
  h5close(groupnested)
  h5close(group3)

  group3 <- file[["/testgroup3"]]
  grouprelative <- group3[["test"]]
  expect_that(grouprelative, is_a("H5Group"))
  expect_that(grouprelative$get_obj_name(), is_identical_to("/testgroup3/test"))
  h5close(grouprelative)
  h5close(group3)

  # TODO(mario): recursive group creation
  # group5 <- file["/test1/test2/test3/test4/test5"]


  # expect_that(group5, is_a("H5Group"))
  # expect_that(group5@location, is_identical_to("/test1/test2/test3/test4/test5"))
  # h5close(group5)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("H5File-Subset-DataSet",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  # TODO(mario): Implicit, recursive group creation?
  # group5 <- file["/test1/test2/test3/test4/test5"]

  g1 <- createGroup(file, "test/test1/test2/test3")
  g1[["dset1"]] <- 1:10
  g1[["dset2"]] <- matrix(1:9, nrow = 3)
  g1[["dset3"]] <- array(1:6, dim = c(1, 2, 3))
  file[["dset4"]] <- matrix(1:10, nrow = 5)

  # TODO: should work without h5close()
  h5close(g1)
  h5close(file)

  file <- h5file(fname, "r")
  dset <- file[["test/test1/test2/test3/dset1"]]
  expect_that(readDataSet(dset), is_identical_to(1:10))
  h5close(dset)

  dset <- file[["test/test1/test2/test3/dset2"]]
  expect_that(readDataSet(dset), is_identical_to(matrix(1:9, nrow = 3)))
  h5close(dset)

  # TODO(mario): Does array retrieval work?
  # dset <- file[["test/test1/test2/test3/dset3"]]
  # expect_that(readDataSet(dset), is_identical_to(array(1:6, dim = c(1, 2, 3))))
  # h5close(dset)

  dset <- file[["dset4"]]
  expect_that(readDataSet(dset), is_identical_to(matrix(1:10, nrow = 5)))
  h5close(dset)

  # check subsets
  # TODO: should work without h5close()
  dset <- file[["test/test1/test2/test3/dset1"]]
  expect_that(dset[1:5], is_identical_to(1:5))
  h5close(dset)

  dset <- file[["test/test1/test2/test3/dset2"]]
  expect_that(dset[1:2,], is_identical_to(matrix(1:9, nrow = 3)[1:2,]))
  h5close(dset)

  # TODO(mario): Does array retrieval work?
  # dset <- file[["test/test1/test2/test3/dset3"]]
  # expect_that(dset[1,1:2,3],
  #     is_identical_to(array(1:6, dim = c(1, 2, 3))[1,1:2,3,drop = FALSE]))
  # h5close(dset)

  # set subsets
  # TODO: include test cases
  h5close(file)
  expect_true(file.remove(fname))
})




---
File: /tests/testthat/test-zzz-H5File.R
---

context("h5-H5File")
fname <- tempfile(fileext=".h5")

test_that("H5File-param",{
	f <- function() file <- h5file(1, "a")
	expect_that(f(), throws_error("is.character\\(name\\) is not TRUE"))

	f <- function() file <- h5file(c("a", "a"), "a")
	expect_that(f(), throws_error("length\\(name\\) == 1 is not TRUE"))

	f <- function() file <- h5file("a", 1)
  expect_that(f(), throws_error("'arg' must be NULL or a character vector"))

	f <- function() file <- h5file("a", c("a", "a"))
	expect_that(f(), throws_error("'arg' must be of length 1"))

	f <- function() file <- h5file("a", c("a", "a"))
  expect_that(f(), throws_error("'arg' must be of length 1"))

	f <- function() file <- h5file("path", "w--")
	expect_that(f(), throws_error("'arg' should be one of.*"))
})

test_that("H5File-FileMode-param-a",{
	if(file.exists(fname)) file.remove(fname)
	file <- h5file(fname)
	expect_that(file, is_a("H5File"))
	# TODO: add mode to file
	#expect_that(file$mode, is_identical_to("a"))
	expect_that(normalizePath(file$get_filename(), mustWork=FALSE), is_identical_to(normalizePath(fname, mustWork=FALSE)))
	group1 <- createGroup(file, "testgroup")
	expect_that(group1, is_a("H5Group"))
	h5close(group1)
	h5close(file)

	# Open existing file for append
	expect_true(file.exists(fname))
	file <- h5file(fname, "a")
	expect_that(file, is_a("H5File"))
	expect_true(existsGroup(file, "testgroup"))
	group2 <- createGroup(file, "testgroup2")
	h5close(group2)
	h5close(file)
})

test_that("H5File-FileMode-param-w-",{
	expect_true(file.exists(fname))
	f <- function() file <- h5file(fname, "w-")
	expect_that(f(), throws_error("Unable to open file"))
	expect_true(file.remove(fname))

	file <- h5file(fname, "w-")
	expect_that(file$mode, is_identical_to("w-"))
	expect_that(normalizePath(file$filename, mustWork=FALSE), is_identical_to(normalizePath(fname, mustWork=FALSE)))
	group1 <- createGroup(file, "testgroup1")
	expect_true(existsGroup(file, "testgroup1"))
	h5close(group1)
	h5close(file)
})

test_that("H5File-FileMode-param-w",{
  expect_true(file.exists(fname))
  # Seems HDF5 since 1.8.15 does not detect that file does exist but is already
  # closed, see also https://www.hdfgroup.org/HDF5/doc/RM/RM_H5F.html
  # We therefore need to delete file
  expect_true(file.remove(fname))

  file <- h5file(fname, "w")
  expect_that(file$mode, is_identical_to("w"))
  expect_that(normalizePath(file$filename, mustWork=FALSE), is_identical_to(normalizePath(fname, mustWork=FALSE)))
  expect_false(existsGroup(file, "testgroup1"))
  group2 <- createGroup(file, "testgroup1")
  h5close(group2)
  h5close(file)

  expect_true(file.exists(fname))
  # See above
  expect_true(file.remove(fname))

  file <- h5file(fname, "w")
  expect_that(file$mode, is_identical_to("w"))
  expect_that(normalizePath(file$filename, mustWork=FALSE), is_identical_to(normalizePath(fname, mustWork=FALSE)))
  expect_false(existsGroup(file, "testgroup1"))
  h5close(file)

})

test_that("H5File-FileMode-param-r",{
	expect_true(file.exists(fname))
  file <- h5file(fname, "r")
  expect_that(file$mode, is_identical_to("r"))

  # TODO(mario): Check why for osx we have
  # > file$filename
  # [1] "/private/var/folders/q3/0dypvmy96jv26m3qk49pp85r0000gn/T/Rtmpl0x2xf/fileb2287a7a7b98.h5"
  # > fname
  # [1] "/var/folders/q3/0dypvmy96jv26m3qk49pp85r0000gn/T//Rtmpl0x2xf/fileb2287a7a7b98.h5"

  expect_that(normalizePath(file$filename, mustWork=FALSE), is_identical_to(normalizePath(fname, mustWork=FALSE)))
  h5close(file)

  expect_true(file.remove(fname))
  f <- function() file <- h5file(fname, "r")
  expect_that(f(), throws_error("Unable to open file"))
})

test_that("H5File-FileMode-param-r+",{
  if(file.exists(fname)) file.remove(fname)
  f <- function() file <- h5file(fname, "r+")
  expect_that(f(), throws_error("Unable to open file"))

  file <- h5file(fname, "a")
  group1 <- createGroup(file, "testgroup")
  expect_that(group1, is_a("H5Group"))
  h5close(group1)
  h5close(file)

  file <- h5file(fname, "r+")
  expect_true(existsGroup(file, "testgroup"))
  expect_that(group1, is_a("H5Group"))
  h5close(group1)
  h5close(file)
  expect_true(file.remove(fname))
})


test_that("H5File-show",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)
  group1 <- createGroup(file, "testgroup")
  group2 <- createGroup(file, "testgroup2")
  group3 <- createGroup(group2, "testgroup3")
  h5close(group1)
  h5close(group2)
  h5close(group3)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("H5File-is-h5file",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)
  group1 <- createGroup(file, "testgroup")
  h5close(group1)
  h5close(file)

  expect_true(is.h5file(fname))
  expect_warning(expect_false(is.h5file("abc")))
  fnametxt <- "test.txt"
  writeLines("abc", fnametxt)
  expect_false(is.h5file(fnametxt))
  expect_true(file.remove(fname))
  expect_true(file.remove(fnametxt))
})

test_that("H5File-flush",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)
  group1 <- createGroup(file, "testgroup")
  ds <- createDataSet(group1, "testset", 1:100)
  h5flush(file)
  h5close(file)
})




---
File: /tests/testthat/test-zzz-H5Group.R
---

context("h5-H5Group")
fname <- tempfile(fileext=".h5")

test_that("H5Group-param",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)

  group1 <- createGroup(file, "//testgroup")
  expect_that(group1, is_a("H5Group"))
  h5close(group1)

  group2 <- createGroup(file, "testgroup2//")
  expect_that(group2, is_a("H5Group"))
  h5close(group2)

  # Does not need to throw an error
  # f <- function() grouproot <- createGroup(file, "/")
  # expect_that(f(), throws_error("H5Gcreate failed"))

  # Test very long groupname
  gname <- paste(rep(LETTERS, 1000), collapse = "")
  groupn <- createGroup(file, gname)
  expect_that(group1, is_a("H5Group"))
  h5close(groupn)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("H5Group-createGroup",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname)

  # Not Fail for nested (non-existent) group name
  # f <- function() group1 <- createGroup(file, "/testgroup/test")
  # expect_that(f(), throws_error("H5Gcreate failed"))

  group3 <- createGroup(file, "/testgroup3")
  expect_that(group3, is_a("H5Group"))
  expect_that(group3$get_obj_name(), is_identical_to("/testgroup3"))

  groupnested <- createGroup(group3, "/test")
  expect_that(groupnested, is_a("H5Group"))
  expect_that(groupnested$get_obj_name(), is_identical_to("/testgroup3/test"))
  h5close(groupnested)
  h5close(group3)
  h5close(file)
})

test_that("H5Group-openLocation",{
  expect_true(file.exists(fname))
  file <- h5file(fname, "r")
  # Fail for nested (non-existent) group name
  f <- function() group1 <- openLocation(file, "/testgroup/test")
  expect_that(f(), throws_error()) # error message varies between versions

  group3 <- openLocation(file, "/testgroup3")
  expect_that(group3, is_a("H5Group"))
  expect_that(group3$get_obj_name(), is_identical_to("/testgroup3"))

  groupnested <- openLocation(group3, "test")
  expect_that(groupnested, is_a("H5Group"))
  expect_that(groupnested$get_obj_name(), is_identical_to("/testgroup3/test"))
  h5close(groupnested)
  h5close(group3)

  group3 <- openLocation(file, "/testgroup3")
  grouprelative <- openLocation(group3, "test")
  expect_that(grouprelative, is_a("H5Group"))
  expect_that(grouprelative$get_obj_name(), is_identical_to("/testgroup3/test"))
  # TODO: should absolute path be displayed?
  # eg. expect_that(grouprelative@name, is_identical_to("/testgroup3/test"))

  h5close(grouprelative)
  h5close(group3)
  h5close(file)
})

test_that("H5Group-openGroup",{
  expect_true(file.exists(fname))
  file <- h5file(fname, "r")
  # Fail for nested (non-existent) group name
  f <- function() group1 <- openGroup(file, "/testgroup/test")
  expect_that(f(), throws_error()) # specific message check removed as message varies
  
  group3 <- openGroup(file, "/testgroup3")
  expect_that(group3, is_a("H5Group"))
  expect_that(group3$get_obj_name(), is_identical_to("/testgroup3"))
  
  groupnested <- openGroup(group3, "test")
  expect_that(groupnested, is_a("H5Group"))
  expect_that(groupnested$get_obj_name(), is_identical_to("/testgroup3/test"))
  h5close(groupnested)
  h5close(group3)
  
  group3 <- openGroup(file, "/testgroup3")
  grouprelative <- openGroup(group3, "test")
  expect_that(grouprelative, is_a("H5Group"))
  expect_that(grouprelative$get_obj_name(), is_identical_to("/testgroup3/test"))
  # TODO: should absolute path be displayed?
  # eg. expect_that(grouprelative@name, is_identical_to("/testgroup3/test"))
  
  h5close(grouprelative)
  h5close(group3)
  h5close(file)
})

test_that("H5Group-existsGroup",{
  expect_true(file.exists(fname))
  file <- h5file(fname, "r")
  # Fail for nested (non-existent) group name
  expect_false(existsGroup(file, "/testgroup/test"))
  expect_true(existsGroup(file, "/testgroup3"))
  expect_true(existsGroup(file, "/testgroup3/test"))

  group3 <- openLocation(file, "/testgroup3")
  expect_true(existsGroup(group3, "test"))
  h5close(group3)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("CommonFG-list-groups",{
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")

  # TODO(mario): Adjust error message if object[[path]] is nonexistent
  f <- function() list.groups(file, path = "a/be/bu")
  expect_that(f(), throws_error()) # specific error message removed as message varies
  expect_that(list.groups(file), is_identical_to(character(0)))

  g1 <- createGroup(file, "testgroup")
  g1[["testset"]] <- 1:3
  expect_that(list.groups(file), is_identical_to(c("testgroup")))
  expect_that(list.groups(file, recursive = FALSE), is_identical_to(c("testgroup")))
  expect_that(list.groups(file), is_identical_to(c("testgroup")))

  g11 <- createGroup(g1, "testgroup1")
  g12 <- createGroup(g1, "testgroup2")
  g13 <- createGroup(g1, "testgroup3")

  g11[["testset1"]] <- 1:3
  g12[["testset2"]] <- 1:3
  g13[["testset3"]] <- 1:3
  h5close(g1)

  group <- createGroup(file, "testgroupN")
  h5close(group)

  ex <- c("testgroup", "testgroup/testgroup1", "testgroup/testgroup2",
 	"testgroup/testgroup3", "testgroupN")
  expect_that(list.groups(file), is_identical_to(ex))

  ex <- c("testgroup", "testgroup1", "testgroup2", "testgroup3", "testgroupN")
  expect_that(basename(list.groups(file)), is_identical_to(ex))

  ex <- c("testgroup", "testgroupN")
  expect_that(list.groups(file, recursive = FALSE), is_identical_to(ex))

  ex <- c("testgroup1", "testgroup2", "testgroup3")
  testgroup <- file[["testgroup"]]
  expect_that(list.groups(file[["testgroup"]], full.names = TRUE), is_identical_to(paste0("/testgroup/", ex)))
  expect_that(list.groups(testgroup), is_identical_to(ex))
  h5close(testgroup)

  h5close(file)
  expect_true(file.remove(fname))
})

test_that("CommonFG-unlink",{
  if(file.exists(fname)) file.remove(fname)

  file <- h5file(fname)
  g1 <- createGroup(file, "testgroup")
  g2 <- createGroup(file, "testgroup2")
  g1[["testset"]] <- 1:3
  g1[["testset2"]] <- 1:3
  g2[["testset"]] <- 1:3

  h5close(file)

  file <- h5file(fname, "r+")

  # unlink group
  ex <- c("testgroup/testset",  "testgroup/testset2", "testgroup2/testset")
  expect_that(list.datasets(file, recursive = TRUE),
      is_identical_to(ex))

  # unlink dataset
  expect_true(h5unlink(file, "testgroup"))
  expect_true(h5unlink(file, "testgroup2/testset"))
  expect_that(list.datasets(file, recursive = TRUE),
      is_identical_to(character(0)))
  expect_that(list.groups(file, recursive = TRUE),
      is_identical_to("testgroup2"))

  # remove last group
  expect_true(h5unlink(file, "testgroup2"))
  expect_that(list.groups(file, recursive = TRUE),
      is_identical_to(character(0)))

  # remove non-existing
  # expect_that(h5unlink(file, "testgroup2"), is_false())
  # expect_that(h5unlink(file, "testgroup2/testset"), is_false())

  # add data sets again
  g1 <- createGroup(file, "testgroup")
  g2 <- createGroup(file, "testgroup2")
  g1[["testset"]] <- 5:6
  g1[["testset2"]] <- 5:6
  g2[["testset"]] <- 5:6
  h5close(file)

  file <- h5file(fname, "a")

  # TODO(mario): check why this still leaves an open file handle
  expect_that(file[["testgroup/testset"]][], is_identical_to(5:6))
  expect_that(file[["testgroup/testset2"]][], is_identical_to(5:6))
  expect_that(file[["testgroup2/testset"]][], is_identical_to(5:6))

  testset <- file[["testgroup/testset"]]
  expect_that(testset[], is_identical_to(5:6))
  h5close(testset)
  testset2 <- file[["testgroup/testset2"]]
  expect_that(testset2[], is_identical_to(5:6))
  h5close(testset2)
  testset3 <- file[["testgroup2/testset"]]
  expect_that(testset3[], is_identical_to(5:6))
  h5close(testset3)

  # remove multiple datasets, 1 missing
  # TODO: check if file is read-only mode
  res <- h5unlink(file, c("testgroup/testset", "testgroup/testset2",
          "testgroup2/testset", "testgroup2/missing"))
  names(res) <- NULL
  expect_that(res, is_identical_to(c(TRUE, TRUE, TRUE, FALSE)))
  h5close(file)

  expect_true(file.remove(fname))
})



---
File: /tests/testthat/test-zzz-io.R
---

context("h5-datatypes-IO")

test_that("datatypes-IO",{
	
	testmat <- matrix(rnorm(120), ncol = 3)
	fname <- tempfile(fileext=".h5")
	if(file.exists(fname)) file.remove(fname)
	dsetname <- c("testmat1", "testmat2")
	
	file <- h5file(fname, "a")
	group <- createGroup(file, "/testgroup")
	dset <- createDataSet(group, dsetname[1], testmat)
	h5close(dset)
	h5close(group)
	h5close(file)
	
	file <- h5file(fname, "r")
	group <- openLocation(file, "/testgroup")
	dset <- openLocation(group, dsetname[1])
	outmat <- readDataSet(dset)
	expect_that(testmat, is_identical_to(outmat))
	h5close(dset)
	h5close(group)
	h5close(file)
	
	file <- h5file(fname, "a")
	group2 <- createGroup(file, "/testgroup/testgroup2")
	dset2 <- createDataSet(group2, dsetname[2], testmat)
	outmat2 <- readDataSet(dset2)
	expect_that(testmat, is_identical_to(outmat2))
	h5close(dset2)
	h5close(group2)
	h5close(file)
	
	file2 <- h5file(fname, "r")
	group3 <- openLocation(file2, "/testgroup/testgroup2")
	dset3 <- openLocation(group3, dsetname[2]) 
	outmat3 <- readDataSet(dset3)
	expect_that(testmat, is_identical_to(outmat3))
	h5close(dset3)
	h5close(group3)
	h5close(file2)
	
  expect_true(file.remove(fname))
})




---
File: /tests/testthat/test-zzz-vlen.R
---

context("h5-DataSet-VLEN-Vector")

fname <- tempfile(fileext=".h5")

# test_that("DataSet-VLEN-Vector-create",{
#   if(file.exists(fname)) file.remove(fname)
#   file <- h5file(fname, "a")
#   group <- createGroup(file, "/testgroup")
#   
#   dset1 <- createDataSet(group, "testvec_n", type = "vlen-double", dimensions = 30L)
#   expect_that(dset1@datatype, is_identical_to("x"))
#   h5close(dset1)
#   
#   f <- function() createDataSet(group, "testvec_l", type = "vlen-logical", dimensions = 30L)
#   expect_that(f(), throws_error("Type 'vlen-logical' not supported yet"))
#   
#   dset3 <- createDataSet(group, "testvec_i", type = "vlen-integer", dimensions = 30L)
#   expect_that(dset3@datatype, is_identical_to("y"))
#   h5close(dset3)
#   
#   f <- function() createDataSet(group, "testvec_c", type = "vlen-character", dimensions = 30L)
#   expect_that(f(), throws_error("Type 'vlen-character' not supported yet"))
#   
#   f <- function() createDataSet(group, "testvec_c4", type = "vlen-character", dimensions = 30L, size = 9)
#   expect_that(f(), throws_error("Type 'vlen-character' not supported yet"))
# 
#   h5close(group)
#   h5close(file)
#  
#   expect_that(file.remove(fname), is_true())
# })

test_that("DataSet-VLEN-Vector",{
  if(file.exists(fname)) file.remove(fname)
  
  testvec_n <- rnorm(120)
  testvec_i <- as.integer(runif(120)*10000)
  testvec_l <- as.logical(round(runif(120)))
  testvec_c <-rep(paste0(LETTERS[1:3], rev(LETTERS)[1:3]), 120/3)
  testvec_c[1] <- paste0(testvec_c[1], testvec_c[1])
  testvec_c[40] <- paste0(testvec_c[1], testvec_c[1])
  
  testlist_n <- list(testvec_n[1:10], testvec_n[11:30], testvec_n[31:120])
  testlist_i <- list(testvec_i[1:10], testvec_i[11:30], testvec_i[31:120])
  testlist_l <- list(testvec_l[1:10], testvec_l[11:30], testvec_l[31:120])
  testlist_c <- list(testvec_c[1:10], testvec_c[11:30], testvec_c[31:120])
  
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  
  dset1 <- createDataSet(group, "testlist_n", testlist_n)
  h5close(dset1)
  
  dset2 <- createDataSet(group, "testlist_i", testlist_i)
  h5close(dset2)
  
  dset3 <- createDataSet(group, "testlist_l", testlist_l)
  h5close(dset3)
  
  dset4 <- createDataSet(group, "testlist_c", testlist_c)
  h5close(dset4)

  h5close(group)
  h5close(file)
  
  file <- h5file(fname, "a")
  testlist_n_in <- file[["/testgroup/testlist_n"]]
  expect_that(testlist_n_in[], is_identical_to(testlist_n))
  h5close(testlist_n_in)
  testlist_i_in <- file[["/testgroup/testlist_i"]] 
  expect_that(testlist_i_in[], is_identical_to(testlist_i))
  h5close(testlist_i_in)
  testlist_l_in <- file[["/testgroup/testlist_l"]] 
  expect_that(testlist_l_in[], is_identical_to(testlist_l))
  h5close(testlist_l_in)
  testlist_c_in <- file[["/testgroup/testlist_c"]] 
  expect_that(testlist_c_in[], is_identical_to(testlist_c))
  h5close(testlist_c_in)
  h5close(file)
  expect_true(file.remove(fname))
})

test_that("DataSet-VLEN-Vector-Attribute",{
  testvec_n <- rnorm(120)
  testvec_i <- as.integer(runif(120)*10000)
  testvec_l <- as.logical(round(runif(120)))
  testvec_c <-rep(paste0(LETTERS[1:3], rev(LETTERS)[1:3]), 120/3)
  testvec_c[1] <- paste0(testvec_c[1], testvec_c[1])
  testvec_c[40] <- paste0(testvec_c[1], testvec_c[1])
  
  testlist_n <- list(testvec_n[1:10], testvec_n[11:30], testvec_n[31:120])
  testlist_i <- list(testvec_i[1:10], testvec_i[11:30], testvec_i[31:120])
  testlist_l <- list(testvec_l[1:10], testvec_l[11:30], testvec_l[31:120])
  testlist_c <- list(testvec_c[1:10], testvec_c[11:30], testvec_c[31:120])
  
  if(file.exists(fname)) file.remove(fname)
  file <- h5file(fname, "a")
  group <- createGroup(file, "/testgroup")
  
  h5attr(group, "testlist_n") <- testlist_n
  h5attr(group, "testlist_i") <- testlist_i
  h5attr(group, "testlist_l") <- testlist_l
  h5attr(group, "testlist_c") <- testlist_c
 
  h5close(group)
  h5close(file)
  
  file <- h5file(fname, "a")
# TODO: check why this leaves open file handle
#  testlist_n_in <- h5attr(file["/testgroup"], "testlist_n") 
#  expect_that(testlist_n_in, is_identical_to(testlist_n))
#  testlist_i_in <- h5attr(file["/testgroup"], "testlist_i") 
#  expect_that(testlist_i_in[], is_identical_to(testlist_i))
  
  testgroup <- file[["/testgroup"]]
  testlist_n_in <- h5attr(testgroup, "testlist_n") 
  expect_that(testlist_n_in, is_identical_to(testlist_n))
  testlist_i_in <- h5attr(testgroup, "testlist_i") 
  expect_that(testlist_i_in[], is_identical_to(testlist_i))
  testlist_l_in <- h5attr(testgroup, "testlist_l") 
  expect_that(testlist_l_in[], is_identical_to(testlist_l))
  testlist_c_in <- h5attr(testgroup, "testlist_c") 
  expect_that(testlist_c_in[], is_identical_to(testlist_c))
  
  h5close(testgroup)
  h5close(file)
  expect_true(file.remove(fname))
})



---
File: /tests/testthat.R
---

library(testthat)
library(hdf5r)

test_check("hdf5r")




---
File: /tools/winlibs.R
---

# Build against rwinlib build of hdf5
VERSION <- commandArgs(TRUE)
if(!file.exists(sprintf("../windows/hdf5-%s/include/hdf5.h", VERSION))){
  download.file(sprintf("https://github.com/rwinlib/hdf5/archive/v%s.zip", VERSION),
                "lib.zip", quiet = TRUE)
  dir.create("../windows", showWarnings = FALSE)
  unzip("lib.zip", exdir = "../windows")
  unlink("lib.zip")
}



---
File: /vignettes/hdf5r.Rmd
---

---
title: "Introduction to the hdf5r package"
author: "Holger Hoefling"
date: April 17th 2016
abstract: >
  Overview on how to use the simple as well as advanced facilities of HDF5 using the **hdf5r** package
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
    number_sections: true
    keep_md: true
  pdf_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to the hdf5r package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8](inputenc)
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, eval=TRUE}
knitr::opts_chunk$set(fig.width=7, fig.height=7, tidy=TRUE, results="hold")
```






-----------------------------------------------------

# Introduction

> HDF5 is a data model, library, and file format for storing and managing data.
  It supports an unlimited variety of datatypes, and is designed for flexible and
  efficient I/O and for high volume and complex data.

As R is very often used to process large amounts of data, having a direct interface to HDF5 is very useful.
As of the writing of this vignette, there are 2 other packages available that also implement an interface to HDF5,
**h5** on CRAN and **rhdf5** on Bioconductor. These are also good implementations, but there are several points that
make this package here -- **hdf5r** -- stand out:

- User friendly interface that allows access to datasets in the same fashion a user would access regular R arrays
- All HDF5 classes are implemented using R6 classes, allowing for a very simple way of manipulating objects
- The library is almost feature complete, implementing most of the functionality of the HDF5 C-API. Some exceptions are for
  example functions that expect other C-functions as arguments.
- It ships with the newest version 1.10.0 of HDF5
- All HDF5 constants and datatypes are available under their regular name.
- All HDF5 functions that return constants do this in the format of an *extended-factor-variable*, giving the
  constants value as well as the name. Furthermore, all functions that in HDF5 return *C-structs*, return a data frame
  with the same variable names as in the structs (usually used by the various "-info" functions).
- Tracking and closing of unused HDF5 resources is done completely automatically using the R garbage collector.

In the following sections of this vignette, first a simple example will be given that shows how standard operations
are being performed. Next, more advanced features will be discussed such as the creation of complex datatypes,
datasets with special datatypes, the setting of the various available filters when reading/writing a package etc. We will
end with a technical overview on the underlying implementation.

------------------------------------------------------

# A simple example

As an introduction on how to use it, let us set up a very simple usage example. We will create a file, some groups in it as
well as datasets of different sizes. We will read and write data, delete datasets again, get information on various objects.

## Creating files, groups and datasets

But first things first. We create a random filename in a temporary directory and create a file with read/write access,
deleting it if it already exists (it won't - tempfile gives us a name of a file that doesn't exist yet).

```{r}
library(hdf5r)
test_filename <- tempfile(fileext=".h5")
file.h5 <- H5File$new(test_filename, mode="w")
file.h5
```
Now that we have this, we will create 2 groups, one for the **mtcars** dataset and one for the **nycflights13** dataset.
```{r}
mtcars.grp <- file.h5$create_group("mtcars")
flights.grp <- file.h5$create_group("flights")
```

Into these groups, we will now write the datasets
```{r}
library(datasets)
library(nycflights13)
library(reshape2)
mtcars.grp[["mtcars"]] <- datasets::mtcars
flights.grp[["weather"]] <- nycflights13::weather
flights.grp[["flights"]] <- nycflights13::flights
```

Out of the weather data, we extract the information on the wind-direction and wind-speed and will save it as a matrix
with the hours in the columns and the days in the rows (only for weather station *EWR*, the others are not complete).
```{r}
weather_wind_dir <- subset(nycflights13::weather, origin=="EWR", select=c("year", "month", "day", "hour", "wind_dir"))
weather_wind_dir <- na.exclude(weather_wind_dir)
weather_wind_dir$wind_dir <- as.integer(weather_wind_dir$wind_dir)
weather_wind_dir <- acast(weather_wind_dir, year + month + day ~ hour, value.var="wind_dir")
flights.grp[["wind_dir"]] <- weather_wind_dir
```
and
```{r}
weather_wind_speed <- subset(nycflights13::weather, origin=="EWR", select=c("year", "month", "day", "hour", "wind_speed"))
weather_wind_speed <- na.exclude(weather_wind_speed)
weather_wind_speed <- acast(weather_wind_speed, year + month + day ~ hour, value.var="wind_speed")
flights.grp[["wind_speed"]] <- weather_wind_speed
```
For completeness, we also attach the row and column names as attributes:
```{r}
h5attr(flights.grp[["wind_dir"]], "colnames") <- colnames(weather_wind_dir)
h5attr(flights.grp[["wind_dir"]], "rownames") <- rownames(weather_wind_dir)
h5attr(flights.grp[["wind_speed"]], "colnames") <- colnames(weather_wind_speed)
h5attr(flights.grp[["wind_speed"]], "rownames") <- rownames(weather_wind_speed)
```

## Getting information about different objects

### Content of files and groups

With respect to groups and files, we also want to have a simple way to extract the contents. With the **names** function,
we can get all names of objects in a group or in the root directory of a file
```{r, results="markup"}
names(file.h5)
names(flights.grp)
```
Another option that gives more information is **ls**, a method of the classes **H5File** and **H5Group**
```{r}
flights.grp$ls()
```

### Information on attributes, datatypes and datasets

If you have an HDF5-File, it is of course important to look up various information not only about groups, but also
about the information contained in it. First, we want to get more information about the dataset. **ls** on the group
already gives a lot of information about the datatype, the size, the maximum size etc. However there are also other, more direct,
ways to get the same information. In order to investigate the datatype we can
```{r, results="markup"}
weather_ds <- flights.grp[["weather"]]
weather_ds_type <- weather_ds$get_type()
weather_ds_type$get_class()
cat(weather_ds_type$to_text())
```
telling us that our dataset consists of a *H5T_COMPOUND* datatype and prints more detailed information on its content of
every column. Regarding the size of the dataset and the size of the chunks (datasets are by default chunked; more about this below) we do:
```{r}
weather_ds$dims
weather_ds$maxdims
weather_ds$chunk_dims
```

In order to get information on attributes we also have various function available. Which attributes are attached to an object we can see with
```{r}
h5attr_names(flights.grp[["wind_dir"]])
```
and the content of one attribute can be extracted with **h5attr**, the content of all of them with a list as **h5attributes**.
```{r}
h5attr(flights.grp[["wind_dir"]], "colnames")
```

### Detailed information about various objects

In HDF5, there are also various ways of getting more detailed information about objects. The most detailed methods for this are

- **get_obj_info:** Various information on the number of attributes, the type of the object, the reference count, access times
  (if set to be recorded) and other more technical information
- **get_link_info:** For links, mainly yields information on the link type, i.e. hard link or soft link. The difference between them and
  how to create them will be discussed further below.
- **get_group_info:** Information about the storage type of the group, if a file is mounted to the group and the number of items
  in the group. For the casual user, the most interesting information is the number of items in the group, which can also be retrieved
  using the **names** function. For very large groups, this way is however more efficient.
- **get_file_name:** For an *H5File* or *H5Group*, *H5D* or *H5T* (where D is for dataset and T stands for a committed type)
   object, returns the name of the file it is in.
- **get_obj_name:** Similar as *get_file_name*, applies to the same object, but returns the path **inside** the file to the object
- **file_info:** It extracts relatively technical information about a file. It can only be applied to an object of
  class **H5File**. This function is usually not of interest to the casual user

Most of these are somewhat advanced. They key information can usually also be extracted with one of the "higher-level" methods shown
above, but sometimes the *info* methods are more efficient.


## Assigning data into datasets and deleting datasets

Of course we also want to to be able to read out data, change it, extend the dataset and
also delete it again. Reading out the data works just as it does for regular R arrays and data frames. However,
HDF5-tables only have one dimension, not two. It is currently not possible to selectively read columns - all of them have to be
read at the same time. For arrays, any data point can be read on its without restrictions

```{r, results="markup"}
weather_ds[1:5]
wind_dir_ds <- flights.grp[["wind_dir"]]
wind_dir_ds[1:3,]
```

Let us replace one row. Currently, vector-recycling is not enabled, so you have to ensure that your replacements have the correct size.
Recycling may be enabled in the future.
```{r}
wind_dir_ds[1,] <- rep(1, 24)
wind_dir_ds[1,]
```

It is also possible to add data outside the dimensions of the dataset as long as they are within the *maxdims*. The
dataset will be expanded to accommodate the new data. When the expansion of the dataset leads to unassigned points,
they are filled with the default fill value. The default fill value can be obtained using
```{r, results="markup"}
wind_dir_ds$get_fill_value()
wind_dir_ds[1, 25] <- 1
wind_dir_ds[1:2, ]
```

Now that we have expanded the dataset to have a 25th column, filled with 0s except for the first column, it only remains to show how
to delete a dataset. However note: Deleting a dataset does not lead to a reduction in HDF5 file size, but the internal space can be re-used
for other datasets later.
```{r}
flights.grp$link_delete("wind_dir")
flights.grp$ls()
```




## Closing the file

As a last step, we want to close the file. For this, we have 2 options, the **close** and **close_all** methods of an h5-file. There
are some non-obvious differences for novice users between the two. **close** will close the file, but groups and datatsets
that are already open, will stay open. Furthermore, as along as any object is still open, the file cannot be re-opened in the
regular fashion as HDF5 prevents a file from being opened more than once.

However, it can be quite cumbersome to close all objects associated with a file - that is if we even have still access to them.
We may have created an object, discarded it, but the garbage collector hasn't closed it yet.

In order to make this process simpler for the end-user, **close_all** closes the file as well as all objects associated with the
file. Any R6-classes pointing to the object will automatically be invalidated. This way, if it is needed, the file can be
re-opened again.

```{r, eval=FALSE}
file.h5$close_all()
```

As a rule - it is recommended to work in the following fashion. Open a file with **H5File$new** and store the resulting R6-class
object. Do not discard this object. The current default behavior is to close the file, but not the objects inside the file if
the garbage collector is triggered. This is done in order not to interfere with other open objects later, but as explained
can prevent the the re-opening of the file later. Therefore, do not discard the R6-class pointing to a file - and close it later
again using the **close_all* method in order to ensure that all IDs using the file are being closed as well.

-----------------------------------------------------

# Advanced features

HDF5 provides a very wide range of tools. Describing it here would certainly be a task that is too large for this vignette.
For a complete overview on what HDF5 can do, the reader should have a look at the [HDF5 website](https://www.hdfgroup.org/solutions/hdf5/)
and the documentation that is listed there as well as specifically the [reference manual](https://support.hdfgroup.org/documentation/hdf5/latest/_r_m.html).
Most API-functions that are referenced there are already implemented (and any other missing functionality that is feasible will hopefully
follow soon).

In this section we will will therefore only shine a spotlight on a number of low-level API functions that can be used
in connection with creating datasets as well as datatypes.

## Creating datasets

As we have already seen above, a dataset can be created by simply assigning an appropriate R object under a given
name into a group or a file. The automatic algorithm then uses the size of the assigned object to determine
the size of the HDF5 dataset, it makes assumptions about "chunking" that have an influence on the storage efficiency
as well as the maximum possible size of the dataset.

However, we have much more control if we specify these things "by hand". In the following example,
we will create a dataset consisting of 2 bit unsigned integers (i.e. capable of storing values from 0 to 3).
We will set the size of the dataset as well as the space and the
chunk-size ourselves. As a first step, lets create the custom datatype
```{r}
uint2_dt <- h5types$H5T_NATIVE_UINT32$set_size(1)$set_precision(2)$set_sign(h5const$H5T_SGN_NONE)
```
Here we use a built-in constant and datatype. All constants can be accessed using **h5const$<const_name>** and
all built-in types are accesses with **h5types$<type_name>**. An overview of all existing constants can be
retrieved with **h5const$overview** and all existing types are shown by **h5types$overview**.

Next we define the space that we will use for the dataset, where we want 10 columns and 10 rows. The number of columns will always be fixed,
but the number of rows should be able to increase to infinity.
```{r}
space_ds <- H5S$new(dims=c(10,10), maxdims=c(Inf, 10))
```

Next, we have to define with which properties the dataset should be created. We will set a default fill value of 1, enable
n-bit filtering but no compression and set the chunk size to (10, 10).
```{r}
ds_create_pl_nbit <- H5P_DATASET_CREATE$new()
ds_create_pl_nbit$set_chunk(c(10,10))$set_fill_value(uint2_dt, 1)$set_nbit()
```

Now lets put all this together and create a dataset.
```{r}
uint2.grp <- file.h5$create_group("uint2")
uint2_ds_nbit <- uint2.grp$create_dataset(name="nbit_filter", space=space_ds, dtype=uint2_dt, dataset_create_pl=ds_create_pl_nbit,
                                          chunk_dim=NULL, gzip_level=NULL)
uint2_ds_nbit[,] <- sample(0:3, size=100, replace=TRUE)
uint2_ds_nbit$get_storage_size()
```
And not lets compare what happens if we don't have any filter, only compression and nbit as well as compression

```{r}
ds_create_pl_nbit_deflate <- ds_create_pl_nbit$copy()$set_deflate(9)
ds_create_pl_deflate <- ds_create_pl_nbit$copy()$remove_filter()$set_deflate(9)
ds_create_pl_none <- ds_create_pl_nbit$copy()$remove_filter()
uint2_ds_nbit_deflate <- uint2.grp$create_dataset(name="nbit_deflate_filter", space=space_ds, dtype=uint2_dt,
                                                  dataset_create_pl=ds_create_pl_nbit_deflate, chunk_dim=NULL, gzip_level=NULL)
uint2_ds_nbit_deflate[,] <- uint2_ds_nbit[,]
uint2_ds_deflate <- uint2.grp$create_dataset(name="deflate_filter", space=space_ds, dtype=uint2_dt, dataset_create_pl=ds_create_pl_deflate,
                                          chunk_dim=NULL, gzip_level=NULL)
uint2_ds_deflate[,] <- uint2_ds_nbit[,]
uint2_ds_none <- uint2.grp$create_dataset(name="none_filter", space=space_ds, dtype=uint2_dt, dataset_create_pl=ds_create_pl_none,
                                          chunk_dim=NULL, gzip_level=NULL)
uint2_ds_none[,] <- uint2_ds_nbit[,]
```
With the sizes of the datasets
```{r}
uint2_ds_nbit_deflate$get_storage_size()
uint2_ds_nbit$get_storage_size()
uint2_ds_deflate$get_storage_size()
uint2_ds_none$get_storage_size()
```
and we see that in the case of random data, not surprisingly, the nbit filter alone is the most efficient. Using compression on the
nbit-filter actually increases the storage size. However, despite the random data, compression can still save some space compared
to raw storage as in raw storage mode, a whole byte is stored and not just 2 bit.


## Interacting with datatypes

### Integer, Float

For integer-datatypes we have already seen that we have control over essentially everything, i.e. signed/unsigned as well
as precision down to the exact number of bits. For floats we have similar control, being able to customize the size of the
mantissa as well as the exponent (although in practice this is likely less relevant than being able to customize
integer types). To learn more about this functionality for floats, we recommend to read the relevant section of the manual.

### Strings
HDF5 itself provides access to both C-type strings and FORTRAN type strings. As R internally uses C-strings, only C-type strings
are supported (i.e. strings that are NULL delimited). In terms of the size of the strings, there are fixed and variable length
strings available.
```{r}
str_fixed_len <- H5T_STRING$new(size=20)
str_var_length <- H5T_STRING$new(size=Inf)
```

These two types of strings have implications for efficiency and usability. For obvious reasons, variable length strings are
more convenient as they are never too small hold a piece of information. However, internally in HDF5, these aren't stored
in the dataset itself - only a pointer to the HDF5-internal heap is stored. This has 2 implications:

- Retrieving the string is somewhat slower
- As the heap is not compressed, compression of datasets does not yield much space saving for variable length data

From this perspective, fixed length strings are considerably better as they are both faster (if not too long) and
compressible. However, the user has to be careful that their strings aren't getting too long, or they will be truncated.


### Enum

The equivalent to factors in R are **ENUM** datatypes. These are stored internally as integers, but each integer
has a string label attached to it. In contrast to R-factor variables, the integer values do not have to start at 1 and do not
have to to consecutive either. In order to support this more flexible datatype also optimally on the R side,
hdf5r comes with the **factor_extended** class. In the HDF5 API - each enum level is inserted one at a time. As this is
rather inconvenient for a vector-oriented language like R, this functionality has not been exposed. We instead
provide an R6-class constructor that lets us set all labels and values in one go.

```{r}
enum_example <- H5T_ENUM$new(c("Label 1", "Label 2", "Label 3"), values=c(-3, 5, 10))
```
For efficiency reasons, an integer datatype is automatically generated that provides exactly the needed
precision in order to store the values of the enum. Given an enum, variable, we can also find out what labels and values it has

```{r}
enum_example$get_labels()
enum_example$get_values()
```

In addition, we can also get the datatype back that the enum is based on

```{r}
enum_example$get_super()
```

#### Logical values

A logical variable is a special case of an enum. It is internally based on a 1-byte unsigned integer that has a precision of 1-bit
(so an n-bit filter will only store a single bit). Its internal values are 0 and 1 with labels *FALSE* and *TRUE* respectively.
As a class, it is represented as an H5T_ENUM

```{r}
logical_example <- H5T_LOGICAL$new(include_NA=TRUE)
## we could also use h5types$H5T_LOGICAL  or h5types$H5T_LOGICAL_NA
logical_example$get_labels()
logical_example$get_values()
```
Note that doLogical has precedence over the *labels* parameter.


### Compounds (Tables)

Tables are represented as *COMPOUND* HDF5 objects, which are the equivalent of C-struct. As R does not know this datatype natively,
it has to be converted from structs to the list-based construct of R data-frames. Similar as with ENUMs, we don't expose the underlying
C-API that builds the compound on element at a time but instead provide constructors that create it in one go.

```{r}
cpd_example <- H5T_COMPOUND$new(c("Double_col", "Int_col", "Logical_col"), dtypes=list(h5types$H5T_NATIVE_DOUBLE, h5types$H5T_NATIVE_INT,
                                                                               logical_example))
```
and similar to enums, we can also get back the column names, the classes of the datatypes as well as
identifiers for the datatypes itself.

```{r, results="markup"}
cpd_example$get_cpd_labels()
cpd_example$get_cpd_classes()
cpd_example$get_cpd_types()
```

A textual description is also available

```{r}
cat(cpd_example$to_text())
```


#### Complex values

We also have a way of representing complex variables, these are a compound object consisting of two double precision floating point columns.
This also matches nicely the fact that internally in R, complex values are represented as a struct of doubles.

```{r}
cplx_example <- H5T_COMPLEX$new()
cplx_example$get_cpd_labels()
cplx_example$get_cpd_classes()
```


### Arrays

A special datatype is the **H5T_ARRAY**. As datasets are itself arrays, they are not needed to represent
arrays itself. Rather, the are useful in cases where one datatype is wrapped inside another, so mainly if a
column of a compound object is supposed to be an array. So lets create an array and put it into a compound object together
with some other columns

```{r}
array_example <- H5T_ARRAY$new(dims=c(3,4), dtype_base=h5types$H5T_NATIVE_INT)
cpd_several <- H5T_COMPOUND$new(c("STRING_fixed", "Double", "Complex", "Array"),
                                dtypes=list(str_fixed_len, h5types$H5T_NATIVE_DOUBLE, cplx_example, array_example))
cat(cpd_several$to_text())
```

And to see what this would look like as an R object

```{r}
obj_empty <- create_empty(1, cpd_several)
obj_empty
obj_empty$Array
```


### Variable length data types

And last, there are also variable length datatypes - corresponding to a list in R where each item of the list
has the same datatype (general R list, where each item can have a different type cannot be represented in HDF5).

```{r}
vlen_example <- H5T_VLEN$new(dtype_base=cpd_several)
```

This would represent a list where each item is a table with an arbitrary number of rows.









----------------------------------------------------

# Implementation details

In this section some of the details will be discussed that are likely only interesting for the
technically inclined or someone who would want to extend the package itself.


## Closing of unused ids and garbage collection

In this package, the C-API of HDF5 is being used. For the C-API, it is usually the programmer's responsibility
to close manually an HDF5-ID that is being used by calling the appropriate "close" function. If programs
are not written very diligently, this can easily lead to memory-leaks.

As users of R are used to objects being automatically garbage-collected, such a behavior could pose a significant
problem in R. In order to avoid any issues, the closing of HDF5-IDs is therefore done automatically using the
R garbage collection mechanism.

For every id that is created in the C-code and passed back to R, an R6-class object is created that is non-cloneable.
During creating, the finalizer (see reg.finalizer) is set so that during garbage collection of the R6-class object or when
shutting down R, the corresponding HDF5 resources are being released.

In addition to this, all HDF5-IDs that are currently in use are being tracked as well (in the obj\_tracker environment; not exported).
The reason for this separate tracking is so that on demand, all objects that are currently still open in a file can be closed. The
special challenge here is on the one-hand to track every R6 object that is in use in R, and at the same time not interfere with the
normal operation of the R garbage collection mechanism. To this end, we cannot just save the environment itself in the obj\_tracker
(note that in R, an environment-object is always a pointer to the environment, not the whole environment itself). If we
stored a pointer to the environment itself, the R garbage collector would never delete the environment as formally it would still be
in use (in the obj\_tracker). In order to prevent that, the following mechanism was implemented:

- Every HDF5-ID that is in use is wrapped inside an environment.
- A pointer to that environment is stored inside the R6-class as well as the obj\_tracker
- This way, the R6-class is not referenced directly by the obj\_tracker, however it is possible, by accessing the environment the ID is
- wrapped in through the object tracker to set the ID that is stored inside it to NA - thereby invalidating it.
- As the R6-class is only storing a pointer to the environment, for it the ID will now also appear as NA.

As mentioned, this was mainly implemented to allow for the closing of all IDs that are still open inside a file and to
invalidate all existing R6-classes as well.

### Opening and closing of files

In this context, let us quickly also discuss the special way HDF5 handles files. In HDF5, in principle a file can always only be opened once.
This can lead to problems as users in R are used to being able to open files as often as they like. Furthermore, it is possible in HDF5
to close the ID of a file without closing all objects in the file. Then, however, the file actually stays open until the last ID pointing
into the file is closed and it cannot be opened again without it.

Therefore, as already explained above (and as recommended by the HDF5 manual), do not discard or close files that still have open objects in them.
It is preferable to keep the HDF5-file-id pointer around and close it when it is no longer needed (and all objects inside the file) using
the **close_all** method.



## Conversion of datatypes

A special feature of this package is the far-reaching and flexible implementation of data-conversion routines between R and HDF5. Routines
have been implemented for all datatypes, string, data-frames, arrays and variable length (HDF5-VLEN) objects. Some are relatively straightforward,
others are more complicated. Here, numeric datatypes can be tricky due to the limited ability of R to represent certain datatypes,
specifically long doubles or 64bit-integers.

### Numeric datatypes

For numeric datatypes, the situation is in certain circumstances a bit tricky. In general, R numerical objects are either represented as
64-bit floating point values (doubles) or 32-but integers. R switches relatively transparently between these types as needed (for computations,
integers are converted to doubles and conversely, array positions can be addressed by doubles). The main issue when working with
HDF5 occurs as R doesn't have either a 64bit signed or unsigned integer datatype (and also not a long double). In order to work
around this issue, the following conventions are being used

- The package uses the **bit64** package to provide support for 64-bit integers. These are used extensively (e.g. for ids) and also for
  numeric integer data types.
- 32 bit and 64 bit floats from HDF5 are always returned as 64 bit floats in R. Writing 32 bit floats from R, may always incur loss of precision
  of the underlying 64 bit double that is used to represent it in R.
- For integer data types, any HDF5 integer type that can accurately be represented as a 32-bit signed integer will be returned to R as a regular
  integer (can be changed using flags).
  Any HDF5 64-bit integer can be returned as a signed 64-bit integer - with the option of returning it as a 32 bit integer or double if it
  can be done without loss of precision. For unsigned 64-bit integers, they will be returned as floats, incurring loss of precision but
  avoiding truncation.

An overview of how the data conversion is being done can be seen here:

![Schematic of dataype conversion](./DatatypeConversionDiagram.png)

The underlying principle is that any internal conversion between R types is done by R (with the resulting handling of NA's and overflows),
whereas any conversion between R-types and Non-R-types is done by the HDF5 library (usually meaning that on overflow, truncation occurs).

### Strings

In HDF5, strings can either be variable length or fixed length strings. In R, they are always variable length. Therefore, strings from R to HDF5
that are written into fixed-length fields will be truncated. Conversely, strings from HDF5 that are fixed length to R will only be returned up
the the NULL character that ends strings in C.

### Data-frames/Compounds

The situation is a bit more tricky for table-like objects. In R, these are data-frames, which internally are a list of vectors. In HDF5,
a table is a Compound object, that is equivalent to C-struct - i.e. every row is represented together whereas in R every column is represented
together. Each of these approaches has certain advantages, but the challenge here is to translate between them.

This is done in the straightforward manner. When converting from R to HDF5, the columns of the tables are copied into the struct whereas in
the reverse direction, every struct is decomposed into the corresponding columns.

The Data-frame <-> Compound conversion is also extensively used for HDF5-API functions that return structs as result (and therefore
return data-frames).


### Arrays data-types

In HDF5, datasets itself can have arbitrary dimensions. In addition to that, there are also array-datatypes that allow for the inclusion for
arrays e.g. inside a compound object. Translation to and from arrays is relatively straightforward and only involves setting the correct
*dim* attribute in R.

In addition to that, however, there is small complication. In R, the first dimension is the fastest changing dimension. In HDF5 (same as in C),
the last dimension is however the fastest changing one. For datasets, we work around this problem by always reversing the dimensions
that are passed between R and HDF5 and therefore making the distinction transparent. For arrays, this is however a bit trickier. For example
let us assume that we have a dataset that is a one-dimensional vector of length 10, each element of which is an array-datatype of
length 4, resulting in a 10 x 4 dataset. However, it is now not quite clear how this should be represented in R. If we follow the notion,
that the fastest changing dimension in R is the first one, the result would be a dataset with 4 rows and 10 columns, i.e. 10 x 4.

This does feel rather unintuitive, forcing a user to specify the second dimension to get all items of the array. Therefore,
we have implemented it so that a 10 x 4 dataset is returned, with each row corresponding to the array-datatype. In order to achieve
this we have to deviate from the ordering principle in HDF5. Where in HDF5, the elements of the first internal array are in position
1, 2, 3 and 4 (or 0 to 3 when you start counting at 0), in R they are now in position 1, 11, 21, and 31. In order to do this,
we first internally read the HDF5 array into an R-array of shape 4 x 10 and then transpose the result.


### Variable-length data types

In HDF5, there are also variable-length data types. Essentially, this corresponds to an R list-like object, with the additional
restriction that every item of the list has to be of the same datatype. This is also how it is implemented. R list where all items are
vectors (of arbitrary length) of the same type can be converted to HDF5-VLEN objects and vice versa.


### Reference objects

As of the writing of this vignette, these have not yet been implemented.


---------------------------------------------------

# Future directions

- Custom table class
- API for dplyr
- Ability to store and retrieve missing values for any datatype
- In-memory datasets
- HDF5 references classes
- Improved support in R for different datatypes (mainly uint64)
- Static HTML manual pages


```{r, eval=TRUE, FALSE, include=FALSE}
file.h5$close_all()
```

