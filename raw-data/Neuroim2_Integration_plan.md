
## Revised Integration Plan: LNA Ingestion of `neuroim2` Data Structures

This plan details the integration of `neuroim2` data structures (primarily `NeuroVec` and `LogicalNeuroVol`) as inputs to the LNA `write_lna` function. The approach prioritizes immediate usability for common `neuroim2` objects by converting them to base R types expected by LNA's core engine, while noting paths for deeper, more memory-efficient integration in the future.

The goal is to work within the existing LNA codebase, and not to change the LNA codebase. We just want native neuroimaginfdatastrcutures to be supported and easily pluggable into the LNA pipeline as the ideal data source

**Overall Strategy:**
*   **Centralized Detection & Conversion:** Input object type detection and conversion to LNA-expected formats (arrays, lists of arrays) will occur early within `core_write`.
*   **Leverage `neuroim2` API:** Utilize `neuroim2`'s existing methods like `as.array()`, `as.dense()`, `space()`, `dim()`, etc., for conversion and metadata extraction.
*   **Header Auto-Population:** Automatically populate LNA's `header` argument from the `NeuroSpace` object if not user-supplied.
*   **Progressive Support:** Sprint 1 focuses on dense `neuroim2` types. Sprint 2 adds support for sparse and file-backed types via an initial "densify-then-write" strategy, with appropriate size checks.

---

**Sprint 1: Core `DenseNeuroVec` & `LogicalNeuroVol` Ingestion + Header Auto-Population**

| #        | Ticket                                                              | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | `neuroim2` Refs                                                                                               | LNA Spec Ref        |
| :------- | :------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------ | :------------------ |
| NI2LNA-S1-1 | **Centralized `neuroim2` Object Detection & Conversion in `core_write`** | • **Location:** Early in `core_write`, *after* the initial check if `x` is a list (to handle lists of `NeuroVec`s). <br> • **Helper `lna:::ensure_lna_array_input(obj)`:** <br>   - If `obj` `inherits("DenseNeuroVec")`, convert to 4D R array via `as.array(obj)`. <br>   - If `obj` `inherits("DenseNeuroVol")` or is a 3D R array, convert to 4D R array by appending a singleton 4th dimension (Time=1). Store original 3D flag for context. <br>   - If `obj` is already a 4D R array, pass through. <br>   - Else, error or pass to existing validation. <br> • Apply this helper to `x` (if not a list) or to each element of `x` (if a list). | `DenseNeuroVec`, `DenseNeuroVol`, `as.array()`, `dim()`                                                         | `write_lna` `x` arg |
| NI2LNA-S1-2 | **Enhance `core_write` Mask Validation for `LogicalNeuroVol`**      | • Modify the existing mask validation logic in `core_write` (or its helper, e.g., `lna:::validate_mask`). <br> • If `mask` `inherits("LogicalNeuroVol")`: <br>   1. Extract its `NeuroSpace`: `mask_space <- space(mask)`. <br>   2. If input `x` (or first run's `x_run`) also has a `NeuroSpace` (`input_space <- space(x_run)`): <br>      a. Compare `dim(mask_space)[1:3]` with `dim(input_space)[1:3]`. <br>      b. Compare `trans(mask_space)` with `trans(input_space)`. If different, issue a `warn_lna()`: "Mask orientation/space differs from input data; reslice mask to data space for accurate application." (LNA itself won't reslice). <br>   3. Convert `mask` to a 3D logical R array using `as.array(mask)` for subsequent LNA mask processing. | `LogicalNeuroVol`, `space()`, `dim()`, `trans()`, `as.array()`                                                  | `write_lna` `mask` arg |
| NI2LNA-S1-3 | **Auto-populate `header` via Exported `neuroim2_space_to_lna_header()`** | • Create an **exported** helper function `neuroim2_space_to_lna_header(neurospace_obj)`. <br>   - Input: a `NeuroSpace` object. <br>   - Output: A named list suitable for LNA's `header` param: `list(dims=dim(neurospace_obj)[1:min(3,ndim(neurospace_obj))], spacing=spacing(neurospace_obj), origin=origin(neurospace_obj), transform=trans(neurospace_obj))`. *Note: `origin(neurospace_obj)` is already world-space.* <br> • In `write_lna` (before calling `core_write`): If `header` arg is `NULL` AND input `x` (or its first element) `inherits("NeuroObj")`, call `header_list <- neuroim2_space_to_lna_header(space(x))` and pass this to `core_write`. | `NeuroObj`, `NeuroSpace`, `space()`, `dim()`, `spacing()`, `origin()`, `trans()`                              | `write_lna` `header` arg |
| NI2LNA-S1-4 | **Unit Tests for Sprint 1 Ingestion**                             | • Test `core_write` correctly converts `DenseNeuroVec` (single/list) to 4D arrays. <br> • Test `core_write` converts `DenseNeuroVol`/3D array input to 4D array (T=1). <br> • Test mask validation logic with `LogicalNeuroVol` input: <br>   - Correct conversion to logical array. <br>   - Warning if mask space differs from data space (orientation/dims). <br> • Test `neuroim2_space_to_lna_header()` helper directly. <br> • Test auto-header population in `write_lna` when `x` is `DenseNeuroVec` and `header` is NULL. <br> • **Orientation Test:** Write an LPI-oriented `DenseNeuroVec`; read LNA file's header and verify the affine transform matches. | -                                                                                                             | -                   |
| NI2LNA-S1-5 | **Documentation & Vignette Update (Initial)**                     | • Update `write_lna` docs: `x` can be `NeuroVec` (or list); `mask` can be `LogicalNeuroVol`. Explain auto-header from `NeuroSpace`. <br> • Create a *small* "Round-Trip with neuroim2" vignette: <br>   1. Read NIfTI (e.g., with `neuroim2::read_vec` or `oro.nifti::readNIfTI`). <br>   2. Wrap/convert to `DenseNeuroVec`. <br>   3. `write_lna()` using the `DenseNeuroVec`. <br>   4. `read_lna()` (standard LNA output). <br>   5. (Placeholder for future `read_lna(as_neuroim = TRUE)` returning `DenseNeuroVec`). | -                                                                                                             | LNA §10             |

**Sprint 2: Handling Sparse, File-Backed `NeuroVec` Variants & `NeuroVecSeq`**

| #        | Ticket                                                              | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | `neuroim2` Refs                                                                                                                                     | LNA Spec Ref        |
| :------- | :------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------ |
| NI2LNA-S2-1 | **Extend `lna:::ensure_lna_array_input` for Sparse/Mapped Types**  | • Modify `lna:::ensure_lna_array_input(obj)` from S1-1. <br> • If `obj` `inherits` from `SparseNeuroVec`, `MappedNeuroVec`, `FileBackedNeuroVec`, or `BigNeuroVec`: <br>   1. **Size Check:** `if (prod(dim(obj)) * size_of_element > getOption("lna.max_dense_elements_bytes", 5e8 * 4)) abort_lna("Neuroim2 object too large to densify for LNA input; use smaller objects or future direct sparse/chunked LNA path.")`. (Default 500M elements * 4 bytes/float). <br>   2. Convert to `DenseNeuroVec`: `dense_obj <- as.dense(obj)`. <br>   3. Convert to 4D R array: `as.array(dense_obj)`. <br>   4. Handle 3D to 4D expansion as in S1-1 if `as.dense()` returns a `DenseNeuroVol`. | `SparseNeuroVec`, `MappedNeuroVec`, etc., `as.dense()`, `as.array()`, `dim()`                                                                     | `write_lna` `x` arg |
| NI2LNA-S2-2 | **(Deferred) Direct Sparse `NeuroVec` Ingestion Path**              | • *No implementation in this sprint. Document as future enhancement.* <br> • For `SparseNeuroVec`: could pass `as.matrix(sparse_vec)` (Time x ActiveVoxels after transpose) to `dense_mat` input of `core_write` and `as.array(sparse_vec@mask)` as the `mask`. This would require `core_write` to have a path that accepts pre-flattened masked data. Current LNA expects full 4D `x` and 3D `mask`.                                                                                 | `SparseNeuroVec`, `as.matrix()`, `@mask`                                                                                                              | -                   |
| NI2LNA-S2-3 | **Handle `NeuroVecSeq` Input in `core_write`**                      | • Extend input processing in `core_write` (or `lna:::ensure_lna_array_input`'s caller). <br> • If `x` `inherits("NeuroVecSeq")`: <br>   1. Extract the list of `NeuroVec`s: `list_of_neurovecs <- x@vecs`. <br>   2. **Space Consistency Check:** Verify all `NeuroVec` objects in `list_of_neurovecs` share identical `NeuroSpace` objects (same dimensions, spacing, origin, transform). If not, `abort_lna("All NeuroVec objects in a NeuroVecSeq input must share an identical NeuroSpace when passed to LNA.")`. <br>   3. Process `list_of_neurovecs` as if it were the original `x` (i.e., each element converted to array by `lna:::ensure_lna_array_input`). <br>   4. `run_ids` for `write_lna` can be `names(list_of_neurovecs)`. | `NeuroVecSeq`, `@vecs`, `space()`                                                                                                                     | `write_lna` `x` arg |
| NI2LNA-S2-4 | **Handle Unsigned Integer Data from `neuroim2`**                  | • In `lna:::ensure_lna_array_input`, after `as.array(neuroim_obj)`: <br> • If `is.integer(array_data)` (and potentially check for unsigned types if R had them, or if `neuroim2` signals this via attributes), ensure LNA transforms that expect numeric/double (e.g., `basis.pca`) correctly coerce the data. Most R functions will do this automatically. <br> • Add a note in documentation: "LNA transforms typically expect floating-point data; integer data from `neuroim2` objects will be coerced as needed by R's standard behavior." | `is.integer()`                                                                                                                                      | Edge Case 3.4       |
| NI2LNA-S2-5 | **Unit Tests for Sparse/Mapped/Seq & Edge Cases**                 | • Test `write_lna` with `SparseNeuroVec` (triggering densification and size check). <br> • Test with a `MappedNeuroVec` (from a gzipped NIfTI, triggering densification). <br> • Test `NeuroVecSeq` input (valid case, and error if spaces differ). <br> • Test with unsigned integer `DenseNeuroVec` if `neuroim2` supports creating these easily for testing.                                                                                                  | -                                                                                                                                                   | -                   |

**Key Decisions from Review Integrated:**

*   **Centralized Conversion:** Conversion logic (`lna:::ensure_lna_array_input` and enhanced `.validate_mask`) is placed in `core_write` for broad impact.
*   **3D Input to 4D:** Single `NeuroVol` or 3D array inputs are automatically expanded to 4D (Time=1).
*   **Mask Space Warning:** If `LogicalNeuroVol` mask's space differs from data's space, a warning is issued.
*   **Header Auto-Population:** Uses an exported helper `neuroim2_space_to_lna_header`. `origin()` from `neuroim2` is used directly (it's world-space).
*   **Densification Size Check:** A safeguard (`getOption("lna.max_dense_elements_bytes")`) prevents accidental densification of excessively large sparse/mapped objects.
*   **`NeuroVecSeq` Space Check:** Enforces identical `NeuroSpace` for all elements in a `NeuroVecSeq` if it's to be treated as a list of runs for LNA. Different spaces would imply different geometries that LNA's current run model doesn't handle homogeneously.

This revised two-sprint plan should provide a robust and user-friendly integration path for `neuroim2` data structures into LNA.