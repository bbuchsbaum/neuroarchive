Okay, this is a great goal! Refactoring the `basis` transform to be generic is a key step towards a more flexible and powerful LNA. Based on the provided code (`R/transform_basis.R` primarily, and the latest refined proposal for a generic basis), here's a ticketed list for a single sprint to implement this refactoring.

**Assumptions for this Sprint:**
*   The core LNA engine (`DataHandle`, `Plan`, HDF5 utilities, parameter merging, S3 dispatch for `forward_step`/`invert_step`) is stable.
*   The `neuroim2` integration for input data handling (converting `NeuroVec` to arrays, etc.) is in place as per `R/core_write.R`'s `ensure_lna_array_input` and `validate_mask`.
*   The `lna:::as_dense_mat()` utility (from `R/utils_coercion.R`) is available and correctly converts various inputs to a (TimePoints x MaskedVoxels) or (MaskedVoxels x TimePoints) matrix. The current `as_dense_mat.array` returns Time x Voxels. We'll need to ensure the basis builders get MaskedVoxels x Time.
*   Standardized roles like `lna:::.basis_standard_roles` will be defined.

---

# Generic `basis` Transform Refactoring - Sprint Implementation Tickets

**Epic GB-E1: Core Generic `basis` Framework & PCA Builder Relocation**
*Goal: Establish the generic `forward_step.basis` dispatcher, the builder registry, and refactor the existing PCA logic into the first registered builder.*

| #       | Ticket                                                              | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Proposal Ref         |
| :------ | :------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------- |
| GB-S1-1 | **Schema Update: `basis.schema.json` for Generics**                 | • Modify `inst/schemas/basis.schema.json` as per the "Final Proposal". <br>  - Add `method` (string, default "pca", enum with "pca" initially). <br>  - Add `method_params` (object, default `{}`, `additionalProperties: true`). <br>  - Add `outputs_coefficients` (boolean, default `false`). <br>  - Add readOnly output params: `k_actual`, `method_version_used`. <br>  - Ensure existing PCA params (`k`, `center`, `scale`, `storage_order`) are moved/mapped into `method_params` if `method="pca"`, or ensure the PCA builder looks for them at the top level of `p` for backward compatibility initially. *Decision: For PCA builder, allow `k`, `center`, `scale` at top level of `p` for backward compatibility, but also check `p$method_params$pca` if method="pca".* | Final Proposal §2    |
| GB-S1-2 | **Basis Builder Registry & Registration Function**                  | • Create `R/transform_basis_registry.R` (or similar). <br> • Implement internal environment `.basis_builders <- new.env(parent = emptyenv())`. <br> • Implement exported `register_lna_basis_method(method_name_string, builder_function)`: <br>    - Validates inputs. <br>    - (Optional) Inspects `formals(builder_function)` against expected signature (warn if mismatch). <br>    - Assigns `builder_function` to `.basis_builders[[method_name_string]]`. <br> • Implement exported `get_registered_basis_methods()` returning `ls(.basis_builders)`. | Final Proposal §3    |
| GB-S1-3 | **Helper: `lna:::convert_to_masked_vox_time_matrix()`**              | • Create/Refine this utility (likely in `R/utils_coercion.R` or `R/utils_matrix.R`). <br>  - Input: `X_input_raw` (from `handle$get_inputs`), `mask_3d_logical_array` (from `handle$mask_info$mask`, can be `NULL`). <br>  - If `X_input_raw` is `neuroim2::NeuroVec` and `mask_3d_logical_array` is `neuroim2::LogicalNeuroVol`, use `as.matrix(series(X_input_raw, mask_3d_logical_array))` which gives Time x MaskedVoxels, then transpose. <br>  - If `X_input_raw` is 4D array and `mask_3d_logical_array` is 3D array, apply mask and reshape to (MaskedVoxels x TimePoints). <br>  - If `X_input_raw` is already 2D matrix (Voxels x Time), pass through or validate against mask. <br>  - If `X_input_raw` is `NULL` (for analytic basis), return `matrix(0.0, 0, 0)`. | Q_BuilderInput_1 Ans |
| GB-S1-4 | **Refactor PCA Logic into `build_basis_pca()`**                       | • Create `R/transform_basis_methods.R` (or similar). <br> • Implement `build_basis_pca(X_masked_vox_time, mask_3d_logical_array, neurospace_obj, full_merged_params, active_data_handle)`. <br>  - Move current PCA logic from `forward_step.basis` into this function. <br>  - Input `X_masked_vox_time` is MaskedVoxels x Time. Transpose to Time x MaskedVoxels for `prcomp`/`irlba`. <br>  - Takes `k`, `center`, `scale`, `svd_solver` from `full_merged_params$method_params` (with fallbacks to top-level `full_merged_params$k` etc. for backward compatibility with old PCA descriptors). <br>  - Returns `list(basis_matrix = U_vox_k, k_actual = ..., model_specific_params = list(center=..., scale=...), coefficients = C_time_k (if requested), capabilities=...)` as per builder contract. `basis_matrix` must be MaskedVoxels x K_actual. | Final Proposal §3, §4 |
| GB-S1-5 | **Register `build_basis_pca`**                                      | • In the file defining `build_basis_pca` (or LNA's `zzz.R`), call `register_lna_basis_method("pca", build_basis_pca)`.                                                                                                                                                                                                                                                                                                                             | Final Proposal §3    |
| GB-S1-6 | **Refactor `forward_step.basis` (Generic Dispatcher)**              | • Modify existing `forward_step.basis` in `R/transform_basis.R`. <br>  - Retrieve `p <- desc$params`, `method <- p$method %||% "pca"`. <br>  - Check if `method` exists in `.basis_builders`. Abort if not. <br>  - Call `lna:::convert_to_masked_vox_time_matrix()` to get `X_mat_vox_time`. <br>  - Get `mask_3d_array` and `input_neurospace` from `handle`. <br>  - `basis_out <- build_fun(X_mat_vox_time, mask_3d_array, input_neurospace, p, handle)`. <br>  - Validate `basis_out` structure (`k_actual` present, `basis_matrix` present if not analytic). <br>  - Implement common storage logic for `basis_matrix` (handling `storage_order`), `model_specific_params`, and `extras` as detailed in "Final Proposal §4 (Wrapper Behaviour for extras)". <br>  - Update `desc$params` with `k_actual`, `method_version_used`. Update `desc$datasets`, `desc$capabilities`. <br>  - Handle `outputs_coefficients` and update stash accordingly. | Final Proposal §4    |
| GB-S1-7 | **Define `lna:::.basis_standard_roles`**                            | • Create the internal character vector `.basis_standard_roles` in `R/utils_defaults.R` (or similar) with standard role names like "basis_matrix", "basis_mean_vector", etc.                                                                                                                                                                                                                                                                          | Final Proposal §2.1  |
| GB-S1-8 | **S3 Generic `invert_step.basis` & Default Implementation**       | • In `R/dispatch.R` or `R/transform_basis.R`, change `invert_step.basis` to be an S3 generic: `invert_step.basis <- function(type, desc, handle) UseMethod("invert_step.basis", structure(list(), class = desc$params$method %||% "pca"))`. <br> • Implement `invert_step.basis.default(method_class_obj, type, desc, handle)`. <br>   - This contains the current linear reconstruction logic. <br>   - It attempts to load and apply datasets with roles `lna:::.basis_standard_roles["basis_mean_vector"]` and `...["basis_scale_vector"]` if present in `desc$datasets`. <br>   - Handles `storage_order` for loaded `basis_matrix`. <br>   - Handles subsetting. <br>   - Unflattens data using `handle$mask_info$mask`. | Final Proposal §2.2, §5 |
| GB-S1-9 | **Register Default Inverse for PCA**                                | • `registerS3method("invert_step.basis", "pca", invert_step.basis.default, envir = asNamespace("lna"))`. (Or define `invert_step.basis.pca` directly as a copy of the default if preferred).                                                                                                                                                                                                                                                  | Final Proposal §2.2  |
| GB-S1-10| **Unit Tests for Generic Framework & PCA Builder**                  | • Test `register_lna_basis_method` and `get_registered_basis_methods`. <br> • Test `build_basis_pca` directly for various inputs (data, k, center, scale). <br> • Test `forward_step.basis` dispatching to `build_basis_pca`. Verify HDF5 output structure (main matrix, center/scale, extras if PCA adds any like explained_var). <br> • Test `invert_step.basis` (default/PCA path) reconstructs correctly, including application of mean/scale. <br> • **Backward Compatibility Test:** Read an old LNA file written with the PCA-specific `basis` transform and ensure `read_lna` still works using the new generic `invert_step.basis.default` or `.pca`. | Final Proposal §3 (Checklist) |

**Sprint 2: Adding New Core Basis Builders & Advanced Features**

| #        | Ticket                                                                   | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Proposal Ref         |
| :------- | :----------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------- |
| GB-S2-1  | **Implement `build_basis_identity()`**                                   | • Create builder `build_basis_identity(X_masked_vox_time, mask_3d_logical_array, ...)`. <br>  - `method_params`: optional `value_to_fill_diagonal` (default 1.0). <br>  - If `mask_3d_logical_array` is provided, basis is identity over masked voxels ($N_{maskvox} \times N_{maskvox}$). <br>  - Else, identity over `ncol(X_masked_vox_time)` (if X is vox x time, or use first spatial dim). <br>  - Returns `list(basis_matrix = diag_matrix, k_actual = ncol(diag_matrix), capabilities = list(is_analytic_descriptor_only = FALSE))`. <br>  - Register with `method_name="identity"`.                                                                         | Final Proposal (Builders) |
| GB-S2-2  | **Implement `build_basis_lap_eig()` (Laplacian Eigenmaps)**              | • Create builder `build_basis_lap_eig` as per "Final Proposal §4 (Quick Example)". <br>  - `method_params`: `k` (num eigenvecs), `connectivity` ("6-conn", "26-conn"). <br>  - Uses `mask_3d_logical_array` and `neuroim2` (or `igraph`) to build graph Laplacian $L$. <br>  - `RSpectra::eigs_sym(L, k, which="SM")` to get eigenvectors $U$. <br>  - Returns `list(basis_matrix=U, k_actual=ncol(U), extras = list(eigen_vals = list(role="basis_eigenvalues", data=eigvals)))`. <br>  - Register with `method_name="lap_eig"`.                                                                                             | Final Proposal §4    |
| GB-S2-3  | **Implement `build_basis_hrbf_analytic()` (Descriptor-Only HRBF)**     | • Create builder `build_basis_hrbf_analytic`. <br>  - Input: `mask_3d_logical_array`, `neurospace_obj`, `method_params` (for $\sigma_0$, levels, seed, etc. as per HRBF appendix). <br>  - *Does not use `X_masked_vox_time`.* <br>  - Generates HRBF centre locations $C_{total}$ and $\sigma_{vec}$ based on params. <br>  - **Does not form/return `basis_matrix`.** <br>  - Returns `list(basis_matrix=NULL, k_actual=nrow(C_{total}), extras=list(atom_centers=list(role="basis_atom_centers", data=C_{total}), atom_sigmas=list(role="basis_atom_sigmas", data=sigma_vec)), capabilities=list(is_analytic_descriptor_only=TRUE))`. <br>  - Register with `method_name="hrbf_analytic"`. | Final Proposal §2.2  |
| GB-S2-4  | **Implement `invert_step.basis.hrbf_analytic()`**                          | • Create S3 method `invert_step.basis.hrbf_analytic`. <br>  - Called when `desc$params$method == "hrbf_analytic"` AND `desc$capabilities$is_analytic_descriptor_only == TRUE`. <br>  - Retrieves `coefficients` from stash. <br>  - Loads `atom_centers` and `atom_sigmas` from HDF5 via `desc$datasets` (using their standard roles). <br>  - Regenerates HRBF basis atoms $B_{hrbf}$ on-the-fly using these centres/sigmas and `handle$mask_info$mask` (and `handle$subset$roi_mask`). <br>  - Reconstructs $X_{hat} = \text{coeffs} \cdot B_{hrbf}$. <br>  - Unflattens, updates stash.                                                                                                     | Final Proposal §2.2  |
| GB-S2-5  | **Refine Common Storage in `forward_step.basis` for `extras` & `dtype`** | • Ensure the loop for writing `extras` in `forward_step.basis` correctly uses `extra_item$role` and `extra_item$data`. <br> • Allow `extra_item` to include `dtype_suggestion` (e.g., "float32", "int16"). <br> • `plan$add_dataset_def` should accept and pass this `dtype` to `h5_write_dataset` (which needs to be updated to use it). This allows builders to suggest optimal storage types for their auxiliary data.                                                                      | Addendum Q_BuilderExtras_1 |
| GB-S2-6  | **Handle "Null Basis" Edge Case (`k_actual=0`)**                         | • In `forward_step.basis`: If a builder returns `k_actual = 0` AND `capabilities$is_analytic_descriptor_only = TRUE` (e.g., for a conceptual "identity" transform that implies no basis matrix is stored and coefficients are the data itself): <br>    - No `basis_matrix` is written. <br>    - The descriptor reflects `k_actual = 0`. <br> • In `invert_step.basis.default`: If it's called for a method with `k_actual=0` and `is_analytic_descriptor_only=TRUE` (and no specific inverse method exists for it), it should pass through the data from the `coefficients` stash key to the `input_key` without modification. | Addendum §2.2        |
| GB-S2-7  | **Unit Tests for New Builders & Analytic/Null Basis Paths**            | • Test `build_basis_identity` and `build_basis_lap_eig` (output structure, content). <br> • Test `forward_step.basis` successfully dispatching to these and storing their outputs (including `extras`). <br> • Test `build_basis_hrbf_analytic`: correct `extras` (centres, sigmas), `k_actual`, and `is_analytic_descriptor_only=TRUE`. No `basis_matrix` payload. <br> • Test `invert_step.basis.hrbf_analytic` correctly regenerates basis and reconstructs. <br> • Test "null basis" scenario (k_actual=0, analytic): inverse correctly passes data through. | -                    |
| GB-S2-8  | **Documentation & Developer Guide Updates**                              | • Update `?basis` documentation to explain `method`, `method_params`, and list core-supported methods. <br> • Create a new vignette or dev-guide section: "Writing a Custom LNA Basis Builder," detailing the contract, registration, standard roles, and providing an example (e.g., `lap_eig`). <br> • Document `lna:::scaffold_basis_builder("my_method_name")` helper.                                                                                               | Final Proposal §3 (Checklist) |
| GB-S2-9  | **Helper: `lna:::scaffold_basis_builder()`**                             | • Implement `lna:::scaffold_basis_builder(method_name)` to generate: <br>    - R file with skeleton `build_basis_<method_name>()` function. <br>    - R file with skeleton `invert_step.basis.<method_name>()` (if needed). <br>    - Basic `method_name.schema.json` for `method_params`. <br>    - Stub unit test file. <br> • Include Roxygen `@section Basis-builder contract:` detailing inputs/outputs. | Addendum Pt 1        |
| GB-S2-10 | **Helper: `expect_basis_roundtrip()`**                                 | • Implement `expect_basis_roundtrip(test_input_data, basis_method_name, method_params_list, ...)` for unit testing. <br>   - Internally calls `write_lna` with the specified basis, then `read_lna`, and checks reconstruction error.                                                                                                                                                                                                           | Addendum Pt 1        |

This two-sprint plan should achieve a fully generic, extensible, and robust `basis` transform framework for LNA.