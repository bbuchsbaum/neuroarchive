Okay, this is a great Phase 0 ticket list! It sets a very solid foundation.

Now, let's define **Phase 1**, which will focus on making the LNA package *functional* for a basic end-to-end use case. This means implementing core data handling, the first real transform (e.g., `quant`), and fleshing out the stubs from Phase 0 related to actual data I/O and file finalization.

---

# Milestone 1: End-to-End Basic Quantization - Implementation Tickets

**Epic M1-E1: Core Data I/O & `materialise_plan` Implementation**
*Goal: Enable actual writing and reading of numerical data to/from HDF5, including compression and checksums, by fully implementing `materialise_plan` and related helpers.*

| #     | Ticket                          | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                           | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                          | Spec Refs    |
| :---- | :------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| M1-1  | **HDF5 Dataset Writer**         | Implement `lna:::h5_write_dataset(h5_group, path, data, chunk_dims, compression_level)`: <br> • Creates/writes HDF5 dataset. <br> • Handles `chunk_dims` (or auto-derivation if `NULL` initially). <br> • Handles `compression_level` (gzip). <br> • Sets `write_mode_effective` in `plan` based on actual write behavior. <br> • Gracefully handles HDF5 without zlib (warns, sets level 0).                                                        | • Can write numeric matrices/arrays. <br> • Chunk dimensions are set as specified or heuristically. <br> • Compression is applied; verified by file size/HDF5 tools. <br> • Falls back to no compression with warning if zlib unavailable. <br> • `plan$datasets$write_mode_effective` is updated.                                                                                                    | §4, §7, §2 (chunk_dims) |
| M1-2  | **`materialise_plan` Payloads** | Enhance `lna:::materialise_plan`: <br> • Iterate `plan$payloads` and use `lna:::h5_write_dataset` (M1-1) to write non-NULL payloads. <br> • After writing a payload, call `plan$mark_payload_written(key)`. <br> • Implement HDF5 error retry logic: 1. Retry w/o compression on filter errors + warning. 2. Retry with smaller chunks on write errors (see heuristic in spec) + warning. <br> • Use `step_index` in error messages.                            | • Datasets defined via `plan$add_payload` are written to the HDF5 file. <br> • Payloads are cleared from `plan$payloads` after writing. <br> • Retry logic for compression and chunking is triggered and functions as expected in test cases (e.g., mock HDF5 errors or oversized initial chunks). <br> • Error messages include step provenance.                                                                  | §7 (materialise), §4 (Plan) |
| M1-3  | **`materialise_plan` Checksum** | Further enhance `lna:::materialise_plan`: <br> • If `checksum="sha256"`: <br>   1. Close the HDF5 file fully. <br>   2. Compute SHA256 hash of the entire file byte stream using `digest::digest(file=...)`. <br>   3. Reopen file briefly (or use external tool if strictly adhering to "core writer MUST NOT reopen") to write `lna_checksum` root attribute. (Pragmatic choice: reopen briefly for v1).                                      | • If `checksum="sha256"`, HDF5 file is closed, hashed, and `lna_checksum` attribute is written to root. <br> • If `checksum="none"`, no hash is computed or written. <br> • File handle is properly managed (closed before hashing, closed after writing attribute).                                                                                                                                          | §2 (checksum), §7 (materialise) |
| M1-4  | **Chunking Heuristic Impl.**    | Implement initial chunking heuristic in `lna:::h5_write_dataset` or a helper: <br> • Target <= 1 MiB/chunk. <br> • If est. compressed chunk > 1 GiB for > 4 GiB data, halve fastest changing dimension's chunk size until < 1 GiB. <br> • Auto-reduction for HDF5 limits (e.g., if first heuristic fails, target <= 256 MiB) with warnings.                                                                                                                | • Unit tests verify chunk dimension calculations for various input data sizes and types. <br> • Heuristic correctly reduces chunk sizes under specified conditions. <br> • Warnings are issued for auto-reduction.                                                                                                                                                                                               | §2 (chunk_dims) |

**Epic M1-E2: `write_lna` & `read_lna` Core Logic Enhancements**
*Goal: Implement key functionalities in `write_lna` and `read_lna` for data handling, parameter merging, and basic read options.*

| #     | Ticket                            | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                   | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                      | Spec Refs    |
| :---- | :-------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| M1-5  | **`transform_params` Merging**    | Implement full parameter merging logic in `core_write` (or a helper): <br> 1. Transform schema defaults (via `lna:::default_params`). <br> 2. Package-level defaults (`lna_options()`). <br> 3. User-supplied list in `transform_params` argument. <br> • Deep merge (left-to-right precedence).                                                                                                                                                           | • Unit tests verify correct parameter merging order for various scenarios (all sources, some sources, conflicting keys). <br> • Deep merge behavior is confirmed for nested lists.                                                                                                                                                                                                                                                | §2 (transform_params), §7 (default_params) |
| M1-6  | **`write_lna`: Run Naming**       | Implement default run naming in `core_write`: <br> • If `x` is an unnamed list, assign run names `run-01`, `run-02`, ... based on `seq_along(x)`. <br> • Store/use these names for dataset paths if applicable by transforms.                                                                                                                                                                                                                    | • `write_lna` with unnamed list correctly generates run names. <br> • These names are accessible to `forward_step` (e.g., via `handle$current_run_id` or similar) for use in path generation (tested with a mock transform).                                                                                                                                                                                                           | §2 (x arg)   |
| M1-7  | **`write_lna`: Mask Handling**    | Implement mask handling in `core_write`: <br> • Accept `LogicalNeuroVol` or 3D logical array for `mask`. <br> • If `x` is data (not list), error if `sum(mask)` doesn't match `x`'s spatial voxel count. <br> • If `x` is list, apply this check for each element. <br> • Make mask available in `DataHandle` (e.g., `handle$mask_info = list(mask_array, active_voxels_count)`).                                                                        | • Correctly validates mask dimensions and voxel counts against input data. <br> • Throws appropriate error (`lna_error_validation` or specific) for mismatches. <br> • Mask information is correctly populated in `DataHandle`.                                                                                                                                                                                                           | §2 (mask arg) |
| M1-8  | **`write_lna`: Header Writing**   | Implement header writing in `core_write`/`materialise_plan`: <br> • Accept named list for `header`. <br> • Write NIfTI-like attributes to a designated HDF5 group (e.g., `/header/global` or `/header/run-XX`). <br> • If `x` is list, consider how to handle multiple headers or a common header. (For P1: support one common header written to `/header/global`).                                                                                              | • `header` list attributes are written to the specified HDF5 group. <br> • Data types are preserved where possible.                                                                                                                                                                                                                                                                                                           | §2 (header arg) |
| M1-9  | **`write_lna`: In-Memory**        | Implement `file=NULL` in-memory HDF5 writing in `write_lna`: <br> • Uses `hdf5r` driver='core'. <br> • `materialise_plan` and HDF5 helpers must support `H5File` objects created with `driver='core'`.                                                                                                                                                                                                                                                | • `write_lna(..., file=NULL)` successfully creates an in-memory HDF5 structure. <br> • Return value's `file` component is `NULL`. <br> • Result can be (conceptually) read back if a mechanism to pass the in-memory HDF5 object existed (not strictly testable end-to-end without P1 read, but core write should succeed). <br> • `validate_lna` (M1-17) can run on in-memory file handle (if passed).         | §2 (file arg) |
| M1-10 | **`read_lna`: Basic Read & Close**| Enhance `core_read`: <br> • Open file. <br> • Pass HDF5 file handle to `DataHandle`. <br> • Ensure HDF5 file handle is closed by `read_lna` (e.g. via `on.exit` in `read_lna` wrapper or `core_read`) after data extraction or `lna_reader` creation. This specifically applies if `lazy=FALSE`.                                                                                                                                                          | • `read_lna` (with `lazy=FALSE`) opens and closes the HDF5 file. <br> • `DataHandle` within `core_read` has access to the live HDF5 file.                                                                                                                                                                                                                                                                        | §2 (read_lna) |
| M1-11 | **`read_lna`: `output_dtype`**    | Implement `output_dtype` handling in `core_read`: <br> • Support `"float32"`, `"float64"`. <br> • Requesting `"float16"` raises `lna_error_float16_unsupported` unless `lna:::has_float16_support()` is true. <br> • Final data reconstruction step (likely within `invert_step` or `core_read` post-loop) should cast to this type.                                                                                                                       | • Data returned by `read_lna` is of the specified `output_dtype`. <br> • `float16` request behaves as specified based on `has_float16_support()`.                                                                                                                                                                                                                                                                         | §2 (output_dtype), §7 (has_float16_support) |
| M1-12 | **`lna:::has_float16_support()`** | Implement `lna:::has_float16_support()` utility. <br> • Checks for necessary dependencies (e.g., hypothetical `bit64c` or similar package providing float16, or R version). For P1, can default to `FALSE`.                                                                                                                                                                                                                                          | • Returns `TRUE` or `FALSE` based on (mocked for P1) dependency checks.                                                                                                                                                                                                                                                                                                                                          | §7 (Helpers) |

**Epic M1-E3: `lna_reader` (Lazy Reading)**
*Goal: Implement the lazy reading proxy object for efficient partial data access.*

| #     | Ticket                      | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                     | Spec Refs    |
| :---- | :-------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| M1-13 | **`lna_reader` Class Impl.**| Implement `lna_reader` (S3 or R6 class in `R/reader.R`): <br> • **Internal State:** HDF5 file handle, list of loaded `invert_step` results (`DataHandle` states), original `core_read` args. <br> • **`initialize(file, core_read_args)`:** Opens HDF5, stores args. <br> • **`$close()`:** Closes HDF5. Idempotent. <br> • **`$finalize()` / `reg.finalizer`:** Backup closure. <br> • **`print()` method:** Shows file, open status, available runs/data. | • `read_lna(..., lazy=TRUE)` returns an `lna_reader` object. <br> • HDF5 file remains open. <br> • `$close()` closes the file and is idempotent. <br> • `print()` method provides informative summary. <br> • GC finalizer closes file (test with `gc()` and mock to check file state).                                                                                                                                | §4 (lna_reader), §2 (lazy arg) |
| M1-14 | **`lna_reader`: `$data()`**   | Implement `lna_reader$data(...)`: <br> • Triggers the inverse transform pipeline (runs `core_read` logic internally using stored args and open H5 handle). <br> • Applies subsetting from `$data(...)` arguments. <br> • Returns reconstructed data. <br> • Result should be cached for idempotency if called again with same args.                                                                                                                             | • `$data()` returns reconstructed data. <br> • Subsequent calls with same args return cached result without re-computation (verify via mock `invert_step`). <br> • HDF5 file handle is managed correctly (remains open if reader isn't closed).                                                                                                                                                                     | §4 (lna_reader) |
| M1-15 | **`lna_reader`: `$subset()`** | Implement `lna_reader$subset(roi_mask, time_idx, ...)`: <br> • Stores subsetting parameters. These will be used by subsequent `$data()` calls. <br> • Does NOT trigger data loading. <br> • Returns `self` invisibly for chaining.                                                                                                                                                                                                                             | • `$subset()` updates internal subsetting state. <br> • No data is loaded/computed. <br> • `$data()` called after `$subset()` uses the new subset parameters. <br> • Chaining `reader$subset(...)$data()` works.                                                                                                                                                                                                | §4 (lna_reader) |

**Epic M1-E4: First Transform Implementation (`quant`)**
*Goal: Implement a complete, simple transform (e.g., quantization) to test the full pipeline.*

| #     | Ticket                                  | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Spec Refs    |
| :---- | :-------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| M1-16 | **`quant` Transform: Schema & Defaults**| Create `inst/schemas/quant.schema.json`. Define params (e.g., `bits`, `method` \["range", "sd"], `center` \[logical], `scale_scope` \["voxel", "global"]). <br> Implement `lna:::default_params("quant")` to read and cache these schema defaults. <br> Implement `lna_default.quant()` (optional, could just use schema via `lna:::default_params`).                                                                                                                                | • `quant.schema.json` is valid JSON schema. <br> • `lna:::default_params("quant")` returns defaults from schema. <br> • Parameter merging (M1-5) picks up these defaults correctly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | §5, §7       |
| M1-17 | **`quant` Transform: S3 Methods**       | Implement `forward_step.quant(type, desc, handle)` and `invert_step.quant(type, desc, handle)`: <br> • **Forward:** Applies quantization (e.g., scale to `[0, 2^bits-1]`). Stores quantized data, scale, and offset (min/mean) as payloads in `plan`. Updates `desc` with dataset paths, params. Updates `handle$stash`. <br> • **Inverse:** Reads quantized data, scale, offset. Reconstructs data. Handles `handle$subset` for time/voxels. Updates `handle$stash`. | • `write_lna` with `transforms="quant"` successfully writes quantized data, scale, and offset to HDF5. <br> • `read_lna` reconstructs data with reasonable fidelity (lossy). <br> • `forward_step` adds correct dataset definitions and payloads to `plan`. <br> • `invert_step` correctly applies subsetting before full reconstruction if `handle$subset` is populated. <br> • `desc` object is correctly populated by `forward_step` and used by `invert_step`. <br> • Handles different `scale_scope` options. | §5           |

**Epic M1-E5: Validation, Tooling & Documentation**
*Goal: Implement basic validation, developer tools, and initial documentation for implemented features.*

| #     | Ticket                                    | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                       | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Spec Refs    |
| :---- | :---------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| M1-18 | **`validate_lna()` Basic Impl.**          | Implement `validate_lna(file, strict=TRUE, checksum=TRUE)`: <br> • Opens file, reads root attributes. <br> • Checks `lna_spec` version. <br> • If `checksum=TRUE` and `lna_checksum` attribute exists, recompute and compare. Warn/error on mismatch. <br> • Validates transform descriptors against their schemas (if schemas are findable/shipped). <br> • Placeholder for more checks.                                                                           | • `validate_lna` runs on a file from `write_lna`. <br> • Correctly validates `lna_spec`. <br> • Checksum validation works. <br> • Basic schema validation of `/transforms/*.json` descriptors passes for `quant` (if schema in `inst/`). <br> • Returns `TRUE` for valid file, throws error or returns `FALSE` (based on `strict`) for invalid.                                                                                                                                                                                                                                                                                                                                | §2, §6       |
| M1-19 | **Schema Cache & `default_params` Full**  | Fully implement `lna:::default_params(type)`: <br> • Locates schema (e.g., in `inst/schemas/${type}.schema.json`). <br> • Parses JSON schema, extracts `default` values. <br> • Caches parsed schemas and defaults. <br> • `lna:::schema_cache_clear()` clears this cache. <br> • Note fork-safety issue in docs for compiled validators if `jsonvalidate` uses them.                                                                                         | • `default_params(type)` loads schema, extracts defaults correctly. <br> • Subsequent calls use cached schema/defaults. <br> • `schema_cache_clear()` empties cache. <br> • Handles missing schema gracefully (returns empty list, warns).                                                                                                                                                                                                                                                                                                                                                                                                                                                           | §7, §6       |
| M1-20 | **`scaffold_transform()` Helper**         | Implement `lna::scaffold_transform(type)`: <br> • Generates template files: `R/transform_${type}.R` (with `forward_step`, `invert_step` stubs), `inst/schemas/${type}.schema.json` (basic schema), `tests/testthat/test-transform_${type}.R`. <br> • Stubs should use `lna:::default_params()`.                                                                                                                                                  | • Running `scaffold_transform("mycustom")` creates the specified files with reasonable boilerplate content. <br> • Generated S3 methods include calls to `lna:::default_params("mycustom")`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | §7           |
| M1-21 | **Progress Reporting Integration**        | Integrate `progressr` more fully: <br> • Use in `core_write` loop over transforms/runs. <br> • Use in `core_read` loop over transforms. <br> • Use in `materialise_plan` for payload writing (if many). <br> • Check `!progressr::handlers_is_empty()` before invoking.                                                                                                                                                                              | • Progress bars appear during `write_lna` and `read_lna` if `progressr` handlers are configured. <br> • No errors if handlers are not configured.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | §7, §2       |
| M1-22 | **Documentation Update (Phase 1)**      | Update package README, vignettes, and function man pages for features implemented in Phase 1: <br> • `write_lna`/`read_lna` params (mask, header, `output_dtype`, `lazy`, checksum). <br> • `lna_reader` usage. <br> • `quant` transform parameters and behavior. <br> • Parameter merging order. <br> • Basic `validate_lna`. <br> • Note on parallel writing file opening (atomic rename).                                                                    | • Man pages for `write_lna`, `read_lna`, `lna_reader`, `validate_lna` are updated. <br> • README provides a basic example using `quant` and lazy reading. <br> • "Cookbook" vignette started or section added, showing `quant` and `lna_reader` usage.                                                                                                                                                                                                                                                                                                                                                                                                                                  | §10          |
| M1-23 | **Error Reporting Enhancement**         | Enhance error reporting using `rlang::abort(..., location = ...)`: <br> • Ensure critical functions in `core_write`, `core_read`, `materialise_plan`, and transform steps provide context (e.g., current transform type/name/index, file path) in error messages using `location` or custom fields. <br> • Define `lna_error_float16_unsupported` and other specific error classes as needed.                                                            | • Errors originating from different stages of processing provide clear, contextual information to aid debugging. <br> • New specific error classes are used appropriately.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | §6           |
| M1-24 | **Namespace Collision Warnings**        | Implement `lna::check_transform_implementation(type)` to warn on namespace collisions: <br> • Core LNA transforms (`quant`, `basis`, `embed`, `temporal`, `delta`). <br> • Base R packages (stats, utils, etc.). <br> This can be called by `scaffold_transform` or as a standalone check.                                                                                                                                                              | • `check_transform_implementation("stats")` issues a warning. <br> • `check_transform_implementation("myunique")` does not. <br> • `scaffold_transform("delta")` issues a warning.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | §7           |

---

**Milestone 1: Definition of Done**

*   The `lna` package can successfully write neuroimaging-like array data to an LNA HDF5 file using the `quant` transform, including Gzip compression and optional SHA256 checksums.
*   `write_lna` correctly handles parameter merging, default run naming, mask validation, header metadata, and in-memory HDF5 output.
*   `read_lna` can read the data back, applying inverse `quant` transform, and casting to specified `output_dtype`.
*   `read_lna(lazy=TRUE)` returns a functional `lna_reader` object, capable of deferred data loading, subsetting, and idempotent data retrieval, with proper HDF5 handle management.
*   The `quant` transform (schema, defaults, forward/inverse S3 methods) is fully implemented and tested.
*   Basic file validation via `validate_lna()` (spec version, checksum, `quant` schema) is functional.
*   Developer helpers `lna:::default_params()` (with schema caching) and `lna::scaffold_transform()` are implemented.
*   Progress reporting is integrated.
*   Core error reporting is enhanced with more context.
*   Documentation is updated to reflect Phase 1 capabilities.
*   All Phase 1 tickets are complete, unit-tested, and CI passes.

---

This Phase 1 plan is ambitious but covers the critical path to a usable, albeit basic, LNA package. It builds directly on the skeleton from Phase 0.