Okay, here's a set of granular tickets for **Sprint 1** of implementing the LNA Tidy Pipeline DSL. This sprint will focus on establishing the core `lna_pipeline` R6 object, the pipeline initiation verb `as_pipeline()`, the terminal verb `lna_write()`, and one or two simple core transform verbs to prove the basic concept end-to-end.

**Assumptions for Sprint 1:**
*   The core LNA engine (`write_lna`, S3 transform methods, parameter resolution, etc.) is mature and functional (as per previous Phase 3/4 of LNA core development).
*   Basic schema and default parameter loading (`lna:::default_params`, `lna_options`) are in place.
*   `magrittr` can be added as a dependency (likely `Imports` or `Suggests` if pipes are only for user convenience).

---

# LNA Tidy Pipeline DSL - Sprint 1 Implementation Tickets

**Epic DSL-S1-E1: Core Pipeline Object & Basic Execution Flow**
*Goal: Implement the foundational `lna_pipeline` R6 class and the primary verbs for starting (`as_pipeline`) and executing (`lna_write`) a pipeline.*

| #        | Ticket                                       | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                           | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                           | Appendix Ref |
| :------- | :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| DSL-S1-1 | **`lna_pipeline` R6 Class Definition (Core Fields)** | • Create `R/pipeline.R` (or similar). <br> • Define `lna_pipeline` R6 class. <br> • **Fields (Initial):** `input` (default `NULL`), `input_summary` (character, default empty), `runs` (character vector, default empty), `steps` (list, default empty), `engine_opts` (list, default empty). <br> • **Method:** `initialize()`: Sets default field values.                                                                                             | • `lna_pipeline$new()` creates an object with specified fields initialized to defaults. <br> • Class structure is sound.                                                                                                                                                                                                                                                                                            | §3.1         |
| DSL-S1-2 | **`lna_pipeline$set_input()` Method**          | • Implement `lna_pipeline$set_input(x, run_ids = NULL, chunk_mb_suggestion = NULL)`. <br> • Validates `x` (is.list, is.array, inherits("NeuroVec"), etc.). <br> • Stores `x` in `self$input`. <br> • Derives `self$runs` from `names(x)` if `x` is list and `run_ids` is NULL, or uses `run_ids`. Generates `run-XX` if unnamed list and `run_ids` NULL. <br> • Generates `self$input_summary` string. <br> • Stores `chunk_mb_suggestion` in `self$engine_opts`. | • `$set_input()` correctly populates `input`, `runs`, `input_summary`, `engine_opts`. <br> • Handles single objects and lists (named/unnamed) for `x`. <br> • Input validation for `x` type works.                                                                                                                                                                                                               | §3.1, §3.2   |
| DSL-S1-3 | **`as_pipeline()` Initiator Function**       | • Create `R/dsl_verbs.R` (or add to `R/pipeline.R`). <br> • Implement `as_pipeline(x, run_ids = NULL, chunk_mb_suggestion = NULL)`. <br> • Creates an `lna_pipeline` object. <br> • Calls `$set_input()` with provided arguments. <br> • Returns the `lna_pipeline` object. <br> • Export `as_pipeline`.                                                                                                                                             | • `as_pipeline(data_obj)` returns a valid `lna_pipeline` object with `input` and `runs` correctly set. <br> • `data_obj |> as_pipeline()` works.                                                                                                                                                                                                                                                             | §3.2         |
| DSL-S1-4 | **`lna_pipeline$add_step()` Method**           | • Implement `lna_pipeline$add_step(step_spec)`. <br> • `step_spec` is `list(type = "...", params = list(...))`. <br> • Appends `step_spec` to `self$steps`. <br> • (Future: May also update `descriptor_basename` within `step_spec` based on current step count, though this might be better handled by verbs or `lna_write`). For S1, just store type/params.                                                                                 | • `$add_step()` correctly appends step specifications to the `steps` list.                                                                                                                                                                                                                                                                                                                                      | §3.1, §3.3   |
| DSL-S1-5 | **`lna_write()` Terminal Verb (Basic)**      | • Implement `lna_write(pipeline_obj, file, ..., .verbose = TRUE, .checksum = "sha256")`. <br> • Validates `pipeline_obj` is `lna_pipeline`. <br> • Extracts `transform_types` and `transform_params_list` from `pipeline_obj$steps`. <br> • Calls core `write_lna()` with `pipeline_obj$input`, `pipeline_obj$runs`, types, params, `file`, verbose, checksum, and `...` (for header, mask, etc.). <br> • Export `lna_write`.                     | • `lna_write(pipe, "file.h5")` successfully calls `write_lna` with correctly translated arguments. <br> • A pipeline with zero transforms writes a basic LNA file. <br> • `...` arguments are passed through. <br> • Returns result from `write_lna`.                                                                                                                                                           | §3.4         |
| DSL-S1-6 | **`lna_write()` Error Surfacing (Initial)**  | • Implement basic `tryCatch` within `lna_write()` around the `write_lna()` call. <br> • If `lna_error` is caught: <br>   - Extract `step_index` (0-based) and `transform_type` from the error condition attributes if present. <br>   - Construct a message like: "Pipeline failure in step [DSL 1-based index] (type='[type]'): [original message]". <br>   - `rlang::abort()` with the new message and original error as `parent`.          | • Errors from core `write_lna` (e.g., during a transform) are caught by `lna_write()`. <br> • The re-thrown error includes context about the pipeline step number and type. <br> • `rlang::last_trace()` still provides full trace.                                                                                                                                                                    | Q_DSL-2 Answer |
| DSL-S1-7 | **Unit Tests for Core Pipeline Object & Flow** | • Tests for `lna_pipeline$new()`, `$set_input()`, `$add_step()`. <br> • Tests for `as_pipeline()` with various inputs (single, list, named list). <br> • Tests for `lna_write()`: basic execution, argument passing to `write_lna`, error surfacing. <br> • Test `lna_write` with an empty pipeline (no transforms).                                                                                                                            | • All unit tests pass. <br> • Core pipeline construction and execution flow is verified.                                                                                                                                                                                                                                                                                                                             | -            |

**Epic DSL-S1-E2: First DSL Transform Verbs & Parameter Merging**
*Goal: Implement one or two simple core transform verbs (e.g., `quant`, `pca`) demonstrating parameter merging within the verb.*

| #        | Ticket                                      | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                        | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                              | Appendix Ref |
| :------- | :------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- |
| DSL-S1-8 | **`quant()` DSL Verb Implementation**       | • Implement `quant(data_or_pipe, bits = NULL, ...)` verb. <br> • If `data_or_pipe` is data, call `as_pipeline()` internally. <br> • **Parameter Merging:** <br>   1. `pars <- lna:::default_params("quant")` (memoised). <br>   2. `pars <- utils::modifyList(pars, lna_options("quant"))`. <br>   3. `pars <- utils::modifyList(pars, list(bits=bits, ...))` (filter `NULL` bits before merge). <br> • `step_spec <- list(type = "quant", params = pars)`. <br> • `pipeline_obj$add_step(step_spec)`. Return `pipeline_obj`. <br> • Export `quant`. | • `data |> as_pipeline() |> quant(bits = 6)` creates a pipeline with one "quant" step. <br> • The `params` for the quant step in `pipeline_obj$steps` reflect correct merging of schema defaults, global options, and user-supplied `bits`. <br> • `data |> quant(bits=6)` also works. <br> • `pipeline_obj$print()` (from S2) would show resolved params. | §3.3, Q2 Ans |
| DSL-S1-9 | **`pca()` DSL Verb Implementation (Basic)**   | • Implement `pca(data_or_pipe, k = NULL, ...)` verb (maps to `basis.pca`). <br> • Similar logic to `quant()`: internal `as_pipeline()`, 3-stage parameter merging for LNA transform type "basis.pca". <br> • `step_spec <- list(type = "basis.pca", params = pars)`. <br> • `pipeline_obj$add_step(step_spec)`. Return `pipeline_obj`. <br> • Export `pca`.                                                                                                | • `data |> as_pipeline() |> pca(k = 50)` creates a pipeline with one "basis.pca" step. <br> • Parameters are correctly merged.                                                                                                                                                                                                                                                                                        | §3.3, Q2 Ans |
| DSL-S1-10| **Unit Tests for `quant()` and `pca()` Verbs**| • Test parameter merging logic within `quant()` and `pca()` verbs across different scenarios (only user args, only defaults, mix). <br> • Test end-to-end pipeline construction and execution: `data |> as_pipeline() |> quant() |> lna_write(...)`. <br> • Test `data |> pca(k=10) |> embed() |> quant() |> lna_write(...)` (assuming a basic `embed()` verb is also prototyped or a full `transform_params` for embed is passed via `...` to `lna_write`). | • All unit tests pass. <br> • Verbs correctly add steps with resolved parameters. <br> • Simple pipelines execute successfully.                                                                                                                                                                                                                                                                                         | -            |
| DSL-S1-11| **Memoisation of `lna:::default_params`**    | • If not already done, wrap `lna:::default_params` with `memoise::memoise()` to ensure schemas are read from disk only once per type per session. <br> • Add `memoise` to `Imports`.                                                                                                                                                                                                                                                                  | • Subsequent calls to `lna:::default_params("type")` are faster and do not re-read schema file. <br> • Test cache clearing if `default_params` needs to re-read after schema changes during dev.                                                                                                                                                                                                                  | Micro-tip 1  |
| DSL-S2-11| **Unit Tests for Verbs, Context-Awareness, Registration, Templates** | • Tests for `delta()`, `temporal()`, `hrbf()` verbs (parameter merging, pipeline execution). <br> • Tests for context-aware `embed()` with various preceding steps. <br> • Tests for `register_lna_verb()` (registration, slugging, collision). <br> • Tests for `register_lna_template()` and `apply_template()` (template application, parameter overriding).
                                           | • All unit tests pass. <br> • Core DSL functionality is robust and extensible.



                                      | -                             |

---

**Sprint 1 - Definition of Done:**

*   The `lna_pipeline` R6 class is implemented with core fields and methods (`initialize`, `set_input`, `add_step`).
*   The `as_pipeline()` function can initialize a pipeline from various R data objects, correctly handling single vs. multi-run inputs.
*   The `lna_write()` terminal verb can take an `lna_pipeline` object, translate it into arguments for the core `write_lna()`, and execute it, producing a valid LNA file.
*   Error messages from `lna_write()` provide context about the failing pipeline step.
*   At least two simple DSL verbs (e.g., `quant()`, `pca()`) are implemented, demonstrating correct parameter merging (schema defaults -> global options -> user arguments) within the verb.
*   Basic end-to-end pipelines constructed with these verbs can be successfully written to LNA files.
*   Unit tests cover the implemented R6 methods, `as_pipeline`, `lna_write`, and the basic functionality of the implemented DSL verbs including parameter merging.
*   `lna:::default_params` is memoised.

This sprint lays the critical groundwork for the DSL. Sprint 2 will build on this by adding more advanced pipeline object methods (introspection, modification, visualization), more core verbs, and the registration system for templates and external verbs.