Okay, here's a set of actionable and granular tickets for implementing the core transforms based on your Appendix. This would typically fall within **Phase 2 and Phase 3** of the overall LNA implementation plan, as `quant`, `basis`, and `embed` are foundational, while `temporal` and `delta` are more advanced core transforms.

The `myorg.*` transforms (like `sparse_pca`, `aggregate_runs`, `octree_pca`, `bitplane_pack`, `ae_residual_codec`, `nuisance_projection`) are considered "plugin" or "custom" transforms. Their implementation would follow the pattern established in M3-E2 (Basic Plugin System & Custom Transform Infrastructure) and could be spread across different development efforts or contributed by different parties.

This ticket list focuses on the *core LNA transforms* mentioned or implied by your appendix and the LNA v1.4 spec.

---

# Implementation Tickets: Core LNA Transforms (from Appendix)

**Assumptions:**
*   Phase 0 (Core Skeleton) and Phase 1 (Basic Quantization & I/O) are largely complete.
*   `quant` transform (Method #6 - uniform part) is already substantially implemented from Phase 1 (M1-16, M1-17).
*   Helper functions for HDF5 I/O, parameter merging, `Plan`, and `DataHandle` are available.

---

**Epic CT-E1: `basis` Transform (Method #1 - PCA variant)**
*Goal: Implement the core `basis` transform focusing on Principal Component Analysis (PCA).*
*(Corresponds to parts of M2-E1 in the overall plan)*

| #      | Ticket                                         | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                   | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Appendix Ref | Spec Refs |
| :----- | :--------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- | :-------- |
| CT-1.1 | **`basis` Schema & Defaults (`basis.schema.json`)** | • Create `inst/schemas/basis.schema.json`. <br> • Define params: `method` (enum: "pca", default "pca"), `k` (integer, default e.g., 20), `center` (boolean, default `TRUE`), `scale` (boolean, default `FALSE`), `storage_order` (enum: "component_x_voxel", "voxel_x_component", default "component_x_voxel"), `solver_params` (object, default `{}`). <br> • Ensure `lna:::default_params("basis")` loads these.                         | • `basis.schema.json` is valid. <br> • `lna:::default_params("basis")` correctly returns specified defaults. <br> • `resolve_transform_params` correctly merges user/package/schema defaults for `basis`.                                                                                                                                                                                                                                                                                             | #1, #2, #9   | §5, §7    |
| CT-1.2 | **`forward_step.basis` (PCA method)**          | • Implement `forward_step.basis` for `method="pca"`. <br> • Input: `handle$stash$dense_mat` (voxel x time matrix). <br> • Logic: Use `stats::prcomp` or `irlba::prcomp_irlba`. Handle `k`, `center`, `scale`. <br> • Store: Basis matrix (`rotation`), `center` vector, `scale` vector as HDF5 payloads. <br> • `desc`: Update with paths, effective `k`, version. <br> • `stash`: Output path to basis matrix (e.g., `current_basis_path`) or signal presence. | • `write_lna` with `transforms="basis"` (method PCA) correctly computes and stores basis, center, and scale vectors in HDF5. <br> • Descriptor contains correct paths and effective `k`. <br> • Handles `storage_order` for basis matrix. <br> • Input data is correctly reshaped if 4D. <br> • Warns and truncates `k` if PCA returns fewer components.                                                                                                                                           | #1           | §5        |
| CT-1.3 | **`invert_step.basis` (for PCA reconstruction)** | • Implement `invert_step.basis`. <br> • Input: Expects `coefficients` in `handle$stash` (from `invert_step.embed`). <br> • Logic: Load basis matrix, center, scale from HDF5 paths in `desc`. Reconstruct `dense_mat = coefficients %*% t(basis_matrix) * scale_vector + center_vector`. <br> • Handle `storage_order`. <br> • Apply `handle$subset` (ROI on basis, time on coefficients). <br> • `stash`: Output reconstructed `dense_mat`. | • When chained `embed` -> `basis` (inverse), `invert_step.basis` uses coefficients from `invert_step.embed` to reconstruct data matching original (within tolerance). <br> • Correctly applies ROI subsetting to the basis matrix and time subsetting to coefficients before reconstruction. <br> • Handles missing center/scale vectors gracefully if not computed in forward. <br> • Output `dense_mat` in stash has correct dimensions after subsetting. | #1           | §5        |
| CT-1.4 | **Unit Tests for `basis` Transform (PCA)**     | • Test schema loading and default parameter merging. <br> • Test `forward_step.basis` (PCA): correct HDF5 outputs, plan updates, descriptor content. <br> • Test `invert_step.basis` (PCA): reconstruction accuracy, subsetting logic. <br> • Test `storage_order` handling. <br> • Test with 2D matrix and 4D array inputs.                                                                                                        | • All unit tests pass. <br> • Covers various `k`, `center`, `scale` combinations. <br> • Reconstruction error is within expected bounds for PCA.                                                                                                                                                                                                                                                                                                                                                                | #1           | §8        |

---

**Epic CT-E2: `embed` Transform (Method #1 - applying a basis)**
*Goal: Implement the core `embed` transform to project data onto a pre-computed basis.*
*(Corresponds to parts of M2-E2 in the overall plan)*

| #      | Ticket                                         | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                   | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Appendix Ref | Spec Refs |
| :----- | :--------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- | :-------- |
| CT-2.1 | **`embed` Schema & Defaults (`embed.schema.json`)** | • Create `inst/schemas/embed.schema.json`. <br> • Define params: `basis_path` (string, HDF5 path, required), `center_data_with` (string, HDF5 path to mean vector, optional), `scale_data_with` (string, HDF5 path to scale vector, optional). <br> • Ensure `lna:::default_params("embed")` works.                                                                                                                                        | • `embed.schema.json` is valid. <br> • `lna:::default_params("embed")` correctly returns defaults (empty paths/nulls). <br> • Validation error if `basis_path` not provided by user.                                                                                                                                                                                                                                                                                                                          | #1           | §5, §7    |
| CT-2.2 | **`forward_step.embed`**                       | • Implement `forward_step.embed`. <br> • Input: `handle$stash$dense_mat`. <br> • Logic: Load basis matrix from `desc$params$basis_path` (HDF5 read). Load centering/scaling vectors from HDF5 if paths provided. Apply (center)/scale to input data. Project onto basis: `coefficients = (data - mean) / scale %*% basis_matrix_properly_oriented`. <br> • Store: Coefficient matrix as HDF5 payload. <br> • `desc`: Update. <br> • `stash`: Output `coefficients`. | • `write_lna` with `transforms=c("basis", "embed")` computes and stores coefficients. <br> • `embed` correctly loads basis, mean, scale from HDF5 paths specified in its params (which were typically output by `basis`). <br> • Coefficients are computed correctly. <br> • Handles different orientations of basis matrix based on its dimensions relative to data. <br> • `desc$outputs` correctly names the stashed coefficients.                                                                           | #1           | §5        |
| CT-2.3 | **`invert_step.embed`**                        | • Implement `invert_step.embed`. <br> • Input: Reconstructed coefficients (e.g., `dequantized_coefficients`) from `handle$stash`. <br> • Logic: Load basis matrix, mean, scale from HDF5 paths in `desc`. Reconstruct pre-projection data: `data_approx = coefficients %*% t(basis_matrix) * scale + mean`. <br> • Apply `handle$subset` (ROI on basis/mean/scale, time on coefficients). <br> • `stash`: Output `data_approx` (e.g., `reconstructed_from_embedding`). | • In `basis`->`embed` inverse chain, `invert_step.embed` uses de-quantized coefficients to reconstruct data passed to `invert_step.basis`. <br> • Correctly applies ROI subsetting to basis/mean/scale and time subsetting to coefficients. <br> • Handles missing mean/scale vectors gracefully. <br> • `desc$inputs` from forward pass is used as output key for stash.                                                                                                                                          | #1           | §5        |
| CT-2.4 | **Unit Tests for `embed` Transform**           | • Test schema loading and default parameter merging. <br> • Test `forward_step.embed`: HDF5 output of coefficients, plan updates, descriptor content, loading of basis/mean/scale. <br> • Test `invert_step.embed`: reconstruction accuracy, subsetting logic. <br> • Test with `basis` transform in pipeline.                                                                                                                               | • All unit tests pass. <br> • Covers scenarios with/without centering/scaling. <br> • End-to-end `basis` -> `embed` -> `quant` -> `read_lna` works.                                                                                                                                                                                                                                                                                                                                                                 | #1           | §8        |

---

**Epic CT-E3: `quant` Transform Enhancements (Method #6 - μ-Law, per-voxel)**
*Goal: Extend the existing `quant` transform to support non-uniform quantization methods and per-voxel scope.*
*(Builds upon M1-16, M1-17 from overall plan)*

| #      | Ticket                                                    | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                      | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Appendix Ref | Spec Refs |
| :----- | :-------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- | :-------- |
| CT-3.1 | **`quant` Schema Update (μ-Law, Scope, Entropy)**         | • Update `inst/schemas/quant.schema.json`. <br> • `method`: Add `"mu_law"`, `"lloyd_max"` (Lloyd-Max is stretch). Default "uniform". <br> • `mu_value` (number, default 255, for `method="mu_law"`). <br> • `scope`: Add enum "voxel", "global" (default "global"). <br> • `entropy_coder` (enum: "none", "huffman", "arithmetic"; default "none". Huffman/Arithmetic are stretch).                                                                     | • `quant.schema.json` updated and valid. <br> • `lna:::default_params("quant")` reflects new defaults.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | #6           | §5, §7    |
| CT-3.2 | **`forward_step.quant` (μ-Law, Voxel Scope)**             | • Extend `forward_step.quant`. <br> • Implement `method="mu_law"`: apply μ-law companding. <br> • Implement `scope="voxel"`: compute & store per-voxel min/max (for uniform/μ-law scaling) or Lloyd-Max codebooks. HDF5 path: `/scans/{run_id}/quant_params/transform_XX/min_max_per_voxel` etc. <br> • (Stretch) Implement basic Huffman or Range coding for `entropy_coder` if symbols are few.                                                                 | • `write_lna` with `quant` using `method="mu_law"` works. <br> • `write_lna` with `quant` using `scope="voxel"` computes and stores per-voxel scaling parameters. <br> • Quantized symbols and parameters stored correctly in HDF5. <br> • Combination of `method="mu_law"` and `scope="voxel"` works.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | #6           | §5        |
| CT-3.3 | **`invert_step.quant` (μ-Law, Voxel Scope)**              | • Extend `invert_step.quant`. <br> • Implement inverse μ-law expansion. <br> • If `scope="voxel"`, load per-voxel parameters for dequantization. <br> • (Stretch) Implement Huffman/Range decoding. <br> • Ensure `handle$subset` (ROI, time) is correctly applied, especially with per-voxel params.                                                                                                                                             | • `read_lna` correctly dequantizes data written with `method="mu_law"`. <br> • `read_lna` correctly dequantizes data written with `scope="voxel"`, using per-voxel params. <br> • Subsetting with `scope="voxel"` correctly applies to parameters and data. <br> • Reconstruction accuracy is as expected for the chosen method/bits.                                                                                                                                                                                                                                                                                                                                                                                                                                                           | #6           | §5        |
| CT-3.4 | **Unit Tests for `quant` (μ-Law, Voxel Scope, Entropy)**  | • Test schema updates and new defaults. <br> • Test μ-law forward/inverse accuracy. <br> • Test voxel-scope forward/inverse, including storage/retrieval of per-voxel params and subsetting. <br> • (Stretch) Test entropy coding/decoding if implemented.                                                                                                                                                                                      | • All unit tests pass. <br> • Covers different bit depths and combinations of method/scope.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | #6           | §8        |

---

**Epic CT-E4: `delta` Transform (Method #5 - Δ-Frame / RLE)**
*Goal: Implement the core `delta` transform for temporal difference coding and basic Run-Length Encoding.*
*(Corresponds to parts of M3-E1 in the overall plan)*

| #      | Ticket                                               | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                               | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Appendix Ref | Spec Refs |
| :----- | :--------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- | :-------- |
| CT-4.1 | **`delta` Schema & Defaults (`delta.schema.json`)**    | • Create `inst/schemas/delta.schema.json`. <br> • Define params: `order` (integer, default 1), `axis` (integer, default -1 for last axis), `reference_value_storage` (enum: "first_value_verbatim", "reconstruct_from_deltas", default "first_value_verbatim"), `delta_quantization_bits` (integer, optional/nullable), `coding_method` (enum: "none", "rle", default "none"). Arithmetic/Range coding can be deferred.                              | • `delta.schema.json` is valid. <br> • `lna:::default_params("delta")` correctly returns defaults.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | #5           | §5, §7    |
| CT-4.2 | **`forward_step.delta` (Order 1, RLE)**              | • Implement `forward_step.delta`. <br> • Support `order=1`. <br> • Compute differences along `axis`. <br> • Store first frame/value if `reference_value_storage="first_value_verbatim"`. <br> • Implement `coding_method="rle"`: apply RLE to deltas (store lengths and values). <br> • If `delta_quantization_bits` specified, quantize deltas before RLE/storage. <br> • Store deltas (or RLE stream) and first value(s) as HDF5 payloads. <br> • Update `desc`, `stash`. | • `write_lna` with `transforms="delta"` (order 1) correctly stores first value and delta stream. <br> • `coding_method="rle"` correctly applies RLE and stores lengths/values. <br> • Handles multi-dimensional array inputs correctly based on `axis`. <br> • Optional delta quantization works.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | #5           | §5        |
| CT-4.3 | **`invert_step.delta` (Order 1, RLE)**               | • Implement `invert_step.delta`. <br> • Load first value(s) and delta stream. <br> • Decode RLE if `coding_method="rle"`. <br> • Dequantize deltas if `delta_quantization_bits` was used. <br> • Reconstruct original series by cumulative summation. <br> • Apply `handle$subset` (e.g., time subsetting on reconstructed series). <br> • Update `stash`.                                                                                                        | • `read_lna` correctly reconstructs data from delta representation. <br> • RLE decoding works. <br> • Delta dequantization works. <br> • Subsetting applied to the final reconstructed series works as expected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | #5           | §5        |
| CT-4.4 | **Unit Tests for `delta` Transform (Order 1, RLE)**  | • Test schema loading and defaults. <br> • Test `forward_step.delta`: correct HDF5 outputs (first value, deltas/RLE stream), plan updates, descriptor. Test various `axis` values. <br> • Test `invert_step.delta`: reconstruction accuracy, RLE decoding, subsetting. <br> • Test with/without delta quantization. <br> • Test in pipeline (e.g., after `quant` or `embed`).                                                                             | • All unit tests pass. <br> • Covers 1D, 2D, and 3D+ input data with different `axis` choices. <br> • Reconstruction is lossless if no delta quantization used.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | #5           | §8        |

---

**Epic CT-E5: `temporal` Transform (Method #8 - DCT, B-Splines)**
*Goal: Implement the core `temporal` transform for projecting data onto temporal bases.*
*(Corresponds to parts of M3-E1 in the overall plan)*

| #      | Ticket                                                       | Description / Deliverables                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Acceptance Criteria                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Appendix Ref | Spec Refs |
| :----- | :----------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------- | :-------- |
| CT-5.1 | **`temporal` Schema & Defaults (`temporal.schema.json`)**    | • Create `inst/schemas/temporal.schema.json`. <br> • Params: `kind` (enum: "dct", "bspline", "dpss", "polynomial"; default "dct"), `n_basis` (integer, required or default to N_time), `order` (integer, for bspline/poly, default 3), `knot_vector_path` or `knot_spacing_method` (for bspline), `time_bandwidth_product` (for dpss), `scope` (enum: "global", "voxelwise"; default "global"). <br> • DPSS and voxelwise scope can be stretch goals.                           | • `temporal.schema.json` is valid. <br> • `lna:::default_params("temporal")` correctly returns defaults.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | #8           | §5, §7    |
| CT-5.2 | **`forward_step.temporal` (DCT & B-Spline)**                 | • Implement `forward_step.temporal`. <br> • Support `kind="dct"`: Generate DCT basis matrix. <br> • Support `kind="bspline"`: Generate B-spline basis matrix (e.g., using `splines::bs`). Handle knot definition/generation. <br> • Input: `dense_mat` or `spatial_coefficients` (Time x Features). <br> • Project input data onto chosen temporal basis. <br> • Store: Temporal basis matrix and (if `kind="bspline"` and knots explicit) knot vector as HDF5 payloads. Store coefficients. <br> • Update `desc`, `stash` (output `temporal_coefficients`). | • `write_lna` with `transforms="temporal"` (`kind="dct"` or `"bspline"`) correctly computes and stores temporal basis and coefficients. <br> • `n_basis` and other kind-specific parameters are handled. <br> • B-spline knot generation/storage works. <br> • Handles input data that is 2D (Time x Voxels) or 4D (X,Y,Z,Time) by appropriately reshaping.                                                                                                                                                                                                                                                                                                                                                                                        | #8           | §5        |
| CT-5.3 | **`invert_step.temporal` (DCT & B-Spline)**                  | • Implement `invert_step.temporal`. <br> • Input: `temporal_coefficients` from `handle$stash`. <br> • Logic: Load temporal basis matrix (and knots if bspline) from HDF5 paths in `desc`. Reconstruct data: `data_reconstructed = temporal_basis_matrix %*% temporal_coefficients`. <br> • Apply `handle$subset` (time subsetting on coefficients before multiplication, or on reconstructed time series; ROI/voxel subsetting on the feature dimension of reconstructed data). <br> • Update `stash`. | • `read_lna` correctly reconstructs data from DCT/B-spline temporal representation. <br> • Subsetting on time and features (voxels/spatial components) works correctly. <br> • Reconstruction accuracy is as expected (lossless if `n_basis` = N_time).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | #8           | §5        |
| CT-5.4 | **Unit Tests for `temporal` Transform (DCT & B-Spline)**     | • Test schema loading and defaults. <br> • Test `forward_step.temporal` (DCT, B-spline): HDF5 outputs, plan updates, descriptor. <br> • Test `invert_step.temporal` (DCT, B-spline): reconstruction accuracy, subsetting. <br> • Test various `n_basis` and `kind`-specific parameters. <br> • Test reshaping for 4D inputs. <br> • Test in pipeline (e.g., before or after `quant`).                                                                                        | • All unit tests pass. <br> • Covers different `kind` options and parameters. <br> • Works for typical fMRI data dimensions.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | #8           | §8        |

---

This set of tickets provides a granular breakdown for implementing the core LNA transforms described. Each epic can be further broken down if multiple developers are involved. Remember to integrate these with the overall Phase 2/3 plans.